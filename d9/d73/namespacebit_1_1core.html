<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bit::core: bit::core Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bit::core
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d9f/namespacebit.html">bit</a></li><li class="navelem"><a class="el" href="../../d9/d73/namespacebit_1_1core.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bit::core Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The standard namespace for this project.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:db/ddf/namespacebit_1_1core_1_1adl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/ddf/namespacebit_1_1core_1_1adl.html">adl</a></td></tr>
<tr class="memdesc:db/ddf/namespacebit_1_1core_1_1adl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for managing functions template for forward declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/dc3/namespacebit_1_1core_1_1casts"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc3/namespacebit_1_1core_1_1casts.html">casts</a></td></tr>
<tr class="memdesc:db/dc3/namespacebit_1_1core_1_1casts"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline namespace for managing cast utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/d6a/namespacebit_1_1core_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d6a/namespacebit_1_1core_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:d1/d6a/namespacebit_1_1core_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private namespace for managing implementation-details within headers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d4a/namespacebit_1_1core_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d4a/namespacebit_1_1core_1_1literals.html">literals</a></td></tr>
<tr class="memdesc:d6/d4a/namespacebit_1_1core_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline namespace for managing literal operators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:d0/dd3/structbit_1_1core_1_1aligned__storage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/dd3/structbit_1_1core_1_1aligned__storage">aligned_storage</a></td></tr>
<tr class="memdesc:d0/dd3/structbit_1_1core_1_1aligned__storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a PODType suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align.  <a href="../../d9/d73/namespacebit_1_1core.html#d0/dd3/structbit_1_1core_1_1aligned__storage">More...</a><br /></td></tr>
<tr class="separator:d0/dd3/structbit_1_1core_1_1aligned__storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d5f/classbit_1_1core_1_1allocator__deleter.html">allocator_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deleter for use with standard allocators.  <a href="../../d1/d5f/classbit_1_1core_1_1allocator__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d55/structbit_1_1core_1_1are__associative__containers.html">are_associative_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all Containers.  <a href="../../dd/d55/structbit_1_1core_1_1are__associative__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d70/structbit_1_1core_1_1are__bidirectional__iterators.html">are_bidirectional_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all BidirectionalIterators.  <a href="../../d4/d70/structbit_1_1core_1_1are__bidirectional__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc3/structbit_1_1core_1_1are__containers.html">are_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all Containers.  <a href="../../db/dc3/structbit_1_1core_1_1are__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d4c/structbit_1_1core_1_1are__contiguous__containers.html">are_contiguous_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all ContiguousContainers.  <a href="../../d3/d4c/structbit_1_1core_1_1are__contiguous__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d59/structbit_1_1core_1_1are__copy__assignable.html">are_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all copy-assignable.  <a href="../../d8/d59/structbit_1_1core_1_1are__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d55/structbit_1_1core_1_1are__copy__constructible.html">are_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all copy-constructible.  <a href="../../dc/d55/structbit_1_1core_1_1are__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dae/structbit_1_1core_1_1are__default__constructible.html">are_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all default-constructible.  <a href="../../d5/dae/structbit_1_1core_1_1are__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dff/structbit_1_1core_1_1are__destructible.html">are_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all destructible.  <a href="../../d1/dff/structbit_1_1core_1_1are__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d9d/structbit_1_1core_1_1are__different.html">are_different</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that all types are different types.  <a href="../../d7/d9d/structbit_1_1core_1_1are__different.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d8c/structbit_1_1core_1_1are__different_3_01_t_00_01_t_00_01_ts_8_8_8_01_4.html">are_different&lt; T, T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d55/structbit_1_1core_1_1are__different_3_01_t_00_01_u_00_01_ts_8_8_8_01_4.html">are_different&lt; T, U, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7c/structbit_1_1core_1_1are__equality__comparable.html">are_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all EqualityComparable.  <a href="../../d9/d7c/structbit_1_1core_1_1are__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d68/structbit_1_1core_1_1are__forward__iterators.html">are_forward_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all ForwardIterators.  <a href="../../d6/d68/structbit_1_1core_1_1are__forward__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df0/structbit_1_1core_1_1are__input__iterators.html">are_input_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all InputIterators.  <a href="../../d9/df0/structbit_1_1core_1_1are__input__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d6a/structbit_1_1core_1_1are__iterators.html">are_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all Iterators.  <a href="../../db/d6a/structbit_1_1core_1_1are__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/da8/structbit_1_1core_1_1are__member__function__pointers.html">are_member_function_pointers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/df5/structbit_1_1core_1_1are__member__pointers.html">are_member_pointers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/structbit_1_1core_1_1are__move__assignable.html">are_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all move-assignable.  <a href="../../d4/db4/structbit_1_1core_1_1are__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/structbit_1_1core_1_1are__move__constructible.html">are_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all move-constructible.  <a href="../../d9/d6c/structbit_1_1core_1_1are__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/da4/structbit_1_1core_1_1are__nothrow__copy__assignable.html">are_nothrow_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all nothrow copy-assignable.  <a href="../../d5/da4/structbit_1_1core_1_1are__nothrow__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de2/structbit_1_1core_1_1are__nothrow__copy__constructible.html">are_nothrow_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all copy-constructible.  <a href="../../d0/de2/structbit_1_1core_1_1are__nothrow__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8e/structbit_1_1core_1_1are__nothrow__default__constructible.html">are_nothrow_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all nothrow default-constructible.  <a href="../../da/d8e/structbit_1_1core_1_1are__nothrow__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2e/structbit_1_1core_1_1are__nothrow__destructible.html">are_nothrow_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all destructible.  <a href="../../d6/d2e/structbit_1_1core_1_1are__nothrow__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d19/structbit_1_1core_1_1are__nothrow__move__assignable.html">are_nothrow_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all nothrow move-assignable.  <a href="../../d8/d19/structbit_1_1core_1_1are__nothrow__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d41/structbit_1_1core_1_1are__nothrow__move__constructible.html">are_nothrow_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all move-constructible.  <a href="../../db/d41/structbit_1_1core_1_1are__nothrow__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3c/structbit_1_1core_1_1are__nullable__pointers.html">are_nullable_pointers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all Containers.  <a href="../../d2/d3c/structbit_1_1core_1_1are__nullable__pointers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/de2/structbit_1_1core_1_1are__random__access__iterators.html">are_random_access_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all RandomAccessIterators.  <a href="../../d6/de2/structbit_1_1core_1_1are__random__access__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dde/structbit_1_1core_1_1are__ranges.html">are_ranges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dcb/structbit_1_1core_1_1are__reverse__ranges.html">are_reverse_ranges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8f/structbit_1_1core_1_1are__reversible__containers.html">are_reversible_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all ReversibleContainers.  <a href="../../de/d8f/structbit_1_1core_1_1are__reversible__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dbf/structbit_1_1core_1_1are__same.html">are_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that all types are the same type.  <a href="../../d0/dbf/structbit_1_1core_1_1are__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dba/structbit_1_1core_1_1are__same_3_01_t_00_01_t_01_4.html">are_same&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d87/structbit_1_1core_1_1are__same_3_01_t_00_01_t_00_01_ts_8_8_8_01_4.html">are_same&lt; T, T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da6/structbit_1_1core_1_1are__sequence__containers.html">are_sequence_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all SequenceContainers.  <a href="../../db/da6/structbit_1_1core_1_1are__sequence__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd7/structbit_1_1core_1_1are__trivially__copy__assignable.html">are_trivially_copy_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all trivially copy-assignable.  <a href="../../d8/dd7/structbit_1_1core_1_1are__trivially__copy__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d34/structbit_1_1core_1_1are__trivially__copy__constructible.html">are_trivially_copy_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all copy-constructible.  <a href="../../dc/d34/structbit_1_1core_1_1are__trivially__copy__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d13/structbit_1_1core_1_1are__trivially__default__constructible.html">are_trivially_default_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all trivially default-constructible.  <a href="../../df/d13/structbit_1_1core_1_1are__trivially__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d81/structbit_1_1core_1_1are__trivially__destructible.html">are_trivially_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all destructible.  <a href="../../d2/d81/structbit_1_1core_1_1are__trivially__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d61/structbit_1_1core_1_1are__trivially__move__assignable.html">are_trivially_move_assignable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all trivially move-assignable.  <a href="../../dc/d61/structbit_1_1core_1_1are__trivially__move__assignable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d90/structbit_1_1core_1_1are__trivially__move__constructible.html">are_trivially_move_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a set of types are all move-constructible.  <a href="../../d9/d90/structbit_1_1core_1_1are__trivially__move__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/dff/structbit_1_1core_1_1arity"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/dff/structbit_1_1core_1_1arity">arity</a></td></tr>
<tr class="memdesc:d0/dff/structbit_1_1core_1_1arity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine the arity of a function.  <a href="../../d9/d73/namespacebit_1_1core.html#d0/dff/structbit_1_1core_1_1arity">More...</a><br /></td></tr>
<tr class="separator:d0/dff/structbit_1_1core_1_1arity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0e/structbit_1_1core_1_1arity_3_01_fn_01_6_01_4.html">arity&lt; Fn &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d37/structbit_1_1core_1_1arity_3_01_fn_01_6_6_01_4.html">arity&lt; Fn &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d47/structbit_1_1core_1_1arity_3_01_r_07_5_08_07_types_8_8_8_08_4.html">arity&lt; R(*)(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d8f/structbit_1_1core_1_1arity_3_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01const_01_4.html">arity&lt; R(C::*)(Types...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3a/structbit_1_1core_1_1arity_3_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01const_01volatile_01_4.html">arity&lt; R(C::*)(Types...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d77/structbit_1_1core_1_1arity_3_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01volatile_01_4.html">arity&lt; R(C::*)(Types...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc4/structbit_1_1core_1_1arity_3_01_r_07_c_1_1_5_08_07_types_8_8_8_08_4.html">arity&lt; R(C::*)(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9a/structbit_1_1core_1_1arity_3_01_r_07_types_8_8_8_08_01const_01_4.html">arity&lt; R(Types...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4e/structbit_1_1core_1_1arity_3_01_r_07_types_8_8_8_08_01const_01volatile_01_4.html">arity&lt; R(Types...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dbb/structbit_1_1core_1_1arity_3_01_r_07_types_8_8_8_08_01volatile_01_4.html">arity&lt; R(Types...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d9d/structbit_1_1core_1_1arity_3_01_r_07_types_8_8_8_08_4.html">arity&lt; R(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable wrapper around non-owned contiguous data.  <a href="../../d6/da4/classbit_1_1core_1_1array__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/ded/classbit_1_1core_1_1bad__expected__access.html">bad_expected_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception type thrown when accessing a non-active expected member.  <a href="../../df/ded/classbit_1_1core_1_1bad__expected__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d5a/classbit_1_1core_1_1bad__expected__access_3_01void_01_4.html">bad_expected_access&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d90/classbit_1_1core_1_1bad__optional__access.html">bad_optional_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when an optional is attempted to be accessed while not containing a value.  <a href="../../df/d90/classbit_1_1core_1_1bad__optional__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dae/classbit_1_1core_1_1bad__variant__access.html">bad_variant_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by variant.  <a href="../../d1/dae/classbit_1_1core_1_1bad__variant__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/structbit_1_1core_1_1base__type.html">base_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the base type of T without modifiers.  <a href="../../dc/d7b/structbit_1_1core_1_1base__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d97/structbit_1_1core_1_1base__type_3_01_t_01_6_01_4.html">base_type&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d75/structbit_1_1core_1_1base__type_3_01_t_01_6_6_01_4.html">base_type&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8e/structbit_1_1core_1_1base__type_3_01_t_01_5_01_4.html">base_type&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dea/classbit_1_1core_1_1basic__string__span.html">basic_string_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight non-owning wrapper around strings.  <a href="../../d7/dea/classbit_1_1core_1_1basic__string__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around non-owned strings.  <a href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d37/classbit_1_1core_1_1basic__zstring__span.html">basic_zstring_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight non-owning wrapper around strings.  <a href="../../da/d37/classbit_1_1core_1_1basic__zstring__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d43/classbit_1_1core_1_1basic__zstring__view.html">basic_zstring_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around non-owned zero-terminated strings.  <a href="../../d6/d43/classbit_1_1core_1_1basic__zstring__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html">bool_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility metafunction provides compile-time boolean values as an integral constant.  <a href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html" title="compressed_pair is a struct template that provides a way to store two heterogeneous objects as a sing...">compressed_pair</a></code> is a <code>struct</code> template that provides a way to store two heterogeneous objects as a single unit that leverages empty-base-optimization  <a href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple that leverages EBO to compress types.  <a href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/d95/structbit_1_1core_1_1conjunction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a></td></tr>
<tr class="memdesc:d7/d95/structbit_1_1core_1_1conjunction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine the <a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html" title="This utility metafunction provides compile-time boolean values as an integral constant. ">bool_constant</a> from a logical AND operation of other bool_constants.  <a href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">More...</a><br /></td></tr>
<tr class="separator:d7/d95/structbit_1_1core_1_1conjunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3f/structbit_1_1core_1_1conjunction_3_01_b1_01_4.html">conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d1c/structbit_1_1core_1_1conjunction_3_01_b1_00_01_bn_8_8_8_01_4.html">conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/df2/classbit_1_1core_1_1delegate"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a></td></tr>
<tr class="memdesc:d0/df2/classbit_1_1core_1_1delegate"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is for a lightweight way of managing function callbacks without requiring heap allocations.  <a href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">More...</a><br /></td></tr>
<tr class="separator:d0/df2/classbit_1_1core_1_1delegate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd4/classbit_1_1core_1_1delegate_3_01_r_07_types_8_8_8_08_4.html">delegate&lt; R(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dec/structbit_1_1core_1_1disable__if.html">disable_if</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/d04/structbit_1_1core_1_1disable__if_3_01true_00_01_t_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d04/structbit_1_1core_1_1disable__if_3_01true_00_01_t_01_4">disable_if&lt; true, T &gt;</a></td></tr>
<tr class="separator:d7/d04/structbit_1_1core_1_1disable__if_3_01true_00_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de0/structbit_1_1core_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine the <code><a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html" title="This utility metafunction provides compile-time boolean values as an integral constant. ">bool_constant</a></code> from a logical OR operations of other <a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html" title="This utility metafunction provides compile-time boolean values as an integral constant. ">bool_constant</a>.  <a href="../../d5/de0/structbit_1_1core_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d78/structbit_1_1core_1_1disjunction_3_01_b1_01_4.html">disjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d33/structbit_1_1core_1_1disjunction_3_01_b1_00_01_bn_8_8_8_01_4.html">disjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d3e/structbit_1_1core_1_1empty"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#dc/d3e/structbit_1_1core_1_1empty">empty</a></td></tr>
<tr class="memdesc:dc/d3e/structbit_1_1core_1_1empty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that always expands into an empty struct with no members or type members.  <a href="../../d9/d73/namespacebit_1_1core.html#dc/d3e/structbit_1_1core_1_1empty">More...</a><br /></td></tr>
<tr class="separator:dc/d3e/structbit_1_1core_1_1empty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dd9/structbit_1_1core_1_1enable__if.html">enable_if</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/de6/structbit_1_1core_1_1enable__if_3_01false_00_01_t_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/de6/structbit_1_1core_1_1enable__if_3_01false_00_01_t_01_4">enable_if&lt; false, T &gt;</a></td></tr>
<tr class="separator:d0/de6/structbit_1_1core_1_1enable__if_3_01false_00_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d3e/structbit_1_1core_1_1enable__overload__if.html">enable_overload_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="../../d8/dd9/structbit_1_1core_1_1enable__if.html">enable_if</a>, but doesn't sfinae-away a type; instead produces an uninstantiable unique type when true.  <a href="../../dd/d3e/structbit_1_1core_1_1enable__overload__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d0a/structbit_1_1core_1_1enable__overload__if_3_01false_00_01_t_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#dc/d0a/structbit_1_1core_1_1enable__overload__if_3_01false_00_01_t_01_4">enable_overload_if&lt; false, T &gt;</a></td></tr>
<tr class="separator:dc/d0a/structbit_1_1core_1_1enable__overload__if_3_01false_00_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An RAII wrapper around an allocated piece of memory with unique ownership semantics.  <a href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d8f/classbit_1_1core_1_1expected_3_01void_00_01_e_01_4.html">expected&lt; void, E &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d21/structbit_1_1core_1_1function__argument"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#dc/d21/structbit_1_1core_1_1function__argument">function_argument</a></td></tr>
<tr class="memdesc:dc/d21/structbit_1_1core_1_1function__argument"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to access the <code>Ith</code> argument type of a given function.  <a href="../../d9/d73/namespacebit_1_1core.html#dc/d21/structbit_1_1core_1_1function__argument">More...</a><br /></td></tr>
<tr class="separator:dc/d21/structbit_1_1core_1_1function__argument"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d5d/structbit_1_1core_1_1function__argument_3_01_i_00_01_fn_01_6_01_4.html">function_argument&lt; I, Fn &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dea/structbit_1_1core_1_1function__argument_3_01_i_00_01_fn_01_6_6_01_4.html">function_argument&lt; I, Fn &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd6/structbit_1_1core_1_1function__argument_3_01_i_00_01_r_07_5_08_07_types_8_8_8_08_4.html">function_argument&lt; I, R(*)(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df7/structbit_1_1core_1_1function__argument_3_01_i_00_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01const_01_4.html">function_argument&lt; I, R(C::*)(Types...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d39/structbit_1_1core_1_1function__argument_3_01_i_00_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01const_01volatile_01_4.html">function_argument&lt; I, R(C::*)(Types...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/de5/structbit_1_1core_1_1function__argument_3_01_i_00_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01volatile_01_4.html">function_argument&lt; I, R(C::*)(Types...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dd8/structbit_1_1core_1_1function__argument_3_01_i_00_01_r_07_c_1_1_5_08_07_types_8_8_8_08_4.html">function_argument&lt; I, R(C::*)(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/db1/structbit_1_1core_1_1function__argument_3_01_i_00_01_r_07_types_8_8_8_08_01const_01_4.html">function_argument&lt; I, R(Types...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d5a/structbit_1_1core_1_1function__argument_3_01_i_00_01_r_07_types_8_8_8_08_01const_01volatile_01_4.html">function_argument&lt; I, R(Types...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc9/structbit_1_1core_1_1function__argument_3_01_i_00_01_r_07_types_8_8_8_08_01volatile_01_4.html">function_argument&lt; I, R(Types...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7e/structbit_1_1core_1_1function__argument_3_01_i_00_01_r_07_types_8_8_8_08_4.html">function_argument&lt; I, R(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/d73/structbit_1_1core_1_1function__signature"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d1/d73/structbit_1_1core_1_1function__signature">function_signature</a></td></tr>
<tr class="memdesc:d1/d73/structbit_1_1core_1_1function__signature"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to extract the signature of a given function type.  <a href="../../d9/d73/namespacebit_1_1core.html#d1/d73/structbit_1_1core_1_1function__signature">More...</a><br /></td></tr>
<tr class="separator:d1/d73/structbit_1_1core_1_1function__signature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d25/structbit_1_1core_1_1function__signature_3_01_fn_01_6_01_4.html">function_signature&lt; Fn &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d5a/structbit_1_1core_1_1function__signature_3_01_fn_01_6_6_01_4.html">function_signature&lt; Fn &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dde/structbit_1_1core_1_1function__signature_3_01_fn_01_5_01_4.html">function_signature&lt; Fn * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc6/structbit_1_1core_1_1function__signature_3_01_r_07_arg_types_8_8_8_08_01const_01_4.html">function_signature&lt; R(ArgTypes...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d65/structbit_1_1core_1_1function__signature_3_01_r_07_arg_types_8_8_8_08_01const_01volatile_01_4.html">function_signature&lt; R(ArgTypes...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/structbit_1_1core_1_1function__signature_3_01_r_07_arg_types_8_8_8_08_01volatile_01_4.html">function_signature&lt; R(ArgTypes...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d1a/structbit_1_1core_1_1function__signature_3_01_r_07_arg_types_8_8_8_08_4.html">function_signature&lt; R(ArgTypes...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d99/structbit_1_1core_1_1function__signature_3_01_r_07_c_1_1_5_08_07_arg_types_8_8_8_08_01const_01_4.html">function_signature&lt; R(C::*)(ArgTypes...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/daf/structbit_1_1core_1_1function__signature_3_01_r_07_c_1_1_5_08_07_arg_types_8_8_8_08_01const_01volatile_01_4.html">function_signature&lt; R(C::*)(ArgTypes...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d49/structbit_1_1core_1_1function__signature_3_01_r_07_c_1_1_5_08_07_arg_types_8_8_8_08_01volatile_01_4.html">function_signature&lt; R(C::*)(ArgTypes...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d93/structbit_1_1core_1_1function__signature_3_01_r_07_c_1_1_5_08_07_arg_types_8_8_8_08_4.html">function_signature&lt; R(C::*)(ArgTypes...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d10/structbit_1_1core_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash struct that satisfies the requirements of <code>std::hash</code>, but is implemented in terms of hash_value to allow for easy ADL overloads and type-querying.  <a href="../../db/d10/structbit_1_1core_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d71/structbit_1_1core_1_1in__place__index__t.html">in_place_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a special disambiguation tag for variadic functions, used in any and optional.  <a href="../../d0/d71/structbit_1_1core_1_1in__place__index__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d6f/structbit_1_1core_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a special disambiguation tag for variadic functions, used in any and optional.  <a href="../../dd/d6f/structbit_1_1core_1_1in__place__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dcd/structbit_1_1core_1_1in__place__type__t.html">in_place_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a special disambiguation tag for variadic functions, used in any and optional.  <a href="../../da/dcd/structbit_1_1core_1_1in__place__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d2e/structbit_1_1core_1_1index__of__type.html">index_of_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine the index of <code>T</code> in the variadic pack <code>Types</code>.  <a href="../../da/d2e/structbit_1_1core_1_1index__of__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d0a/structbit_1_1core_1_1insensitive__char__traits.html">insensitive_char_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Char traits to allow case-insensitive comparisons for strings.  <a href="../../de/d0a/structbit_1_1core_1_1insensitive__char__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d73/structbit_1_1core_1_1invoke__result.html">invoke_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/ddd/structbit_1_1core_1_1is__associative__container.html">is_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a AssociativeContainer.  <a href="../../d5/ddd/structbit_1_1core_1_1is__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d19/structbit_1_1core_1_1is__base__of__all.html">is_base_of_all</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that <code>Base</code> is the base of all <code>Derived</code>.  <a href="../../d4/d19/structbit_1_1core_1_1is__base__of__all.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d80/structbit_1_1core_1_1is__base__of__any.html">is_base_of_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that <code>Base</code> is the base of any <code>Derived</code>.  <a href="../../d1/d80/structbit_1_1core_1_1is__base__of__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dcd/structbit_1_1core_1_1is__bidirectional__iterator.html">is_bidirectional_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a BidirectionalIterator.  <a href="../../d9/dcd/structbit_1_1core_1_1is__bidirectional__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df1/structbit_1_1core_1_1is__bool__constant.html">is_bool_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that determines whether <code>T</code> is a <a class="el" href="../../d1/d94/structbit_1_1core_1_1size__constant.html" title="This utility metafunction provides compile-time size values as an integral constant. ">size_constant</a>.  <a href="../../d2/df1/structbit_1_1core_1_1is__bool__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfb/structbit_1_1core_1_1is__bool__constant_3_01bool__constant_3_01_b_01_4_01_4.html">is_bool_constant&lt; bool_constant&lt; B &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d63/structbit_1_1core_1_1is__const__member__function__pointer.html">is_const_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>Func</code> is a const member function pointer.  <a href="../../d4/d63/structbit_1_1core_1_1is__const__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d56/structbit_1_1core_1_1is__const__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01_4.html">is_const_member_function_pointer&lt; R(C::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de7/structbit_1_1core_1_1is__const__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01volatile_01_4.html">is_const_member_function_pointer&lt; R(C::*)(Args...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d15/structbit_1_1core_1_1is__container.html">is_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a Container.  <a href="../../da/d15/structbit_1_1core_1_1is__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dcd/structbit_1_1core_1_1is__contiguous__container.html">is_contiguous_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a ContiguousContainer.  <a href="../../d0/dcd/structbit_1_1core_1_1is__contiguous__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d19/structbit_1_1core_1_1is__cv__member__function__pointer.html">is_cv_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>Func</code> is a const volatile member function pointer.  <a href="../../dd/d19/structbit_1_1core_1_1is__cv__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4e/structbit_1_1core_1_1is__cv__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01volatile_01_4.html">is_cv_member_function_pointer&lt; R(C::*)(Args...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3b/structbit_1_1core_1_1is__derived__from__all.html">is_derived_from_all</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that <code>Derived</code> is derived from all <code>Bases</code>.  <a href="../../de/d3b/structbit_1_1core_1_1is__derived__from__all.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d67/structbit_1_1core_1_1is__derived__from__any.html">is_derived_from_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that <code>Derived</code> is derived from any <code>Bases</code>.  <a href="../../d4/d67/structbit_1_1core_1_1is__derived__from__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d22/structbit_1_1core_1_1is__different.html">is_different</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if two types are different.  <a href="../../dd/d22/structbit_1_1core_1_1is__different.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d9b/structbit_1_1core_1_1is__different_3_01_t_00_01_t_01_4.html">is_different&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1e/structbit_1_1core_1_1is__dynamic__span.html">is_dynamic_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given type a dynamic span?  <a href="../../dd/d1e/structbit_1_1core_1_1is__dynamic__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dff/structbit_1_1core_1_1is__dynamic__span_3_01span_3_01_t_00_01dynamic__extent_01_4_01_4.html">is_dynamic_span&lt; span&lt; T, dynamic_extent &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dd1/structbit_1_1core_1_1is__equality__comparable.html">is_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a EqualityComparable.  <a href="../../d0/dd1/structbit_1_1core_1_1is__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/db9/structbit_1_1core_1_1is__expected.html">is_expected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dbd/structbit_1_1core_1_1is__expected_3_01expected_3_01_t_00_01_e_01_4_01_4.html">is_expected&lt; expected&lt; T, E &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dae/structbit_1_1core_1_1is__explicitly__constructible.html">is_explicitly_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether a type is explicitly constructible from a given set of arguments.  <a href="../../da/dae/structbit_1_1core_1_1is__explicitly__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d22/structbit_1_1core_1_1is__explicitly__convertible.html">is_explicitly_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if From is explicitly convertible to To.  <a href="../../de/d22/structbit_1_1core_1_1is__explicitly__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dd8/structbit_1_1core_1_1is__forward__iterator.html">is_forward_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d35/structbit_1_1core_1_1is__hashable.html">is_hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait determining whether <code>T</code> is hashable by an ADL call to <code>hash_value</code>.  <a href="../../d4/d35/structbit_1_1core_1_1is__hashable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/df7/structbit_1_1core_1_1is__implicitly__constructible.html">is_implicitly_constructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if T is implicitly constructible with braced initialization.  <a href="../../d3/df7/structbit_1_1core_1_1is__implicitly__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d0b/structbit_1_1core_1_1is__implicitly__convertible.html">is_implicitly_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if From is implicitly convertible to To.  <a href="../../d6/d0b/structbit_1_1core_1_1is__implicitly__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d5a/structbit_1_1core_1_1is__in__place.html">is_in_place</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if the type is an in_place type.  <a href="../../d3/d5a/structbit_1_1core_1_1is__in__place.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dfd/structbit_1_1core_1_1is__in__place_3_01in__place__index__t_3_01_i_01_4_01_4.html">is_in_place&lt; in_place_index_t&lt; I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df9/structbit_1_1core_1_1is__in__place_3_01in__place__t_01_4.html">is_in_place&lt; in_place_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dac/structbit_1_1core_1_1is__in__place_3_01in__place__type__t_3_01_t_01_4_01_4.html">is_in_place&lt; in_place_type_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/ddc/structbit_1_1core_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is an InputIterator.  <a href="../../d5/ddc/structbit_1_1core_1_1is__input__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/db1/structbit_1_1core_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is an Iterator.  <a href="../../d6/db1/structbit_1_1core_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5e/structbit_1_1core_1_1is__member__function__pointer.html">is_member_function_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de0/structbit_1_1core_1_1is__member__function__pointer_3_01_r_07_t_1_1_5_08_07_arg_types_8_8_8_08_01const_01_4.html">is_member_function_pointer&lt; R(T::*)(ArgTypes...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d1e/structbit_1_1core_1_1is__member__function__pointer_3_01_r_07_t_1_1_5_08_07_arg_types_8_8_8_08_01const_01volatile_01_4.html">is_member_function_pointer&lt; R(T::*)(ArgTypes...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d8c/structbit_1_1core_1_1is__member__function__pointer_3_01_r_07_t_1_1_5_08_07_arg_types_8_8_8_08_01volatile_01_4.html">is_member_function_pointer&lt; R(T::*)(ArgTypes...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d12/structbit_1_1core_1_1is__member__function__pointer_3_01_r_07_t_1_1_5_08_07_arg_types_8_8_8_08_4.html">is_member_function_pointer&lt; R(T::*)(ArgTypes...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1a/structbit_1_1core_1_1is__member__object__pointer.html">is_member_object_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/ddd/structbit_1_1core_1_1is__member__object__pointer_3_01_r_01_t_1_1_5_01_4.html">is_member_object_pointer&lt; R T::* &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddd/structbit_1_1core_1_1is__member__object__pointer_3_01_r_01_t_1_1_5const_01_4.html">is_member_object_pointer&lt; R T::*const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d51/structbit_1_1core_1_1is__member__object__pointer_3_01_r_01_t_1_1_5const_01volatile_01_4.html">is_member_object_pointer&lt; R T::*const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dc8/structbit_1_1core_1_1is__member__object__pointer_3_01_r_01_t_1_1_5volatile_01_4.html">is_member_object_pointer&lt; R T::*volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dfa/structbit_1_1core_1_1is__member__pointer.html">is_member_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0a/structbit_1_1core_1_1is__nothrow__hashable.html">is_nothrow_hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait determining whether <code>T</code> is nothrow hashable by an ADL call to <code>hash_value</code>.  <a href="../../df/d0a/structbit_1_1core_1_1is__nothrow__hashable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc1/structbit_1_1core_1_1is__nullable__pointer.html">is_nullable_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a Container.  <a href="../../db/dc1/structbit_1_1core_1_1is__nullable__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/dd9/structbit_1_1core_1_1is__one__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d6/dd9/structbit_1_1core_1_1is__one__of">is_one_of</a></td></tr>
<tr class="memdesc:d6/dd9/structbit_1_1core_1_1is__one__of"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> is one of <code>Ts</code>.  <a href="../../d9/d73/namespacebit_1_1core.html#d6/dd9/structbit_1_1core_1_1is__one__of">More...</a><br /></td></tr>
<tr class="separator:d6/dd9/structbit_1_1core_1_1is__one__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d9b/structbit_1_1core_1_1is__one__of_3_01_t_01_4.html">is_one_of&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d50/structbit_1_1core_1_1is__one__of_3_01_t_00_01_t_00_01_ts_8_8_8_01_4.html">is_one_of&lt; T, T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d44/structbit_1_1core_1_1is__one__of_3_01_t_00_01_t0_00_01_ts_8_8_8_01_4.html">is_one_of&lt; T, T0, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d51/structbit_1_1core_1_1is__optional.html">is_optional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/db9/structbit_1_1core_1_1is__optional_3_01optional_3_01_t_01_4_01_4.html">is_optional&lt; optional&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbe/structbit_1_1core_1_1is__random__access__iterator.html">is_random_access_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a RandomAccessIterator.  <a href="../../df/dbe/structbit_1_1core_1_1is__random__access__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d15/structbit_1_1core_1_1is__range.html">is_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/da1/structbit_1_1core_1_1is__reverse__range.html">is_reverse_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d83/structbit_1_1core_1_1is__reversible__container.html">is_reversible_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a ReversibleContainer.  <a href="../../d0/d83/structbit_1_1core_1_1is__reversible__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3d/structbit_1_1core_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if two types are the same.  <a href="../../d5/d3d/structbit_1_1core_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dd7/structbit_1_1core_1_1is__same_3_01_t_00_01_t_01_4.html">is_same&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d31/structbit_1_1core_1_1is__same__constness.html">is_same_constness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> and <code>U</code> have the same const- qualification.  <a href="../../d8/d31/structbit_1_1core_1_1is__same__constness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da4/structbit_1_1core_1_1is__same__cv.html">is_same_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> and <code>U</code> have the same cv- qualification.  <a href="../../de/da4/structbit_1_1core_1_1is__same__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d13/structbit_1_1core_1_1is__same__sign.html">is_same_sign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> and <code>U</code> have the same sign.  <a href="../../db/d13/structbit_1_1core_1_1is__same__sign.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d33/structbit_1_1core_1_1is__same__volatility.html">is_same_volatility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> and <code>U</code> have the same volatile- qualification.  <a href="../../db/d33/structbit_1_1core_1_1is__same__volatility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/structbit_1_1core_1_1is__sequence__container.html">is_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a SequenceContainer.  <a href="../../d5/d08/structbit_1_1core_1_1is__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d28/structbit_1_1core_1_1is__size__constant.html">is_size_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that determines whether <code>T</code> is a <a class="el" href="../../d1/d94/structbit_1_1core_1_1size__constant.html" title="This utility metafunction provides compile-time size values as an integral constant. ">size_constant</a>.  <a href="../../d3/d28/structbit_1_1core_1_1is__size__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d54/structbit_1_1core_1_1is__size__constant_3_01size__constant_3_01_size_01_4_01_4.html">is_size_constant&lt; size_constant&lt; Size &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dce/structbit_1_1core_1_1is__span.html">is_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given type a span ?  <a href="../../dc/dce/structbit_1_1core_1_1is__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de8/structbit_1_1core_1_1is__span_3_01span_3_01_t_00_01_n_01_4_01_4.html">is_span&lt; span&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d39/structbit_1_1core_1_1is__unexpected__type.html">is_unexpected_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d41/structbit_1_1core_1_1is__unexpected__type_3_01unexpected__type_3_01_t_01_4_01_4.html">is_unexpected_type&lt; unexpected_type&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d02/structbit_1_1core_1_1is__volatile__member__function__pointer.html">is_volatile_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>Func</code> is a volatile member function pointer.  <a href="../../db/d02/structbit_1_1core_1_1is__volatile__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfb/structbit_1_1core_1_1is__volatile__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01volatile_01_4.html">is_volatile_member_function_pointer&lt; R(C::*)(Args...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0a/structbit_1_1core_1_1is__volatile__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01volatile_01_4.html">is_volatile_member_function_pointer&lt; R(C::*)(Args...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy class used for lazy-loading any type.  <a href="../../d4/d69/classbit_1_1core_1_1lazy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d6a/classbit_1_1core_1_1map__view.html">map_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight, non-owning wrapper around map operations.  <a href="../../d5/d6a/classbit_1_1core_1_1map__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d3a/structbit_1_1core_1_1monostate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a></td></tr>
<tr class="memdesc:da/d3a/structbit_1_1core_1_1monostate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit type intended for use as a well-behaved empty alternative in <code>variant</code>.  <a href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">More...</a><br /></td></tr>
<tr class="separator:da/d3a/structbit_1_1core_1_1monostate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d5e/structbit_1_1core_1_1negation.html">negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction for negating a <a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html" title="This utility metafunction provides compile-time boolean values as an integral constant. ">bool_constant</a>.  <a href="../../de/d5e/structbit_1_1core_1_1negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dec/structbit_1_1core_1_1nonesuch.html">nonesuch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility type for the detected_t idiom.  <a href="../../d8/dec/structbit_1_1core_1_1nonesuch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/dd8/structbit_1_1core_1_1normalize__char"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/dd8/structbit_1_1core_1_1normalize__char">normalize_char</a></td></tr>
<tr class="memdesc:d7/dd8/structbit_1_1core_1_1normalize__char"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes character types T to non-signed/unsigned character types.  <a href="../../d9/d73/namespacebit_1_1core.html#d7/dd8/structbit_1_1core_1_1normalize__char">More...</a><br /></td></tr>
<tr class="separator:d7/dd8/structbit_1_1core_1_1normalize__char"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da3/structbit_1_1core_1_1normalize__char_3_01char_01_4.html">normalize_char&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de6/structbit_1_1core_1_1normalize__char_3_01signed_01char_01_4.html">normalize_char&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d40/structbit_1_1core_1_1normalize__char_3_01unsigned_01char_01_4.html">normalize_char&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d34/structbit_1_1core_1_1nth__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d8/d34/structbit_1_1core_1_1nth__type">nth_type</a></td></tr>
<tr class="memdesc:d8/d34/structbit_1_1core_1_1nth__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait for extracting the <code>Ith</code> type from a variadic pack.  <a href="../../d9/d73/namespacebit_1_1core.html#d8/d34/structbit_1_1core_1_1nth__type">More...</a><br /></td></tr>
<tr class="separator:d8/d34/structbit_1_1core_1_1nth__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d9c/structbit_1_1core_1_1nth__type_3_010_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#db/d9c/structbit_1_1core_1_1nth__type_3_010_01_4">nth_type&lt; 0 &gt;</a></td></tr>
<tr class="separator:db/d9c/structbit_1_1core_1_1nth__type_3_010_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7c/structbit_1_1core_1_1nth__type_3_010_00_01_type0_00_01_types_8_8_8_01_4.html">nth_type&lt; 0, Type0, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dea/structbit_1_1core_1_1nth__type_3_01_i_00_01_type0_00_01_types_8_8_8_01_4.html">nth_type&lt; I, Type0, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type represents null optional value.  <a href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight wrapper around a pointer type.  <a href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An offset pointer based on boost::offset_ptr.  <a href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template optional manages an optional contained value, i.e. a value that may or may not be present.  <a href="../../db/d56/classbit_1_1core_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to propagate the const qualifier.  <a href="../../d6/d12/classbit_1_1core_1_1propagate__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a range from a given Container.  <a href="../../d0/d23/classbit_1_1core_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dcd/structbit_1_1core_1_1remove__cvref.html">remove_cvref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any CV and reference qualifiers.  <a href="../../d6/dcd/structbit_1_1core_1_1remove__cvref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dd3/structbit_1_1core_1_1remove__pointers.html">remove_pointers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all pointers from a given type.  <a href="../../dd/dd3/structbit_1_1core_1_1remove__pointers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dff/structbit_1_1core_1_1remove__pointers_3_01_t_01_5_01_4.html">remove_pointers&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d5c/structbit_1_1core_1_1remove__pointers_3_01_t_01_5const_01_4.html">remove_pointers&lt; T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dcb/structbit_1_1core_1_1remove__pointers_3_01_t_01_5const_01volatile_01_4.html">remove_pointers&lt; T *const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d99/structbit_1_1core_1_1remove__pointers_3_01_t_01_5volatile_01_4.html">remove_pointers&lt; T *volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d35/structbit_1_1core_1_1resolves__overload__index.html">resolves_overload_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to determine the index of the type that would be resolved if presented with Types... simultaneous overloads, and presented with <code>T</code>.  <a href="../../d2/d35/structbit_1_1core_1_1resolves__overload__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/ded/structbit_1_1core_1_1resolves__overload__type.html">resolves_overload_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to determine the type that would be resolved if presented with Types... simultaneous overloads, and presented with <code>T</code>.  <a href="../../df/ded/structbit_1_1core_1_1resolves__overload__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7e/classbit_1_1core_1_1ring__array.html">ring_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular buffer that uses an array for storage.  <a href="../../de/d7e/classbit_1_1core_1_1ring__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an implementation of a non-owning circular buffer.  <a href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d49/classbit_1_1core_1_1ring__deque.html">ring_deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular buffer with a deque API.  <a href="../../d2/d49/classbit_1_1core_1_1ring__deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbc/classbit_1_1core_1_1scope__guard.html">scope_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class leverages RAII to perform cleanup actions at the end of a scope.  <a href="../../d6/dbc/classbit_1_1core_1_1scope__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dac/classbit_1_1core_1_1set__view.html">set_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight, non-owning wrapper around set operations.  <a href="../../d8/dac/classbit_1_1core_1_1set__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d50/structbit_1_1core_1_1sfinae__base"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#db/d50/structbit_1_1core_1_1sfinae__base">sfinae_base</a></td></tr>
<tr class="memdesc:db/d50/structbit_1_1core_1_1sfinae__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sfinae types.  <a href="../../d9/d73/namespacebit_1_1core.html#db/d50/structbit_1_1core_1_1sfinae__base">More...</a><br /></td></tr>
<tr class="separator:db/d50/structbit_1_1core_1_1sfinae__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d94/structbit_1_1core_1_1size__constant.html">size_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility metafunction provides compile-time size values as an integral constant.  <a href="../../d1/d94/structbit_1_1core_1_1size__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html">source_location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source location is a small, immutable type used for representing where retrieving information about where this type is constructed.  <a href="../../d3/d9a/classbit_1_1core_1_1source__location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight non-owning wrapper around contiguous memory.  <a href="../../d1/d27/classbit_1_1core_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thin wrapper around a different iterator type to add uniqueness.  <a href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a 3-state boolean type that introduces 'indeterminate' as the third state.  <a href="../../d0/de7/classbit_1_1core_1_1tribool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/d18/structbit_1_1core_1_1tuple__element"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#df/d18/structbit_1_1core_1_1tuple__element">tuple_element</a></td></tr>
<tr class="separator:df/d18/structbit_1_1core_1_1tuple__element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dba/structbit_1_1core_1_1tuple__element_3_010_00_01compressed__pair_3_01_t_00_01_u_01_4_01_4.html">tuple_element&lt; 0, compressed_pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d18/structbit_1_1core_1_1tuple__element_3_011_00_01compressed__pair_3_01_t_00_01_u_01_4_01_4.html">tuple_element&lt; 1, compressed_pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dad/structbit_1_1core_1_1tuple__element_3_01_idx_00_01compressed__pair_3_01_ts_8_8_8_01_4_01_4.html">tuple_element&lt; Idx, compressed_pair&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d47/structbit_1_1core_1_1tuple__element_3_01_idx_00_01compressed__tuple_3_01_ts_8_8_8_01_4_01_4.html">tuple_element&lt; Idx, compressed_tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d49/structbit_1_1core_1_1tuple__element_3_01_idx_00_01tuple_3_01_ts_8_8_8_01_4_01_4.html">tuple_element&lt; Idx, tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/de5/structbit_1_1core_1_1tuple__size"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d1/de5/structbit_1_1core_1_1tuple__size">tuple_size</a></td></tr>
<tr class="separator:d1/de5/structbit_1_1core_1_1tuple__size"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d85/structbit_1_1core_1_1tuple__size_3_01compressed__pair_3_01_t_00_01_u_01_4_01_4.html">tuple_size&lt; compressed_pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d50/structbit_1_1core_1_1tuple__size_3_01compressed__pair_3_01_ts_8_8_8_01_4_01_4.html">tuple_size&lt; compressed_pair&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc5/structbit_1_1core_1_1tuple__size_3_01compressed__tuple_3_01_ts_8_8_8_01_4_01_4.html">tuple_size&lt; compressed_tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d01/structbit_1_1core_1_1tuple__size_3_01tuple_3_01_ts_8_8_8_01_4_01_4.html">tuple_size&lt; tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d2d/structbit_1_1core_1_1type__identity.html">type_identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This simple type is used to add '::type' to any transformation type-traits.  <a href="../../dd/d2d/structbit_1_1core_1_1type__identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/dc5/structbit_1_1core_1_1type__list"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/dc5/structbit_1_1core_1_1type__list">type_list</a></td></tr>
<tr class="memdesc:d7/dc5/structbit_1_1core_1_1type__list"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility metafunction for encoding a sequence of types into a single unique type.  <a href="../../d9/d73/namespacebit_1_1core.html#d7/dc5/structbit_1_1core_1_1type__list">More...</a><br /></td></tr>
<tr class="separator:d7/dc5/structbit_1_1core_1_1type__list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/d3c/classbit_1_1core_1_1underlying__container__type"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d3c/classbit_1_1core_1_1underlying__container__type">underlying_container_type</a></td></tr>
<tr class="memdesc:d7/d3c/classbit_1_1core_1_1underlying__container__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying container type of any container adapter.  <a href="../../d9/d73/namespacebit_1_1core.html#d7/d3c/classbit_1_1core_1_1underlying__container__type">More...</a><br /></td></tr>
<tr class="separator:d7/d3c/classbit_1_1core_1_1underlying__container__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd6/structbit_1_1core_1_1unexpect__t.html">unexpect_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag type used for tag-dispatch.  <a href="../../d7/dd6/structbit_1_1core_1_1unexpect__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing an unexpected value coming from an expected type.  <a href="../../de/d25/classbit_1_1core_1_1unexpected__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template variant represents a type-safe union.  <a href="../../d0/d2b/classbit_1_1core_1_1variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/d55/structbit_1_1core_1_1variant__alternative"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#d1/d55/structbit_1_1core_1_1variant__alternative">variant_alternative</a></td></tr>
<tr class="separator:d1/d55/structbit_1_1core_1_1variant__alternative"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da8/structbit_1_1core_1_1variant__alternative_3_01_i_00_01const_01_t_01_4.html">variant_alternative&lt; I, const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d30/structbit_1_1core_1_1variant__alternative_3_01_i_00_01const_01volatile_01_t_01_4.html">variant_alternative&lt; I, const volatile T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dad/structbit_1_1core_1_1variant__alternative_3_01_i_00_01variant_3_01_types_8_8_8_01_4_01_4.html">variant_alternative&lt; I, variant&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d00/structbit_1_1core_1_1variant__alternative_3_01_i_00_01volatile_01_t_01_4.html">variant_alternative&lt; I, volatile T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d64/structbit_1_1core_1_1variant__size.html">variant_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the number of alternatives in a possibly cv-qualified variant as a compile-time constant expression.  <a href="../../d1/d64/structbit_1_1core_1_1variant__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d4b/structbit_1_1core_1_1variant__size_3_01const_01_t_01_4.html">variant_size&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8a/structbit_1_1core_1_1variant__size_3_01const_01volatile_01_t_01_4.html">variant_size&lt; const volatile T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/db1/structbit_1_1core_1_1variant__size_3_01variant_3_01_types_8_8_8_01_4_01_4.html">variant_size&lt; variant&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbf/structbit_1_1core_1_1variant__size_3_01volatile_01_t_01_4.html">variant_size&lt; volatile T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d80/classbit_1_1core_1_1zip__iterator.html">zip_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator used for zipping multiple iterator ranges together into a single iterator.  <a href="../../d6/d80/classbit_1_1core_1_1zip__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4a1e28c4cd317a610d53116426a8ee12"><td class="memTemplParams" colspan="2"><a id="a4a1e28c4cd317a610d53116426a8ee12"></a>
template&lt;typename CharT , typename Traits  = std::char_traits&lt;CharT&gt;, std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:a4a1e28c4cd317a610d53116426a8ee12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_zstring</b> = CharT *</td></tr>
<tr class="separator:a4a1e28c4cd317a610d53116426a8ee12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae683fede8422aa0b47cc5428d38bbf70"><td class="memTemplParams" colspan="2"><a id="ae683fede8422aa0b47cc5428d38bbf70"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:ae683fede8422aa0b47cc5428d38bbf70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zstring</b> = basic_zstring&lt; char, std::char_traits&lt; char &gt;, Extent &gt;</td></tr>
<tr class="separator:ae683fede8422aa0b47cc5428d38bbf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2424647a837ba887e3ec960ab787c2a"><td class="memTemplParams" colspan="2"><a id="ac2424647a837ba887e3ec960ab787c2a"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:ac2424647a837ba887e3ec960ab787c2a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wzstring</b> = basic_zstring&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, Extent &gt;</td></tr>
<tr class="separator:ac2424647a837ba887e3ec960ab787c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab461ed76087cefecccd8e25928074374"><td class="memTemplParams" colspan="2"><a id="ab461ed76087cefecccd8e25928074374"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:ab461ed76087cefecccd8e25928074374"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u16zstring</b> = basic_zstring&lt; char16_t, std::char_traits&lt; char16_t &gt;, Extent &gt;</td></tr>
<tr class="separator:ab461ed76087cefecccd8e25928074374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cdadf173f4888fb8e6202b47b4f7a0"><td class="memTemplParams" colspan="2"><a id="af6cdadf173f4888fb8e6202b47b4f7a0"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:af6cdadf173f4888fb8e6202b47b4f7a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u32zstring</b> = basic_zstring&lt; char32_t, std::char_traits&lt; char32_t &gt;, Extent &gt;</td></tr>
<tr class="separator:af6cdadf173f4888fb8e6202b47b4f7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b1eca6f6540c3407ff4df6983b0e6a"><td class="memTemplParams" colspan="2"><a id="a28b1eca6f6540c3407ff4df6983b0e6a"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a28b1eca6f6540c3407ff4df6983b0e6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>string_span</b> = <a class="el" href="../../d7/dea/classbit_1_1core_1_1basic__string__span.html">basic_string_span</a>&lt; char, std::char_traits&lt; char &gt;, Extent &gt;</td></tr>
<tr class="separator:a28b1eca6f6540c3407ff4df6983b0e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfccaac857d5754eefa25a0440df8ee"><td class="memTemplParams" colspan="2"><a id="a7dfccaac857d5754eefa25a0440df8ee"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a7dfccaac857d5754eefa25a0440df8ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wstring_span</b> = <a class="el" href="../../d7/dea/classbit_1_1core_1_1basic__string__span.html">basic_string_span</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a7dfccaac857d5754eefa25a0440df8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13544e8943e261233273dd29b7b7e833"><td class="memTemplParams" colspan="2"><a id="a13544e8943e261233273dd29b7b7e833"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a13544e8943e261233273dd29b7b7e833"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u16string_span</b> = <a class="el" href="../../d7/dea/classbit_1_1core_1_1basic__string__span.html">basic_string_span</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a13544e8943e261233273dd29b7b7e833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3569286a244ada1db105bdf80f678dae"><td class="memTemplParams" colspan="2"><a id="a3569286a244ada1db105bdf80f678dae"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a3569286a244ada1db105bdf80f678dae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u32string_span</b> = <a class="el" href="../../d7/dea/classbit_1_1core_1_1basic__string__span.html">basic_string_span</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a3569286a244ada1db105bdf80f678dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772748eece1506e1a3b88243a9e9f674"><td class="memTemplParams" colspan="2"><a id="a772748eece1506e1a3b88243a9e9f674"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a772748eece1506e1a3b88243a9e9f674"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zstring_span</b> = <a class="el" href="../../da/d37/classbit_1_1core_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; char, std::char_traits&lt; char &gt;, Extent &gt;</td></tr>
<tr class="separator:a772748eece1506e1a3b88243a9e9f674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868ace3f34efb2833f5db193c9fceac7"><td class="memTemplParams" colspan="2"><a id="a868ace3f34efb2833f5db193c9fceac7"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a868ace3f34efb2833f5db193c9fceac7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wzstring_span</b> = <a class="el" href="../../da/d37/classbit_1_1core_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a868ace3f34efb2833f5db193c9fceac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d56a2d7e0c60ec9b00e83e630e2c9f"><td class="memTemplParams" colspan="2"><a id="ae0d56a2d7e0c60ec9b00e83e630e2c9f"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ae0d56a2d7e0c60ec9b00e83e630e2c9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u16zstring_span</b> = <a class="el" href="../../da/d37/classbit_1_1core_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, Extent &gt;</td></tr>
<tr class="separator:ae0d56a2d7e0c60ec9b00e83e630e2c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb3284dc982e109404355cdec4af79d"><td class="memTemplParams" colspan="2"><a id="a9fb3284dc982e109404355cdec4af79d"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a9fb3284dc982e109404355cdec4af79d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u32zstring_span</b> = <a class="el" href="../../da/d37/classbit_1_1core_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a9fb3284dc982e109404355cdec4af79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95aaae9e48d9bc1e9ce1680fe2961614"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95aaae9e48d9bc1e9ce1680fe2961614"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a95aaae9e48d9bc1e9ce1680fe2961614">is_string_span</a> = detail::is_string_span&lt; std::remove_cv_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a95aaae9e48d9bc1e9ce1680fe2961614"><td class="mdescLeft">&#160;</td><td class="mdescRight">type-trait to determine whether the type is a string_span  <a href="#a95aaae9e48d9bc1e9ce1680fe2961614">More...</a><br /></td></tr>
<tr class="separator:a95aaae9e48d9bc1e9ce1680fe2961614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca3133d65111e9bd17f114f28ec8239"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaca3133d65111e9bd17f114f28ec8239"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aaca3133d65111e9bd17f114f28ec8239">is_zstring_span</a> = detail::is_zstring_span&lt; std::remove_cv_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:aaca3133d65111e9bd17f114f28ec8239"><td class="mdescLeft">&#160;</td><td class="mdescRight">type-trait to determine whether the type is a null-terminated string  <a href="#aaca3133d65111e9bd17f114f28ec8239">More...</a><br /></td></tr>
<tr class="separator:aaca3133d65111e9bd17f114f28ec8239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5df4a9a805374b71a2b4d28cfba4d2"><td class="memItemLeft" align="right" valign="top"><a id="a8a5df4a9a805374b71a2b4d28cfba4d2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_view</b> = <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; char &gt;</td></tr>
<tr class="separator:a8a5df4a9a805374b71a2b4d28cfba4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab495d234f64ce5baaf15bbe718ceca91"><td class="memItemLeft" align="right" valign="top"><a id="ab495d234f64ce5baaf15bbe718ceca91"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wstring_view</b> = <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:ab495d234f64ce5baaf15bbe718ceca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cbbb5ee2f5baad183e94dfc5b922f9"><td class="memItemLeft" align="right" valign="top"><a id="a65cbbb5ee2f5baad183e94dfc5b922f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16string_view</b> = <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:a65cbbb5ee2f5baad183e94dfc5b922f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee6310d9fa1d379c1e14f657053e2f2"><td class="memItemLeft" align="right" valign="top"><a id="a7ee6310d9fa1d379c1e14f657053e2f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32string_view</b> = <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:a7ee6310d9fa1d379c1e14f657053e2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c0c7a34d78fae3191cf75e195fbee4"><td class="memItemLeft" align="right" valign="top"><a id="ab5c0c7a34d78fae3191cf75e195fbee4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>zstring_view</b> = <a class="el" href="../../d6/d43/classbit_1_1core_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; char &gt;</td></tr>
<tr class="separator:ab5c0c7a34d78fae3191cf75e195fbee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d755770175b41a249b1cb486647f4ed"><td class="memItemLeft" align="right" valign="top"><a id="a0d755770175b41a249b1cb486647f4ed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wzstring_view</b> = <a class="el" href="../../d6/d43/classbit_1_1core_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a0d755770175b41a249b1cb486647f4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3fab3ef4dc037bff3131f1978ff127"><td class="memItemLeft" align="right" valign="top"><a id="adf3fab3ef4dc037bff3131f1978ff127"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16zstring_view</b> = <a class="el" href="../../d6/d43/classbit_1_1core_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:adf3fab3ef4dc037bff3131f1978ff127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4414569439c147bb98eb49e29498082"><td class="memItemLeft" align="right" valign="top"><a id="af4414569439c147bb98eb49e29498082"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32zstring_view</b> = <a class="el" href="../../d6/d43/classbit_1_1core_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:af4414569439c147bb98eb49e29498082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6855449215aeed920928e48e466ccf"><td class="memTemplParams" colspan="2"><a id="a6f6855449215aeed920928e48e466ccf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f6855449215aeed920928e48e466ccf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a6f6855449215aeed920928e48e466ccf">owner</a> = T</td></tr>
<tr class="memdesc:a6f6855449215aeed920928e48e466ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper type that represents ownership. <br /></td></tr>
<tr class="separator:a6f6855449215aeed920928e48e466ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9c0cace893c87d00d22166c5e1ba62"><td class="memTemplParams" colspan="2"><a id="a7a9c0cace893c87d00d22166c5e1ba62"></a>
template&lt;typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:a7a9c0cace893c87d00d22166c5e1ba62"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move_range</b> = <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; std::move_iterator&lt; Iterator &gt;, std::move_iterator&lt; Sentinel &gt; &gt;</td></tr>
<tr class="separator:a7a9c0cace893c87d00d22166c5e1ba62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caf50551c26ffa97d2cbbf61688199e"><td class="memTemplParams" colspan="2"><a id="a6caf50551c26ffa97d2cbbf61688199e"></a>
template&lt;typename Iterator , typename Sentinel  = Iterator&gt; </td></tr>
<tr class="memitem:a6caf50551c26ffa97d2cbbf61688199e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a6caf50551c26ffa97d2cbbf61688199e">reverse_range</a> = <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; std::reverse_iterator&lt; Iterator &gt;, std::reverse_iterator&lt; Sentinel &gt; &gt;</td></tr>
<tr class="memdesc:a6caf50551c26ffa97d2cbbf61688199e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range that contains only reverse iterators. <br /></td></tr>
<tr class="separator:a6caf50551c26ffa97d2cbbf61688199e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe5efe8b18ac41c02a35d22ec2d30a"><td class="memTemplParams" colspan="2"><a id="a76fe5efe8b18ac41c02a35d22ec2d30a"></a>
template&lt;std::size_t N, typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:a76fe5efe8b18ac41c02a35d22ec2d30a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_element_range</b> = <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; N, Iterator &gt;, <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; N, Sentinel &gt; &gt;</td></tr>
<tr class="separator:a76fe5efe8b18ac41c02a35d22ec2d30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43976861ba959049bb2734def46feaae"><td class="memTemplParams" colspan="2"><a id="a43976861ba959049bb2734def46feaae"></a>
template&lt;typename... Iterators&gt; </td></tr>
<tr class="memitem:a43976861ba959049bb2734def46feaae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zip_range</b> = <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; <a class="el" href="../../d6/d80/classbit_1_1core_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators &gt;..., <a class="el" href="../../d6/d80/classbit_1_1core_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators &gt;... &gt;</td></tr>
<tr class="separator:a43976861ba959049bb2734def46feaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b3ef1423ac0fce701839b2e7079bec"><td class="memItemLeft" align="right" valign="top"><a id="a57b3ef1423ac0fce701839b2e7079bec"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>true_type</b> = <a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html">bool_constant</a>&lt; true &gt;</td></tr>
<tr class="separator:a57b3ef1423ac0fce701839b2e7079bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6075c11560b5323ca4ef4507be5ca6f"><td class="memItemLeft" align="right" valign="top"><a id="ad6075c11560b5323ca4ef4507be5ca6f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>false_type</b> = <a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html">bool_constant</a>&lt; false &gt;</td></tr>
<tr class="separator:ad6075c11560b5323ca4ef4507be5ca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e71a59d67c93b4ac8187a88f9b38fc1"><td class="memTemplParams" colspan="2"><a id="a1e71a59d67c93b4ac8187a88f9b38fc1"></a>
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a1e71a59d67c93b4ac8187a88f9b38fc1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected</b> = typename detail::detector&lt; <a class="el" href="../../d8/dec/structbit_1_1core_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;::value_t</td></tr>
<tr class="separator:a1e71a59d67c93b4ac8187a88f9b38fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab9f65c2f1fa110deb868285f34da9e"><td class="memTemplParams" colspan="2"><a id="a1ab9f65c2f1fa110deb868285f34da9e"></a>
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a1ab9f65c2f1fa110deb868285f34da9e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_t</b> = typename detail::detector&lt; <a class="el" href="../../d8/dec/structbit_1_1core_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;::type</td></tr>
<tr class="separator:a1ab9f65c2f1fa110deb868285f34da9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3a3c5098d2a86da417c3d9b4756ef6"><td class="memTemplParams" colspan="2"><a id="abd3a3c5098d2a86da417c3d9b4756ef6"></a>
template&lt;typename Default , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:abd3a3c5098d2a86da417c3d9b4756ef6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_or</b> = detail::detector&lt; Default, void, Op, Args... &gt;</td></tr>
<tr class="separator:abd3a3c5098d2a86da417c3d9b4756ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba27ebaa0576056213c1a815ab0afd2b"><td class="memTemplParams" colspan="2"><a id="aba27ebaa0576056213c1a815ab0afd2b"></a>
template&lt;typename Default , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:aba27ebaa0576056213c1a815ab0afd2b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_or_t</b> = typename detected_or&lt; Default, Op, Args... &gt;::type</td></tr>
<tr class="separator:aba27ebaa0576056213c1a815ab0afd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9593d50c3b5f24968f9cf9aed8e94e2e"><td class="memTemplParams" colspan="2"><a id="a9593d50c3b5f24968f9cf9aed8e94e2e"></a>
template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a9593d50c3b5f24968f9cf9aed8e94e2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_exact</b> = std::is_same&lt; Expected, detected_t&lt; Op, Args... &gt; &gt;</td></tr>
<tr class="separator:a9593d50c3b5f24968f9cf9aed8e94e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b485648ab96b813237da7ec8246455e"><td class="memTemplParams" colspan="2"><a id="a3b485648ab96b813237da7ec8246455e"></a>
template&lt;typename To , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a3b485648ab96b813237da7ec8246455e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_convertible</b> = std::is_convertible&lt; detected_t&lt; Op, Args... &gt;, To &gt;</td></tr>
<tr class="separator:a3b485648ab96b813237da7ec8246455e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c471cd05e346a7a501dfbba0b31207"><td class="memTemplParams" colspan="2"><a id="a37c471cd05e346a7a501dfbba0b31207"></a>
template&lt;typename T , T V&gt; </td></tr>
<tr class="memitem:a37c471cd05e346a7a501dfbba0b31207"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integral_constant</b> = std::integral_constant&lt; T, V &gt;</td></tr>
<tr class="separator:a37c471cd05e346a7a501dfbba0b31207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6e4ae2b91f0bc7a7729bc54cdc68c1"><td class="memTemplParams" colspan="2"><a id="afd6e4ae2b91f0bc7a7729bc54cdc68c1"></a>
template&lt;typename T , T V&gt; </td></tr>
<tr class="memitem:afd6e4ae2b91f0bc7a7729bc54cdc68c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integral_constant_t</b> = typename integral_constant&lt; T, V &gt;::type</td></tr>
<tr class="separator:afd6e4ae2b91f0bc7a7729bc54cdc68c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac152b6b41bd4c44f7bba28f2b649ae22"><td class="memTemplParams" colspan="2"><a id="ac152b6b41bd4c44f7bba28f2b649ae22"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:ac152b6b41bd4c44f7bba28f2b649ae22"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_t</b> = typename <a class="el" href="../../d8/dd9/structbit_1_1core_1_1enable__if.html">enable_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="separator:ac152b6b41bd4c44f7bba28f2b649ae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a7f0955400668a3a6a5aab2aa4c93e"><td class="memTemplParams" colspan="2"><a id="ad3a7f0955400668a3a6a5aab2aa4c93e"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:ad3a7f0955400668a3a6a5aab2aa4c93e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad3a7f0955400668a3a6a5aab2aa4c93e">disable_if_t</a> = typename <a class="el" href="../../d8/dd9/structbit_1_1core_1_1enable__if.html">enable_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="memdesc:ad3a7f0955400668a3a6a5aab2aa4c93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias to retrieve the <code>::type</code> member of <code>block_if</code>. <br /></td></tr>
<tr class="separator:ad3a7f0955400668a3a6a5aab2aa4c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b67a176c3a604dee4c2d4d4d8612a1"><td class="memTemplParams" colspan="2"><a id="a78b67a176c3a604dee4c2d4d4d8612a1"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:a78b67a176c3a604dee4c2d4d4d8612a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a78b67a176c3a604dee4c2d4d4d8612a1">enable_overload_if_t</a> = typename <a class="el" href="../../dd/d3e/structbit_1_1core_1_1enable__overload__if.html">enable_overload_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="memdesc:a78b67a176c3a604dee4c2d4d4d8612a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias to retrieve the <code>::type</code> member of <code>block_if</code>. <br /></td></tr>
<tr class="separator:a78b67a176c3a604dee4c2d4d4d8612a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33850c0345ef7835ecc4880dac5269dc"><td class="memTemplParams" colspan="2"><a id="a33850c0345ef7835ecc4880dac5269dc"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:a33850c0345ef7835ecc4880dac5269dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a33850c0345ef7835ecc4880dac5269dc">disable_overload_if</a> = <a class="el" href="../../dd/d3e/structbit_1_1core_1_1enable__overload__if.html">enable_overload_if</a>&lt;!B, T &gt;</td></tr>
<tr class="memdesc:a33850c0345ef7835ecc4880dac5269dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of <code>block_if</code>. <br /></td></tr>
<tr class="separator:a33850c0345ef7835ecc4880dac5269dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cd3956f5221a64247d167f225f0752"><td class="memTemplParams" colspan="2"><a id="a21cd3956f5221a64247d167f225f0752"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:a21cd3956f5221a64247d167f225f0752"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a21cd3956f5221a64247d167f225f0752">disable_overload_if_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a33850c0345ef7835ecc4880dac5269dc">disable_overload_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="memdesc:a21cd3956f5221a64247d167f225f0752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias to retrieve the <code>::type</code> member of <code>block_unless</code>. <br /></td></tr>
<tr class="separator:a21cd3956f5221a64247d167f225f0752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009ebf263b365e405468e850d654d2ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a009ebf263b365e405468e850d654d2ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a009ebf263b365e405468e850d654d2ee">type_identity_t</a> = typename <a class="el" href="../../dd/d2d/structbit_1_1core_1_1type__identity.html">type_identity</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a009ebf263b365e405468e850d654d2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace alias used to extract identity&lt;T&gt;::type.  <a href="#a009ebf263b365e405468e850d654d2ee">More...</a><br /></td></tr>
<tr class="separator:a009ebf263b365e405468e850d654d2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34572ccc792c800c6e93ea48afdf8a66"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a34572ccc792c800c6e93ea48afdf8a66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a34572ccc792c800c6e93ea48afdf8a66">void_t</a> = typename detail::voidify&lt; Types... &gt;::type</td></tr>
<tr class="memdesc:a34572ccc792c800c6e93ea48afdf8a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that maps a sequence of any types to the type void.  <a href="#a34572ccc792c800c6e93ea48afdf8a66">More...</a><br /></td></tr>
<tr class="separator:a34572ccc792c800c6e93ea48afdf8a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51f16431c3e7b201420c4b96ca59f58"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab51f16431c3e7b201420c4b96ca59f58"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab51f16431c3e7b201420c4b96ca59f58">is_assignable</a> = std::is_assignable&lt; T, U &gt;</td></tr>
<tr class="memdesc:ab51f16431c3e7b201420c4b96ca59f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is assignable.  <a href="#ab51f16431c3e7b201420c4b96ca59f58">More...</a><br /></td></tr>
<tr class="separator:ab51f16431c3e7b201420c4b96ca59f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4d09b7fe409dc363b65f21fb0b1b06"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e4d09b7fe409dc363b65f21fb0b1b06"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3e4d09b7fe409dc363b65f21fb0b1b06">is_copy_assignable</a> = std::is_copy_assignable&lt; T &gt;</td></tr>
<tr class="memdesc:a3e4d09b7fe409dc363b65f21fb0b1b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is copy-assignable.  <a href="#a3e4d09b7fe409dc363b65f21fb0b1b06">More...</a><br /></td></tr>
<tr class="separator:a3e4d09b7fe409dc363b65f21fb0b1b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1771083dc64b5a241d9e36069a44cb6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1771083dc64b5a241d9e36069a44cb6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1771083dc64b5a241d9e36069a44cb6a">is_copy_constructible</a> = std::is_copy_constructible&lt; T &gt;</td></tr>
<tr class="memdesc:a1771083dc64b5a241d9e36069a44cb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is copy-constructible.  <a href="#a1771083dc64b5a241d9e36069a44cb6a">More...</a><br /></td></tr>
<tr class="separator:a1771083dc64b5a241d9e36069a44cb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7075f46b78f22acb517a4fc86f9ee464"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7075f46b78f22acb517a4fc86f9ee464"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7075f46b78f22acb517a4fc86f9ee464">is_default_constructible</a> = std::is_default_constructible&lt; T &gt;</td></tr>
<tr class="memdesc:a7075f46b78f22acb517a4fc86f9ee464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is default-constructible.  <a href="#a7075f46b78f22acb517a4fc86f9ee464">More...</a><br /></td></tr>
<tr class="separator:a7075f46b78f22acb517a4fc86f9ee464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414aed485401f8a9703416887ba9c2e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a414aed485401f8a9703416887ba9c2e8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a414aed485401f8a9703416887ba9c2e8">is_destructible</a> = std::is_destructible&lt; T &gt;</td></tr>
<tr class="memdesc:a414aed485401f8a9703416887ba9c2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is destructible.  <a href="#a414aed485401f8a9703416887ba9c2e8">More...</a><br /></td></tr>
<tr class="separator:a414aed485401f8a9703416887ba9c2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdca05a02c7109d278090d99672c88a3"><td class="memTemplParams" colspan="2"><a id="afdca05a02c7109d278090d99672c88a3"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:afdca05a02c7109d278090d99672c88a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>are_member_object_pointers</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a>&lt; <a class="el" href="../../d4/d1a/structbit_1_1core_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt; Ts &gt;... &gt;</td></tr>
<tr class="separator:afdca05a02c7109d278090d99672c88a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9e46d169a187adb1a07e0531e8a01a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b9e46d169a187adb1a07e0531e8a01a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3b9e46d169a187adb1a07e0531e8a01a">is_move_assignable</a> = std::is_move_assignable&lt; T &gt;</td></tr>
<tr class="memdesc:a3b9e46d169a187adb1a07e0531e8a01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is move-assignable.  <a href="#a3b9e46d169a187adb1a07e0531e8a01a">More...</a><br /></td></tr>
<tr class="separator:a3b9e46d169a187adb1a07e0531e8a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ffdda9ec7463844a64a48dfeef2483"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65ffdda9ec7463844a64a48dfeef2483"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a65ffdda9ec7463844a64a48dfeef2483">is_move_constructible</a> = std::is_move_constructible&lt; T &gt;</td></tr>
<tr class="memdesc:a65ffdda9ec7463844a64a48dfeef2483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is move-constructible.  <a href="#a65ffdda9ec7463844a64a48dfeef2483">More...</a><br /></td></tr>
<tr class="separator:a65ffdda9ec7463844a64a48dfeef2483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a6053cdf318c66148e586dfef7530a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af9a6053cdf318c66148e586dfef7530a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af9a6053cdf318c66148e586dfef7530a">is_trivially_assignable</a> = std::is_trivially_assignable&lt; T, U &gt;</td></tr>
<tr class="memdesc:af9a6053cdf318c66148e586dfef7530a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is trivially assignable.  <a href="#af9a6053cdf318c66148e586dfef7530a">More...</a><br /></td></tr>
<tr class="separator:af9a6053cdf318c66148e586dfef7530a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4664ddec42d92eb0982bd8d2cbcd5a7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4664ddec42d92eb0982bd8d2cbcd5a7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a4664ddec42d92eb0982bd8d2cbcd5a7e">is_nothrow_copy_assignable</a> = std::is_nothrow_copy_assignable&lt; T &gt;</td></tr>
<tr class="memdesc:a4664ddec42d92eb0982bd8d2cbcd5a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is nothrow copy-assignable.  <a href="#a4664ddec42d92eb0982bd8d2cbcd5a7e">More...</a><br /></td></tr>
<tr class="separator:a4664ddec42d92eb0982bd8d2cbcd5a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3c99e273941fc29f98f96f802f0a7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a3c99e273941fc29f98f96f802f0a7d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0a3c99e273941fc29f98f96f802f0a7d">is_nothrow_copy_constructible</a> = std::is_nothrow_copy_constructible&lt; T &gt;</td></tr>
<tr class="memdesc:a0a3c99e273941fc29f98f96f802f0a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is copy-constructible.  <a href="#a0a3c99e273941fc29f98f96f802f0a7d">More...</a><br /></td></tr>
<tr class="separator:a0a3c99e273941fc29f98f96f802f0a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504a07f5c7a1615c06c5a59162c09a00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a504a07f5c7a1615c06c5a59162c09a00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a504a07f5c7a1615c06c5a59162c09a00">is_nothrow_default_constructible</a> = std::is_nothrow_default_constructible&lt; T &gt;</td></tr>
<tr class="memdesc:a504a07f5c7a1615c06c5a59162c09a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is nothrow default-constructible.  <a href="#a504a07f5c7a1615c06c5a59162c09a00">More...</a><br /></td></tr>
<tr class="separator:a504a07f5c7a1615c06c5a59162c09a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ee3460c056151459089407d1194b64"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1ee3460c056151459089407d1194b64"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae1ee3460c056151459089407d1194b64">is_nothrow_destructible</a> = std::is_nothrow_destructible&lt; T &gt;</td></tr>
<tr class="memdesc:ae1ee3460c056151459089407d1194b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is destructible.  <a href="#ae1ee3460c056151459089407d1194b64">More...</a><br /></td></tr>
<tr class="separator:ae1ee3460c056151459089407d1194b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9518a91a11b6a4140499d395f7dc608a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9518a91a11b6a4140499d395f7dc608a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9518a91a11b6a4140499d395f7dc608a">is_nothrow_move_assignable</a> = std::is_nothrow_move_assignable&lt; T &gt;</td></tr>
<tr class="memdesc:a9518a91a11b6a4140499d395f7dc608a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is nothrow move-assignable.  <a href="#a9518a91a11b6a4140499d395f7dc608a">More...</a><br /></td></tr>
<tr class="separator:a9518a91a11b6a4140499d395f7dc608a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c2235981ef56c0ef0a7b2d56738f44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2c2235981ef56c0ef0a7b2d56738f44"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa2c2235981ef56c0ef0a7b2d56738f44">is_nothrow_move_constructible</a> = std::is_nothrow_move_constructible&lt; T &gt;</td></tr>
<tr class="memdesc:aa2c2235981ef56c0ef0a7b2d56738f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is move-constructible.  <a href="#aa2c2235981ef56c0ef0a7b2d56738f44">More...</a><br /></td></tr>
<tr class="separator:aa2c2235981ef56c0ef0a7b2d56738f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1a797ea83fba610a8acdebdba7dafe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:adc1a797ea83fba610a8acdebdba7dafe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#adc1a797ea83fba610a8acdebdba7dafe">is_nothrow_assignable</a> = std::is_nothrow_assignable&lt; T, U &gt;</td></tr>
<tr class="memdesc:adc1a797ea83fba610a8acdebdba7dafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is nothrow assignable.  <a href="#adc1a797ea83fba610a8acdebdba7dafe">More...</a><br /></td></tr>
<tr class="separator:adc1a797ea83fba610a8acdebdba7dafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0891f6958fb7737380699c4d05c4bf64"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0891f6958fb7737380699c4d05c4bf64"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0891f6958fb7737380699c4d05c4bf64">is_trivially_copy_assignable</a> = std::is_trivially_copy_assignable&lt; T &gt;</td></tr>
<tr class="memdesc:a0891f6958fb7737380699c4d05c4bf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is trivially copy-assignable.  <a href="#a0891f6958fb7737380699c4d05c4bf64">More...</a><br /></td></tr>
<tr class="separator:a0891f6958fb7737380699c4d05c4bf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09839e41c2608b206f4a02d43f28fd8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09839e41c2608b206f4a02d43f28fd8f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a09839e41c2608b206f4a02d43f28fd8f">is_trivially_copy_constructible</a> = std::is_trivially_copy_constructible&lt; T &gt;</td></tr>
<tr class="memdesc:a09839e41c2608b206f4a02d43f28fd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is copy-constructible.  <a href="#a09839e41c2608b206f4a02d43f28fd8f">More...</a><br /></td></tr>
<tr class="separator:a09839e41c2608b206f4a02d43f28fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aecfc9d5ab4fa42b6289b479b37739b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7aecfc9d5ab4fa42b6289b479b37739b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7aecfc9d5ab4fa42b6289b479b37739b">is_trivially_default_constructible</a> = std::is_trivially_default_constructible&lt; T &gt;</td></tr>
<tr class="memdesc:a7aecfc9d5ab4fa42b6289b479b37739b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is trivially default-constructible.  <a href="#a7aecfc9d5ab4fa42b6289b479b37739b">More...</a><br /></td></tr>
<tr class="separator:a7aecfc9d5ab4fa42b6289b479b37739b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc833e0cdfa1b9c18c112b5164239c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadc833e0cdfa1b9c18c112b5164239c7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aadc833e0cdfa1b9c18c112b5164239c7">is_trivially_destructible</a> = std::is_trivially_destructible&lt; T &gt;</td></tr>
<tr class="memdesc:aadc833e0cdfa1b9c18c112b5164239c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is destructible.  <a href="#aadc833e0cdfa1b9c18c112b5164239c7">More...</a><br /></td></tr>
<tr class="separator:aadc833e0cdfa1b9c18c112b5164239c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d6085a41d33b8ab2f232ad21392982"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35d6085a41d33b8ab2f232ad21392982"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a35d6085a41d33b8ab2f232ad21392982">is_trivially_move_assignable</a> = std::is_trivially_move_assignable&lt; T &gt;</td></tr>
<tr class="memdesc:a35d6085a41d33b8ab2f232ad21392982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is trivially move-assignable.  <a href="#a35d6085a41d33b8ab2f232ad21392982">More...</a><br /></td></tr>
<tr class="separator:a35d6085a41d33b8ab2f232ad21392982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411d152531059e6b08c5dc21be658c43"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a411d152531059e6b08c5dc21be658c43"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a411d152531059e6b08c5dc21be658c43">is_trivially_move_constructible</a> = std::is_trivially_move_constructible&lt; T &gt;</td></tr>
<tr class="memdesc:a411d152531059e6b08c5dc21be658c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for determining if a type is move-constructible.  <a href="#a411d152531059e6b08c5dc21be658c43">More...</a><br /></td></tr>
<tr class="separator:a411d152531059e6b08c5dc21be658c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52444afa8c653a002d9cc3a84d916df"><td class="memTemplParams" colspan="2"><a id="ac52444afa8c653a002d9cc3a84d916df"></a>
template&lt;std::size_t I, typename Fn &gt; </td></tr>
<tr class="memitem:ac52444afa8c653a002d9cc3a84d916df"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac52444afa8c653a002d9cc3a84d916df">function_argument_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#dc/d21/structbit_1_1core_1_1function__argument">function_argument</a>&lt; I, Fn &gt;::type</td></tr>
<tr class="memdesc:ac52444afa8c653a002d9cc3a84d916df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract function_argument::type. <br /></td></tr>
<tr class="separator:ac52444afa8c653a002d9cc3a84d916df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7924cb4fc7b33d936c69ee41387e639"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af7924cb4fc7b33d936c69ee41387e639"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af7924cb4fc7b33d936c69ee41387e639">is_same_decay</a> = std::is_same&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; U &gt; &gt;</td></tr>
<tr class="memdesc:af7924cb4fc7b33d936c69ee41387e639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether a type is the same with a different decay type.  <a href="#af7924cb4fc7b33d936c69ee41387e639">More...</a><br /></td></tr>
<tr class="separator:af7924cb4fc7b33d936c69ee41387e639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363386a3fe421689b6252fd4536b0d3f"><td class="memTemplParams" colspan="2"><a id="a363386a3fe421689b6252fd4536b0d3f"></a>
template&lt;std::size_t I, typename... Types&gt; </td></tr>
<tr class="memitem:a363386a3fe421689b6252fd4536b0d3f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a363386a3fe421689b6252fd4536b0d3f">nth_type_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d8/d34/structbit_1_1core_1_1nth__type">nth_type</a>&lt; I, Types... &gt;::type</td></tr>
<tr class="memdesc:a363386a3fe421689b6252fd4536b0d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract nth_type::type. <br /></td></tr>
<tr class="separator:a363386a3fe421689b6252fd4536b0d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cb0729bdcb141e7590869875942b1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1cb0729bdcb141e7590869875942b1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac1cb0729bdcb141e7590869875942b1e">pointer_rank</a> = detail::pointer_rank&lt; T, 0 &gt;</td></tr>
<tr class="memdesc:ac1cb0729bdcb141e7590869875942b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the level of indirection of a given type T.  <a href="#ac1cb0729bdcb141e7590869875942b1e">More...</a><br /></td></tr>
<tr class="separator:ac1cb0729bdcb141e7590869875942b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43996d16b67dd09a689734f384cd7a5e"><td class="memTemplParams" colspan="2"><a id="a43996d16b67dd09a689734f384cd7a5e"></a>
template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a43996d16b67dd09a689734f384cd7a5e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a43996d16b67dd09a689734f384cd7a5e">resolved_overload_type_t</a> = typename <a class="el" href="../../df/ded/structbit_1_1core_1_1resolves__overload__type.html">resolves_overload_type</a>&lt; T, Types... &gt;::type</td></tr>
<tr class="memdesc:a43996d16b67dd09a689734f384cd7a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract resolves_overload_type::type. <br /></td></tr>
<tr class="separator:a43996d16b67dd09a689734f384cd7a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772da658421119c1880d81776eb880e9"><td class="memTemplParams" colspan="2"><a id="a772da658421119c1880d81776eb880e9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a772da658421119c1880d81776eb880e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a772da658421119c1880d81776eb880e9">base_type_t</a> = typename <a class="el" href="../../dc/d7b/structbit_1_1core_1_1base__type.html">base_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a772da658421119c1880d81776eb880e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of <a class="el" href="../../dc/d7b/structbit_1_1core_1_1base__type.html" title="Obtains the base type of T without modifiers. ">base_type</a>. <br /></td></tr>
<tr class="separator:a772da658421119c1880d81776eb880e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9926304af6391fd8fa279d7ae3121e"><td class="memTemplParams" colspan="2"><a id="a2a9926304af6391fd8fa279d7ae3121e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a9926304af6391fd8fa279d7ae3121e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2a9926304af6391fd8fa279d7ae3121e">function_signature_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d1/d73/structbit_1_1core_1_1function__signature">function_signature</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a2a9926304af6391fd8fa279d7ae3121e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract function_signature::type. <br /></td></tr>
<tr class="separator:a2a9926304af6391fd8fa279d7ae3121e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcecdee4575842906c24982a4bb2f3e"><td class="memTemplParams" colspan="2">template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:addcecdee4575842906c24982a4bb2f3e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#addcecdee4575842906c24982a4bb2f3e">match_cv_qualifiers</a> = detail::cv_selector&lt; Unqualified, std::is_const&lt; Qualified &gt;::value, std::is_volatile&lt; Qualified &gt;::value &gt;</td></tr>
<tr class="memdesc:addcecdee4575842906c24982a4bb2f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to match the cv qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>.  <a href="#addcecdee4575842906c24982a4bb2f3e">More...</a><br /></td></tr>
<tr class="separator:addcecdee4575842906c24982a4bb2f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8889a5c655f53596e93976628cf8c70b"><td class="memTemplParams" colspan="2"><a id="a8889a5c655f53596e93976628cf8c70b"></a>
template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:a8889a5c655f53596e93976628cf8c70b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a8889a5c655f53596e93976628cf8c70b">match_cv_qualifiers_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#addcecdee4575842906c24982a4bb2f3e">match_cv_qualifiers</a>&lt; Qualified, Unqualified &gt;::type</td></tr>
<tr class="memdesc:a8889a5c655f53596e93976628cf8c70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of match_cv_qualifiers. <br /></td></tr>
<tr class="separator:a8889a5c655f53596e93976628cf8c70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2264263085a410d741140157b6c6f773"><td class="memTemplParams" colspan="2">template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:a2264263085a410d741140157b6c6f773"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2264263085a410d741140157b6c6f773">match_ref_qualifiers</a> = detail::ref_selector&lt; Unqualified, std::is_lvalue_reference&lt; Qualified &gt;::value, std::is_rvalue_reference&lt; Qualified &gt;::value &gt;</td></tr>
<tr class="memdesc:a2264263085a410d741140157b6c6f773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to match the ref qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>.  <a href="#a2264263085a410d741140157b6c6f773">More...</a><br /></td></tr>
<tr class="separator:a2264263085a410d741140157b6c6f773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1022cf0d48431761b8bc81a51a2d8c"><td class="memTemplParams" colspan="2"><a id="afa1022cf0d48431761b8bc81a51a2d8c"></a>
template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:afa1022cf0d48431761b8bc81a51a2d8c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#afa1022cf0d48431761b8bc81a51a2d8c">match_ref_qualifiers_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2264263085a410d741140157b6c6f773">match_ref_qualifiers</a>&lt; Qualified, Unqualified &gt;::type</td></tr>
<tr class="memdesc:afa1022cf0d48431761b8bc81a51a2d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of match_ref_qualifiers. <br /></td></tr>
<tr class="separator:afa1022cf0d48431761b8bc81a51a2d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f29bd16760413ccb652e9568402ddc"><td class="memTemplParams" colspan="2">template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:ad3f29bd16760413ccb652e9568402ddc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad3f29bd16760413ccb652e9568402ddc">match_sign_qualifiers</a> = detail::sign_selector&lt; Unqualified, std::is_signed&lt; Qualified &gt;::value, std::is_unsigned&lt; Qualified &gt;::value &gt;</td></tr>
<tr class="memdesc:ad3f29bd16760413ccb652e9568402ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to match the sign qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>.  <a href="#ad3f29bd16760413ccb652e9568402ddc">More...</a><br /></td></tr>
<tr class="separator:ad3f29bd16760413ccb652e9568402ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0cfda69e41c0b18b59799ce402c45b"><td class="memTemplParams" colspan="2"><a id="a2b0cfda69e41c0b18b59799ce402c45b"></a>
template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:a2b0cfda69e41c0b18b59799ce402c45b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2b0cfda69e41c0b18b59799ce402c45b">match_sign_qualifiers_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad3f29bd16760413ccb652e9568402ddc">match_sign_qualifiers</a>&lt; Qualified, Unqualified &gt;::type</td></tr>
<tr class="memdesc:a2b0cfda69e41c0b18b59799ce402c45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of match_sign_qualifiers. <br /></td></tr>
<tr class="separator:a2b0cfda69e41c0b18b59799ce402c45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc4896179a4f4c18bc403e4cf9c9c5d"><td class="memTemplParams" colspan="2"><a id="a7bc4896179a4f4c18bc403e4cf9c9c5d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7bc4896179a4f4c18bc403e4cf9c9c5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7bc4896179a4f4c18bc403e4cf9c9c5d">normalize_char_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/dd8/structbit_1_1core_1_1normalize__char">normalize_char</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a7bc4896179a4f4c18bc403e4cf9c9c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/dd8/structbit_1_1core_1_1normalize__char" title="Normalizes character types T to non-signed/unsigned character types. ">normalize_char</a>. <br /></td></tr>
<tr class="separator:a7bc4896179a4f4c18bc403e4cf9c9c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001c90db5564d668d6b23174adb6b548"><td class="memTemplParams" colspan="2"><a id="a001c90db5564d668d6b23174adb6b548"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a001c90db5564d668d6b23174adb6b548"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remove_cvref_t</b> = typename <a class="el" href="../../d6/dcd/structbit_1_1core_1_1remove__cvref.html">remove_cvref</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a001c90db5564d668d6b23174adb6b548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4897f797926acc36365771129da3c0c"><td class="memTemplParams" colspan="2"><a id="ae4897f797926acc36365771129da3c0c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4897f797926acc36365771129da3c0c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae4897f797926acc36365771129da3c0c">remove_pointers_t</a> = typename <a class="el" href="../../dd/dd3/structbit_1_1core_1_1remove__pointers.html">remove_pointers</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ae4897f797926acc36365771129da3c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template to retrieve the <code>::type</code> of <a class="el" href="../../dd/dd3/structbit_1_1core_1_1remove__pointers.html" title="Removes all pointers from a given type. ">remove_pointers</a>. <br /></td></tr>
<tr class="separator:ae4897f797926acc36365771129da3c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c2ede351bacf3e10a0d75360aa3d1d"><td class="memTemplParams" colspan="2"><a id="ad5c2ede351bacf3e10a0d75360aa3d1d"></a>
template&lt;std::size_t Len, std::size_t Align = max_align&gt; </td></tr>
<tr class="memitem:ad5c2ede351bacf3e10a0d75360aa3d1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad5c2ede351bacf3e10a0d75360aa3d1d">aligned_storage_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/dd3/structbit_1_1core_1_1aligned__storage">aligned_storage</a>&lt; Len, Align &gt;::type</td></tr>
<tr class="memdesc:ad5c2ede351bacf3e10a0d75360aa3d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-alias for extracting <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d4/d08/unionbit_1_1core_1_1aligned__storage_1_1type">aligned_storage::type</a>. <br /></td></tr>
<tr class="separator:ad5c2ede351bacf3e10a0d75360aa3d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b6e977f622007cfef6fb89fe6f1e75"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ab5b6e977f622007cfef6fb89fe6f1e75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab5b6e977f622007cfef6fb89fe6f1e75">aligned_storage_for</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad5c2ede351bacf3e10a0d75360aa3d1d">aligned_storage_t</a>&lt; detail::aligned_storage_max&lt; sizeof(Types)... &gt;::value, detail::aligned_storage_max&lt; alignof(Types)... &gt;::value &gt;</td></tr>
<tr class="memdesc:ab5b6e977f622007cfef6fb89fe6f1e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-alias for creating <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/dd3/structbit_1_1core_1_1aligned__storage" title="Provides the nested type type, which is a PODType suitable for use as uninitialized storage for any o...">aligned_storage</a> large enough and suitably aligned for all specified Types...  <a href="#ab5b6e977f622007cfef6fb89fe6f1e75">More...</a><br /></td></tr>
<tr class="separator:ab5b6e977f622007cfef6fb89fe6f1e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af840a751e699cded9aab77b10c5a2bca"><td class="memTemplParams" colspan="2"><a id="af840a751e699cded9aab77b10c5a2bca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af840a751e699cded9aab77b10c5a2bca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af840a751e699cded9aab77b10c5a2bca">underlying_container_type_t</a> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d3c/classbit_1_1core_1_1underlying__container__type">underlying_container_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:af840a751e699cded9aab77b10c5a2bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for extracting <code>underlying_container_type&lt;T&gt;::type</code>. <br /></td></tr>
<tr class="separator:af840a751e699cded9aab77b10c5a2bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfd85d93a513bc80a0af16dd247e8c6"><td class="memTemplParams" colspan="2"><a id="a2dfd85d93a513bc80a0af16dd247e8c6"></a>
template&lt;typename F , typename... Types&gt; </td></tr>
<tr class="memitem:a2dfd85d93a513bc80a0af16dd247e8c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_result_t</b> = typename <a class="el" href="../../d8/d73/structbit_1_1core_1_1invoke__result.html">invoke_result</a>&lt; F, Types... &gt;::type</td></tr>
<tr class="separator:a2dfd85d93a513bc80a0af16dd247e8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7a0ee5776e985bbaa3871d7947550a"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename... Args&gt; </td></tr>
<tr class="memitem:a2c7a0ee5776e985bbaa3871d7947550a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2c7a0ee5776e985bbaa3871d7947550a">is_invocable</a> = detail::is_invocable&lt; Fn, Args... &gt;</td></tr>
<tr class="memdesc:a2c7a0ee5776e985bbaa3871d7947550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether <code>Fn</code> is invokable with <code>Args</code>...  <a href="#a2c7a0ee5776e985bbaa3871d7947550a">More...</a><br /></td></tr>
<tr class="separator:a2c7a0ee5776e985bbaa3871d7947550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6dcf0031b078fd8c7c65479ffe687f"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename... Args&gt; </td></tr>
<tr class="memitem:afc6dcf0031b078fd8c7c65479ffe687f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#afc6dcf0031b078fd8c7c65479ffe687f">is_nothrow_invocable</a> = detail::is_nothrow_invocable&lt; Fn, Args... &gt;</td></tr>
<tr class="memdesc:afc6dcf0031b078fd8c7c65479ffe687f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether <code>Fn</code> is nothrow invokable with <code>Args</code>...  <a href="#afc6dcf0031b078fd8c7c65479ffe687f">More...</a><br /></td></tr>
<tr class="separator:afc6dcf0031b078fd8c7c65479ffe687f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bae740c09e530ae1f079d37793d55b9"><td class="memItemLeft" align="right" valign="top"><a id="a7bae740c09e530ae1f079d37793d55b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7bae740c09e530ae1f079d37793d55b9">indeterminate_t</a> = bool(*)(const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;, detail::tribool_t)</td></tr>
<tr class="memdesc:a7bae740c09e530ae1f079d37793d55b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to mark an indeterminate tribool. <br /></td></tr>
<tr class="separator:a7bae740c09e530ae1f079d37793d55b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c61717532131fe9a93a32a563a1306c"><td class="memTemplParams" colspan="2"><a id="a7c61717532131fe9a93a32a563a1306c"></a>
template&lt;size_t I, typename Tuple &gt; </td></tr>
<tr class="memitem:a7c61717532131fe9a93a32a563a1306c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_element_t</b> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#df/d18/structbit_1_1core_1_1tuple__element">tuple_element</a>&lt; I, Tuple &gt;::type</td></tr>
<tr class="separator:a7c61717532131fe9a93a32a563a1306c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa303c6021e907909913340ce742a8874"><td class="memItemLeft" align="right" valign="top"><a id="aa303c6021e907909913340ce742a8874"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa303c6021e907909913340ce742a8874">word</a> = int</td></tr>
<tr class="memdesc:aa303c6021e907909913340ce742a8874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed instruction-sized integer (Word) <br /></td></tr>
<tr class="separator:aa303c6021e907909913340ce742a8874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890c35c8afa09d62b7d480f753cf63c0"><td class="memItemLeft" align="right" valign="top"><a id="a890c35c8afa09d62b7d480f753cf63c0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a890c35c8afa09d62b7d480f753cf63c0">uword</a> = unsigned int</td></tr>
<tr class="memdesc:a890c35c8afa09d62b7d480f753cf63c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned instruction-sized integer (Word) <br /></td></tr>
<tr class="separator:a890c35c8afa09d62b7d480f753cf63c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771a1f9466676adfff67ce641eecaa72"><td class="memItemLeft" align="right" valign="top"><a id="a771a1f9466676adfff67ce641eecaa72"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a771a1f9466676adfff67ce641eecaa72">uchar</a> = unsigned char</td></tr>
<tr class="memdesc:a771a1f9466676adfff67ce641eecaa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned char type. <br /></td></tr>
<tr class="separator:a771a1f9466676adfff67ce641eecaa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d908f7653730fe531080ac07acbaf0"><td class="memItemLeft" align="right" valign="top"><a id="a76d908f7653730fe531080ac07acbaf0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a76d908f7653730fe531080ac07acbaf0">ushort</a> = unsigned short</td></tr>
<tr class="memdesc:a76d908f7653730fe531080ac07acbaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned short type. <br /></td></tr>
<tr class="separator:a76d908f7653730fe531080ac07acbaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465b39a82c46c1d38f6b7aca4c78d52c"><td class="memItemLeft" align="right" valign="top"><a id="a465b39a82c46c1d38f6b7aca4c78d52c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a465b39a82c46c1d38f6b7aca4c78d52c">uint</a> = unsigned int</td></tr>
<tr class="memdesc:a465b39a82c46c1d38f6b7aca4c78d52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned int type. <br /></td></tr>
<tr class="separator:a465b39a82c46c1d38f6b7aca4c78d52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3ee62f7a5182ae7a9a9ceff5643c8e"><td class="memItemLeft" align="right" valign="top"><a id="a6b3ee62f7a5182ae7a9a9ceff5643c8e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a6b3ee62f7a5182ae7a9a9ceff5643c8e">ulong</a> = unsigned long</td></tr>
<tr class="memdesc:a6b3ee62f7a5182ae7a9a9ceff5643c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned long type. <br /></td></tr>
<tr class="separator:a6b3ee62f7a5182ae7a9a9ceff5643c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec6f30cf50adc21023226726b527782"><td class="memItemLeft" align="right" valign="top"><a id="afec6f30cf50adc21023226726b527782"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ulonglong</b> = unsigned long long</td></tr>
<tr class="separator:afec6f30cf50adc21023226726b527782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f00998a640da450aa5f238835e7be8a"><td class="memItemLeft" align="right" valign="top"><a id="a9f00998a640da450aa5f238835e7be8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9f00998a640da450aa5f238835e7be8a">size_t</a> = std::size_t</td></tr>
<tr class="memdesc:a9f00998a640da450aa5f238835e7be8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing size of objects. <br /></td></tr>
<tr class="separator:a9f00998a640da450aa5f238835e7be8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39a4eb2ee23d9e7cd590332124da666"><td class="memItemLeft" align="right" valign="top"><a id="ab39a4eb2ee23d9e7cd590332124da666"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab39a4eb2ee23d9e7cd590332124da666">align_t</a> = std::size_t</td></tr>
<tr class="memdesc:ab39a4eb2ee23d9e7cd590332124da666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing alignment of an object. <br /></td></tr>
<tr class="separator:ab39a4eb2ee23d9e7cd590332124da666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3125111a7659780f481e76fe72f1015d"><td class="memItemLeft" align="right" valign="top"><a id="a3125111a7659780f481e76fe72f1015d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3125111a7659780f481e76fe72f1015d">index_t</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a3125111a7659780f481e76fe72f1015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing index of objects. <br /></td></tr>
<tr class="separator:a3125111a7659780f481e76fe72f1015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d64fc4335f69765bc3cafbd9fc1e31"><td class="memTemplParams" colspan="2"><a id="aa9d64fc4335f69765bc3cafbd9fc1e31"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aa9d64fc4335f69765bc3cafbd9fc1e31"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa9d64fc4335f69765bc3cafbd9fc1e31">array_ref_t</a> = T(&amp;)[N]</td></tr>
<tr class="memdesc:aa9d64fc4335f69765bc3cafbd9fc1e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for lvalue-references to an array of N entries. <br /></td></tr>
<tr class="separator:aa9d64fc4335f69765bc3cafbd9fc1e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0058c751fdcaa650d007ff15d9a7a176"><td class="memTemplParams" colspan="2"><a id="a0058c751fdcaa650d007ff15d9a7a176"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0058c751fdcaa650d007ff15d9a7a176"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0058c751fdcaa650d007ff15d9a7a176">array_rref_t</a> = T(&amp;&amp;)[N]</td></tr>
<tr class="memdesc:a0058c751fdcaa650d007ff15d9a7a176"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for rvalue-references to an array of N entries. <br /></td></tr>
<tr class="separator:a0058c751fdcaa650d007ff15d9a7a176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc991625a0b8cddbdaaf8f1aca5ac889"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:acc991625a0b8cddbdaaf8f1aca5ac889"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#acc991625a0b8cddbdaaf8f1aca5ac889">member_pointer</a> = R T::*</td></tr>
<tr class="memdesc:acc991625a0b8cddbdaaf8f1aca5ac889"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for member pointers to make it more readable.  <a href="#acc991625a0b8cddbdaaf8f1aca5ac889">More...</a><br /></td></tr>
<tr class="separator:acc991625a0b8cddbdaaf8f1aca5ac889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011912bcc8a49005c1b9716e461cd069"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:a011912bcc8a49005c1b9716e461cd069"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a011912bcc8a49005c1b9716e461cd069">member_function_pointer</a> = typename detail::member_function_t&lt; T, Fn &gt;::type</td></tr>
<tr class="memdesc:a011912bcc8a49005c1b9716e461cd069"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for member function pointers to make it more readable.  <a href="#a011912bcc8a49005c1b9716e461cd069">More...</a><br /></td></tr>
<tr class="separator:a011912bcc8a49005c1b9716e461cd069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d594ee9a1db433b8726fd85f5dfca1f"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a1d594ee9a1db433b8726fd85f5dfca1f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1d594ee9a1db433b8726fd85f5dfca1f">function_pointer</a> = typename detail::function_t&lt; Fn &gt;::type</td></tr>
<tr class="memdesc:a1d594ee9a1db433b8726fd85f5dfca1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for function pointers to make it more readable.  <a href="#a1d594ee9a1db433b8726fd85f5dfca1f">More...</a><br /></td></tr>
<tr class="separator:a1d594ee9a1db433b8726fd85f5dfca1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127f6f14bce800487fb12217f507d06e"><td class="memTemplParams" colspan="2"><a id="a127f6f14bce800487fb12217f507d06e"></a>
template&lt;std::size_t I, typename T &gt; </td></tr>
<tr class="memitem:a127f6f14bce800487fb12217f507d06e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>variant_alternative_t</b> = typename <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d1/d55/structbit_1_1core_1_1variant__alternative">variant_alternative</a>&lt; I, T &gt;::type</td></tr>
<tr class="separator:a127f6f14bce800487fb12217f507d06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a41a462b88353d20ab5cbb602fab0fb44"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> : unsigned char </td></tr>
<tr class="memdesc:a41a462b88353d20ab5cbb602fab0fb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned byte type.  <a href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">More...</a><br /></td></tr>
<tr class="separator:a41a462b88353d20ab5cbb602fab0fb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20982aad790d41336dc1dc7a319a4829"><td class="memItemLeft" align="right" valign="top"><a id="a20982aad790d41336dc1dc7a319a4829"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> : std::size_t </td></tr>
<tr class="memdesc:a20982aad790d41336dc1dc7a319a4829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that represents a hash value. <br /></td></tr>
<tr class="separator:a20982aad790d41336dc1dc7a319a4829"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2bd42c34136c4aa85e715d5e907256ef"><td class="memTemplParams" colspan="2">template&lt;typename T  = detail::array_autodeduce, typename... Args&gt; </td></tr>
<tr class="memitem:a2bd42c34136c4aa85e715d5e907256ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2bd42c34136c4aa85e715d5e907256ef">make_array</a> (Args &amp;&amp;... args) noexcept -&gt; detail::array_return_type_t&lt; T, Args... &gt;</td></tr>
<tr class="memdesc:a2bd42c34136c4aa85e715d5e907256ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make utility for creating a std::array.  <a href="#a2bd42c34136c4aa85e715d5e907256ef">More...</a><br /></td></tr>
<tr class="separator:a2bd42c34136c4aa85e715d5e907256ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915a6e7e98b28551c61ad8ae2c05d00c"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a915a6e7e98b28551c61ad8ae2c05d00c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a915a6e7e98b28551c61ad8ae2c05d00c">to_array</a> (const T(&amp;array)[N]) noexcept(std::is_nothrow_copy_constructible&lt; T &gt;::value)</td></tr>
<tr class="memdesc:a915a6e7e98b28551c61ad8ae2c05d00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to convert raw arrays to std::array.  <a href="#a915a6e7e98b28551c61ad8ae2c05d00c">More...</a><br /></td></tr>
<tr class="separator:a915a6e7e98b28551c61ad8ae2c05d00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7561593cbc1e74c86432beb2132d5c12"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a7561593cbc1e74c86432beb2132d5c12"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7561593cbc1e74c86432beb2132d5c12">to_array</a> (T(&amp;&amp;array)[N]) noexcept(std::is_nothrow_move_constructible&lt; T &gt;::value)</td></tr>
<tr class="memdesc:a7561593cbc1e74c86432beb2132d5c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to convert raw arrays to std::array.  <a href="#a7561593cbc1e74c86432beb2132d5c12">More...</a><br /></td></tr>
<tr class="separator:a7561593cbc1e74c86432beb2132d5c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4ceae091a55bc103c8c7472607ae3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d4ceae091a55bc103c8c7472607ae3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0d4ceae091a55bc103c8c7472607ae3a">swap</a> (<a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0d4ceae091a55bc103c8c7472607ae3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>lhs</code> with <code>rhs</code>.  <a href="#a0d4ceae091a55bc103c8c7472607ae3a">More...</a><br /></td></tr>
<tr class="separator:a0d4ceae091a55bc103c8c7472607ae3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d690dc876b4908b42c8d33f73fe6a9"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:a47d690dc876b4908b42c8d33f73fe6a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a47d690dc876b4908b42c8d33f73fe6a9">get</a> (const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a47d690dc876b4908b42c8d33f73fe6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code>N'th</code> entry from the specifier <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html" title="An immutable wrapper around non-owned contiguous data. ">array_view</a>.  <a href="#a47d690dc876b4908b42c8d33f73fe6a9">More...</a><br /></td></tr>
<tr class="separator:a47d690dc876b4908b42c8d33f73fe6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0958ea6d4ce412b883ff62d274dc093"><td class="memTemplParams" colspan="2"><a id="aa0958ea6d4ce412b883ff62d274dc093"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0958ea6d4ce412b883ff62d274dc093"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa0958ea6d4ce412b883ff62d274dc093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42987dd2251f56cb9212b33702cbeeb5"><td class="memTemplParams" colspan="2"><a id="a42987dd2251f56cb9212b33702cbeeb5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42987dd2251f56cb9212b33702cbeeb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a42987dd2251f56cb9212b33702cbeeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85fb6558a556bca5481464d92db41b0"><td class="memTemplParams" colspan="2"><a id="ac85fb6558a556bca5481464d92db41b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac85fb6558a556bca5481464d92db41b0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac85fb6558a556bca5481464d92db41b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c36e3675336c46975f30c5a01c04134"><td class="memTemplParams" colspan="2"><a id="a4c36e3675336c46975f30c5a01c04134"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c36e3675336c46975f30c5a01c04134"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4c36e3675336c46975f30c5a01c04134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88452effbc77f483dfe2d94dccea7349"><td class="memTemplParams" colspan="2"><a id="a88452effbc77f483dfe2d94dccea7349"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88452effbc77f483dfe2d94dccea7349"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a88452effbc77f483dfe2d94dccea7349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace651dfdc87a8b1de54cf4f05d041893"><td class="memTemplParams" colspan="2"><a id="ace651dfdc87a8b1de54cf4f05d041893"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace651dfdc87a8b1de54cf4f05d041893"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ace651dfdc87a8b1de54cf4f05d041893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae963831f24546292f553fb9e5d06a08d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae963831f24546292f553fb9e5d06a08d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae963831f24546292f553fb9e5d06a08d">swap</a> (<a class="el" href="../../de/d7e/classbit_1_1core_1_1ring__array.html">ring_array</a>&lt; T, N &gt; &amp;lhs, <a class="el" href="../../de/d7e/classbit_1_1core_1_1ring__array.html">ring_array</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae963831f24546292f553fb9e5d06a08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two circular arrays.  <a href="#ae963831f24546292f553fb9e5d06a08d">More...</a><br /></td></tr>
<tr class="separator:ae963831f24546292f553fb9e5d06a08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ffdb32eaa0e2887e1f91cf9528c656"><td class="memTemplParams" colspan="2"><a id="ab4ffdb32eaa0e2887e1f91cf9528c656"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab4ffdb32eaa0e2887e1f91cf9528c656"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../de/d7e/classbit_1_1core_1_1ring__array.html">ring_array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="../../de/d7e/classbit_1_1core_1_1ring__array.html">ring_array</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab4ffdb32eaa0e2887e1f91cf9528c656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb466724e99c4db7b9d876d634b8672"><td class="memTemplParams" colspan="2"><a id="a9fb466724e99c4db7b9d876d634b8672"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9fb466724e99c4db7b9d876d634b8672"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../de/d7e/classbit_1_1core_1_1ring__array.html">ring_array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="../../de/d7e/classbit_1_1core_1_1ring__array.html">ring_array</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9fb466724e99c4db7b9d876d634b8672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3cb0afb7c5c02035d7fbba43e375be"><td class="memTemplParams" colspan="2"><a id="a8a3cb0afb7c5c02035d7fbba43e375be"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a3cb0afb7c5c02035d7fbba43e375be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8a3cb0afb7c5c02035d7fbba43e375be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a32dcb2e1b5a9d0c15b6af1025d7f07"><td class="memTemplParams" colspan="2"><a id="a7a32dcb2e1b5a9d0c15b6af1025d7f07"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a32dcb2e1b5a9d0c15b6af1025d7f07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7a32dcb2e1b5a9d0c15b6af1025d7f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5992012294c3edcb86484e2e72be8b"><td class="memTemplParams" colspan="2"><a id="a0f5992012294c3edcb86484e2e72be8b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f5992012294c3edcb86484e2e72be8b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0f5992012294c3edcb86484e2e72be8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6794b80103011498ba66b35710b4fe"><td class="memTemplParams" colspan="2"><a id="aac6794b80103011498ba66b35710b4fe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac6794b80103011498ba66b35710b4fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aac6794b80103011498ba66b35710b4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44fb315d39d124a4dd96806b3cd407a"><td class="memTemplParams" colspan="2"><a id="af44fb315d39d124a4dd96806b3cd407a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af44fb315d39d124a4dd96806b3cd407a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af44fb315d39d124a4dd96806b3cd407a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8c5d657b0b8120c8332f2f80b0daf5"><td class="memTemplParams" colspan="2"><a id="a5e8c5d657b0b8120c8332f2f80b0daf5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e8c5d657b0b8120c8332f2f80b0daf5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5e8c5d657b0b8120c8332f2f80b0daf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c4da11aa39112dfefabaa203f94348"><td class="memTemplParams" colspan="2"><a id="a66c4da11aa39112dfefabaa203f94348"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66c4da11aa39112dfefabaa203f94348"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d44/classbit_1_1core_1_1ring__buffer.html">ring_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a66c4da11aa39112dfefabaa203f94348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96affd163ea4d2e3689d3df45baa32e1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a96affd163ea4d2e3689d3df45baa32e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a96affd163ea4d2e3689d3df45baa32e1">swap</a> (<a class="el" href="../../d2/d49/classbit_1_1core_1_1ring__deque.html">ring_deque</a>&lt; T, Allocator &gt; &amp;lhs, <a class="el" href="../../d2/d49/classbit_1_1core_1_1ring__deque.html">ring_deque</a>&lt; T, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a96affd163ea4d2e3689d3df45baa32e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two circular_deques.  <a href="#a96affd163ea4d2e3689d3df45baa32e1">More...</a><br /></td></tr>
<tr class="separator:a96affd163ea4d2e3689d3df45baa32e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e8063672f7c443cf924383a0d4de8a"><td class="memTemplParams" colspan="2"><a id="a85e8063672f7c443cf924383a0d4de8a"></a>
template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a85e8063672f7c443cf924383a0d4de8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d2/d49/classbit_1_1core_1_1ring__deque.html">ring_deque</a>&lt; T, Allocator &gt; &amp;lhs, const <a class="el" href="../../d2/d49/classbit_1_1core_1_1ring__deque.html">ring_deque</a>&lt; T, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a85e8063672f7c443cf924383a0d4de8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a30375db5e468fc5ee8e0c61238d59"><td class="memTemplParams" colspan="2"><a id="a85a30375db5e468fc5ee8e0c61238d59"></a>
template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a85a30375db5e468fc5ee8e0c61238d59"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d2/d49/classbit_1_1core_1_1ring__deque.html">ring_deque</a>&lt; T, Allocator &gt; &amp;lhs, const <a class="el" href="../../d2/d49/classbit_1_1core_1_1ring__deque.html">ring_deque</a>&lt; T, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a85a30375db5e468fc5ee8e0c61238d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea94db7b3bc698956ebff8a2367c0a4a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:aea94db7b3bc698956ebff8a2367c0a4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aea94db7b3bc698956ebff8a2367c0a4a">swap</a> (<a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aea94db7b3bc698956ebff8a2367c0a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of <code>lhs</code> with <code>rhs</code>.  <a href="#aea94db7b3bc698956ebff8a2367c0a4a">More...</a><br /></td></tr>
<tr class="separator:aea94db7b3bc698956ebff8a2367c0a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5040b18b1a5bbda86e320e68d215d586"><td class="memTemplParams" colspan="2"><a id="a5040b18b1a5bbda86e320e68d215d586"></a>
template&lt;std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:a5040b18b1a5bbda86e320e68d215d586"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a5040b18b1a5bbda86e320e68d215d586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d2447086dab3d9fb741f3321ad02e1"><td class="memTemplParams" colspan="2"><a id="a71d2447086dab3d9fb741f3321ad02e1"></a>
template&lt;std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:a71d2447086dab3d9fb741f3321ad02e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a71d2447086dab3d9fb741f3321ad02e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9655abaf3e7f1177d0f4c0b88e7d8f0"><td class="memTemplParams" colspan="2"><a id="ab9655abaf3e7f1177d0f4c0b88e7d8f0"></a>
template&lt;std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:ab9655abaf3e7f1177d0f4c0b88e7d8f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T &gt; &amp;&amp;x)</td></tr>
<tr class="separator:ab9655abaf3e7f1177d0f4c0b88e7d8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac17c288177df4f9d8b749c4d68720d"><td class="memTemplParams" colspan="2"><a id="a8ac17c288177df4f9d8b749c4d68720d"></a>
template&lt;std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:a8ac17c288177df4f9d8b749c4d68720d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T &gt; &amp;&amp;x)</td></tr>
<tr class="separator:a8ac17c288177df4f9d8b749c4d68720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5156d4c7c3298b7e7afbebbb9f574b52"><td class="memTemplParams" colspan="2"><a id="a5156d4c7c3298b7e7afbebbb9f574b52"></a>
template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a5156d4c7c3298b7e7afbebbb9f574b52"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5156d4c7c3298b7e7afbebbb9f574b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae900e8161ed74cd5d2d63189245476e8"><td class="memTemplParams" colspan="2"><a id="ae900e8161ed74cd5d2d63189245476e8"></a>
template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ae900e8161ed74cd5d2d63189245476e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae900e8161ed74cd5d2d63189245476e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab753669841a42ca46ad9e26986648fc7"><td class="memTemplParams" colspan="2"><a id="ab753669841a42ca46ad9e26986648fc7"></a>
template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ab753669841a42ca46ad9e26986648fc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab753669841a42ca46ad9e26986648fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2edb24cf5bc51d3713d217828a094d"><td class="memTemplParams" colspan="2"><a id="adb2edb24cf5bc51d3713d217828a094d"></a>
template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:adb2edb24cf5bc51d3713d217828a094d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:adb2edb24cf5bc51d3713d217828a094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b354dafb7cabde43edccece083a2da3"><td class="memTemplParams" colspan="2"><a id="a7b354dafb7cabde43edccece083a2da3"></a>
template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a7b354dafb7cabde43edccece083a2da3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7b354dafb7cabde43edccece083a2da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ff68542e2466c32f48ec4a9db4c376"><td class="memTemplParams" colspan="2"><a id="a12ff68542e2466c32f48ec4a9db4c376"></a>
template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a12ff68542e2466c32f48ec4a9db4c376"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a12ff68542e2466c32f48ec4a9db4c376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae2ae3e9fc4f10e6afbd5521bb93c8"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a2fae2ae3e9fc4f10e6afbd5521bb93c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2fae2ae3e9fc4f10e6afbd5521bb93c8">hash_value</a> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a2fae2ae3e9fc4f10e6afbd5521bb93c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a std::basic_string.  <a href="#a2fae2ae3e9fc4f10e6afbd5521bb93c8">More...</a><br /></td></tr>
<tr class="separator:a2fae2ae3e9fc4f10e6afbd5521bb93c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4e3ebbdfe30d764492264cd1c08e7a"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a1b4e3ebbdfe30d764492264cd1c08e7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1b4e3ebbdfe30d764492264cd1c08e7a">hash_value</a> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a1b4e3ebbdfe30d764492264cd1c08e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>.  <a href="#a1b4e3ebbdfe30d764492264cd1c08e7a">More...</a><br /></td></tr>
<tr class="separator:a1b4e3ebbdfe30d764492264cd1c08e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f751e76f09f7419be10785ba208bdbe"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a2f751e76f09f7419be10785ba208bdbe"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2f751e76f09f7419be10785ba208bdbe">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;o, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;str)</td></tr>
<tr class="memdesc:a2f751e76f09f7419be10785ba208bdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for ostream output of <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>.  <a href="#a2f751e76f09f7419be10785ba208bdbe">More...</a><br /></td></tr>
<tr class="separator:a2f751e76f09f7419be10785ba208bdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa020383b2c9172166889dc7ad7ae7541"><td class="memTemplParams" colspan="2"><a id="aa020383b2c9172166889dc7ad7ae7541"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aa020383b2c9172166889dc7ad7ae7541"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa020383b2c9172166889dc7ad7ae7541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f157daf774f817239f8b2b5e7dafe1"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a07f157daf774f817239f8b2b5e7dafe1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a07f157daf774f817239f8b2b5e7dafe1">operator==</a> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a07f157daf774f817239f8b2b5e7dafe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares equality between the two basic_string_views.  <a href="#a07f157daf774f817239f8b2b5e7dafe1">More...</a><br /></td></tr>
<tr class="separator:a07f157daf774f817239f8b2b5e7dafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22d6625325379573b7b759a51e59b59"><td class="memTemplParams" colspan="2"><a id="ab22d6625325379573b7b759a51e59b59"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ab22d6625325379573b7b759a51e59b59"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:ab22d6625325379573b7b759a51e59b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3d38daa5bd639cb09171e7952d82f1"><td class="memTemplParams" colspan="2"><a id="a5e3d38daa5bd639cb09171e7952d82f1"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a5e3d38daa5bd639cb09171e7952d82f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5e3d38daa5bd639cb09171e7952d82f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4a059fa6df889dd35dccb59bf83884"><td class="memTemplParams" colspan="2"><a id="a1b4a059fa6df889dd35dccb59bf83884"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a1b4a059fa6df889dd35dccb59bf83884"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a1b4a059fa6df889dd35dccb59bf83884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4804d141a65b1dae298fc1e760a41b7"><td class="memTemplParams" colspan="2"><a id="ab4804d141a65b1dae298fc1e760a41b7"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab4804d141a65b1dae298fc1e760a41b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const CharT *lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab4804d141a65b1dae298fc1e760a41b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79caf7dbaaf5700a4ff61be64700136c"><td class="memTemplParams" colspan="2"><a id="a79caf7dbaaf5700a4ff61be64700136c"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a79caf7dbaaf5700a4ff61be64700136c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a79caf7dbaaf5700a4ff61be64700136c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fea8cb75c2729feab7ce3b11a96b85"><td class="memTemplParams" colspan="2"><a id="ab0fea8cb75c2729feab7ce3b11a96b85"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ab0fea8cb75c2729feab7ce3b11a96b85"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab0fea8cb75c2729feab7ce3b11a96b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec057975f883b02cc93367432c37376"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a8ec057975f883b02cc93367432c37376"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a8ec057975f883b02cc93367432c37376">operator!=</a> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8ec057975f883b02cc93367432c37376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares inequality between the two basic_string_views.  <a href="#a8ec057975f883b02cc93367432c37376">More...</a><br /></td></tr>
<tr class="separator:a8ec057975f883b02cc93367432c37376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8646e48ee7a107b712194d5a796c0cbe"><td class="memTemplParams" colspan="2"><a id="a8646e48ee7a107b712194d5a796c0cbe"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a8646e48ee7a107b712194d5a796c0cbe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a8646e48ee7a107b712194d5a796c0cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8845322e79a2270aa7000e7ea266e8"><td class="memTemplParams" colspan="2"><a id="a9d8845322e79a2270aa7000e7ea266e8"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a9d8845322e79a2270aa7000e7ea266e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9d8845322e79a2270aa7000e7ea266e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447c25d5c89d1ae17f38ae4be57c1e22"><td class="memTemplParams" colspan="2"><a id="a447c25d5c89d1ae17f38ae4be57c1e22"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a447c25d5c89d1ae17f38ae4be57c1e22"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a447c25d5c89d1ae17f38ae4be57c1e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd9bdb4f8723a936f72513e5939faa3"><td class="memTemplParams" colspan="2"><a id="afcd9bdb4f8723a936f72513e5939faa3"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:afcd9bdb4f8723a936f72513e5939faa3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const CharT *lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:afcd9bdb4f8723a936f72513e5939faa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5dc58cdd1659fb948e0d2b6a6a7a96"><td class="memTemplParams" colspan="2"><a id="a5d5dc58cdd1659fb948e0d2b6a6a7a96"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a5d5dc58cdd1659fb948e0d2b6a6a7a96"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5d5dc58cdd1659fb948e0d2b6a6a7a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac464a1894918cdcc28f402794d72e986"><td class="memTemplParams" colspan="2"><a id="ac464a1894918cdcc28f402794d72e986"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ac464a1894918cdcc28f402794d72e986"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac464a1894918cdcc28f402794d72e986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a8f151582e28e4faec8ac30a1d8337"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a11a8f151582e28e4faec8ac30a1d8337"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a11a8f151582e28e4faec8ac30a1d8337">operator&lt;</a> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a11a8f151582e28e4faec8ac30a1d8337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the left string is less than the right substring.  <a href="#a11a8f151582e28e4faec8ac30a1d8337">More...</a><br /></td></tr>
<tr class="separator:a11a8f151582e28e4faec8ac30a1d8337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff68a8609128ab8c7afc6c510de6f7"><td class="memTemplParams" colspan="2"><a id="a93ff68a8609128ab8c7afc6c510de6f7"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a93ff68a8609128ab8c7afc6c510de6f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a93ff68a8609128ab8c7afc6c510de6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f2044feb6e9e439aea74af6ba18e41"><td class="memTemplParams" colspan="2"><a id="a04f2044feb6e9e439aea74af6ba18e41"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a04f2044feb6e9e439aea74af6ba18e41"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a04f2044feb6e9e439aea74af6ba18e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f3881e93a35b9e3442c463c9fd8c9a"><td class="memTemplParams" colspan="2"><a id="a20f3881e93a35b9e3442c463c9fd8c9a"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a20f3881e93a35b9e3442c463c9fd8c9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a20f3881e93a35b9e3442c463c9fd8c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f8780be405fcf4a4973ad329f00b43"><td class="memTemplParams" colspan="2"><a id="a02f8780be405fcf4a4973ad329f00b43"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a02f8780be405fcf4a4973ad329f00b43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const CharT *lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a02f8780be405fcf4a4973ad329f00b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3695cacc86dc6ac5127d1d25bcfe90"><td class="memTemplParams" colspan="2"><a id="aea3695cacc86dc6ac5127d1d25bcfe90"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aea3695cacc86dc6ac5127d1d25bcfe90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aea3695cacc86dc6ac5127d1d25bcfe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81310f876479161f89973182d777fbb8"><td class="memTemplParams" colspan="2"><a id="a81310f876479161f89973182d777fbb8"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a81310f876479161f89973182d777fbb8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a81310f876479161f89973182d777fbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ed87890ad4048faeec2ac2b69e1c39"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aa4ed87890ad4048faeec2ac2b69e1c39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa4ed87890ad4048faeec2ac2b69e1c39">operator&gt;</a> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa4ed87890ad4048faeec2ac2b69e1c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5022980c628fd64d8ac21e9a3ea65093"><td class="memTemplParams" colspan="2"><a id="a5022980c628fd64d8ac21e9a3ea65093"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a5022980c628fd64d8ac21e9a3ea65093"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a5022980c628fd64d8ac21e9a3ea65093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a0c7273f0a77db608855f1c961a6ea"><td class="memTemplParams" colspan="2"><a id="a41a0c7273f0a77db608855f1c961a6ea"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a41a0c7273f0a77db608855f1c961a6ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a41a0c7273f0a77db608855f1c961a6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2327b89ba1ed24d58bfed90a2d1e2c4"><td class="memTemplParams" colspan="2"><a id="ae2327b89ba1ed24d58bfed90a2d1e2c4"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ae2327b89ba1ed24d58bfed90a2d1e2c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:ae2327b89ba1ed24d58bfed90a2d1e2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a5a22a33fcd26262f610210e90ed25"><td class="memTemplParams" colspan="2"><a id="a20a5a22a33fcd26262f610210e90ed25"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a20a5a22a33fcd26262f610210e90ed25"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const CharT *lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a20a5a22a33fcd26262f610210e90ed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9e6104549104a39b8e08b4d2de8491"><td class="memTemplParams" colspan="2"><a id="a3d9e6104549104a39b8e08b4d2de8491"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a3d9e6104549104a39b8e08b4d2de8491"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3d9e6104549104a39b8e08b4d2de8491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f25cf512e3c0a300ee8d58e1ab782f8"><td class="memTemplParams" colspan="2"><a id="a5f25cf512e3c0a300ee8d58e1ab782f8"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a5f25cf512e3c0a300ee8d58e1ab782f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5f25cf512e3c0a300ee8d58e1ab782f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4065c82582548eee5f85c97fe8cf6509"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a4065c82582548eee5f85c97fe8cf6509"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a4065c82582548eee5f85c97fe8cf6509">operator&lt;=</a> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4065c82582548eee5f85c97fe8cf6509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade906f8b34cb6abde1a5a744b0dcf186"><td class="memTemplParams" colspan="2"><a id="ade906f8b34cb6abde1a5a744b0dcf186"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ade906f8b34cb6abde1a5a744b0dcf186"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:ade906f8b34cb6abde1a5a744b0dcf186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8bc1c7ad1ce551b1e984b6e0854bb9"><td class="memTemplParams" colspan="2"><a id="aca8bc1c7ad1ce551b1e984b6e0854bb9"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:aca8bc1c7ad1ce551b1e984b6e0854bb9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aca8bc1c7ad1ce551b1e984b6e0854bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a1ce8bb61634e74627c7d96e82bd13"><td class="memTemplParams" colspan="2"><a id="a94a1ce8bb61634e74627c7d96e82bd13"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a94a1ce8bb61634e74627c7d96e82bd13"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a94a1ce8bb61634e74627c7d96e82bd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe22238ad9e5e8be99406f57ce386b7c"><td class="memTemplParams" colspan="2"><a id="afe22238ad9e5e8be99406f57ce386b7c"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:afe22238ad9e5e8be99406f57ce386b7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const CharT *lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:afe22238ad9e5e8be99406f57ce386b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8222e582a0c851e80c28350121dc85b"><td class="memTemplParams" colspan="2"><a id="ad8222e582a0c851e80c28350121dc85b"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ad8222e582a0c851e80c28350121dc85b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad8222e582a0c851e80c28350121dc85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f306dbd24fb5a7dcb54203db4676ef"><td class="memTemplParams" colspan="2"><a id="a39f306dbd24fb5a7dcb54203db4676ef"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a39f306dbd24fb5a7dcb54203db4676ef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a39f306dbd24fb5a7dcb54203db4676ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cf79e95613e1b933f66da7112cb32b"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a89cf79e95613e1b933f66da7112cb32b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a89cf79e95613e1b933f66da7112cb32b">operator&gt;=</a> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a89cf79e95613e1b933f66da7112cb32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5295d4c738d909e0043b7b44f35c75ea"><td class="memTemplParams" colspan="2"><a id="a5295d4c738d909e0043b7b44f35c75ea"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a5295d4c738d909e0043b7b44f35c75ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a5295d4c738d909e0043b7b44f35c75ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af435d13926b5133f35175723dffc981f"><td class="memTemplParams" colspan="2"><a id="af435d13926b5133f35175723dffc981f"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:af435d13926b5133f35175723dffc981f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af435d13926b5133f35175723dffc981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a82a24fc6a59f4d5691265e39bbbd5e"><td class="memTemplParams" colspan="2"><a id="a6a82a24fc6a59f4d5691265e39bbbd5e"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a6a82a24fc6a59f4d5691265e39bbbd5e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a6a82a24fc6a59f4d5691265e39bbbd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5799516843dcc60404253a91f2663a"><td class="memTemplParams" colspan="2"><a id="afc5799516843dcc60404253a91f2663a"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:afc5799516843dcc60404253a91f2663a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const CharT *lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:afc5799516843dcc60404253a91f2663a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade1f78ea5e9374932be9b72d9f4c5c0"><td class="memTemplParams" colspan="2"><a id="aade1f78ea5e9374932be9b72d9f4c5c0"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aade1f78ea5e9374932be9b72d9f4c5c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aade1f78ea5e9374932be9b72d9f4c5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea8e350eea874f184575218db11a3a5"><td class="memTemplParams" colspan="2"><a id="a5ea8e350eea874f184575218db11a3a5"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a5ea8e350eea874f184575218db11a3a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5ea8e350eea874f184575218db11a3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49b87d2933196de8934a724e1ca14ea"><td class="memTemplParams" colspan="2"><a id="af49b87d2933196de8934a724e1ca14ea"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:af49b87d2933196de8934a724e1ca14ea"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="separator:af49b87d2933196de8934a724e1ca14ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2b4c9d6ecb2ed1779e98ee8939e190"><td class="memTemplParams" colspan="2"><a id="a2b2b4c9d6ecb2ed1779e98ee8939e190"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a2b2b4c9d6ecb2ed1779e98ee8939e190"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs)</td></tr>
<tr class="separator:a2b2b4c9d6ecb2ed1779e98ee8939e190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1238d43c3a0fe23a9c9c0dfdafca55b1"><td class="memTemplParams" colspan="2"><a id="a1238d43c3a0fe23a9c9c0dfdafca55b1"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a1238d43c3a0fe23a9c9c0dfdafca55b1"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="separator:a1238d43c3a0fe23a9c9c0dfdafca55b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08efcd2722ec2e5512b51f00694db94c"><td class="memTemplParams" colspan="2"><a id="a08efcd2722ec2e5512b51f00694db94c"></a>
template&lt;typename Iterator , typename U &gt; </td></tr>
<tr class="memitem:a08efcd2722ec2e5512b51f00694db94c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a>&lt; Iterator, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a>&lt; Iterator, U &gt; &amp;lhs, typename <a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a>&lt; Iterator, U &gt;::difference_type rhs) noexcept</td></tr>
<tr class="separator:a08efcd2722ec2e5512b51f00694db94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1b2a20e8c9393639564dc3d818cf26"><td class="memTemplParams" colspan="2"><a id="a7d1b2a20e8c9393639564dc3d818cf26"></a>
template&lt;typename Iterator , typename U &gt; </td></tr>
<tr class="memitem:a7d1b2a20e8c9393639564dc3d818cf26"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a>&lt; Iterator, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (typename <a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a>&lt; Iterator, U &gt;::difference_type lhs, const <a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a>&lt; Iterator, U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7d1b2a20e8c9393639564dc3d818cf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263746dc1191cf46905dbe951ff4a378"><td class="memTemplParams" colspan="2"><a id="a263746dc1191cf46905dbe951ff4a378"></a>
template&lt;typename Iterator , typename U &gt; </td></tr>
<tr class="memitem:a263746dc1191cf46905dbe951ff4a378"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a>&lt; Iterator, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a>&lt; Iterator, U &gt; &amp;lhs, typename <a class="el" href="../../d4/d5c/classbit_1_1core_1_1tagged__iterator.html">tagged_iterator</a>&lt; Iterator, U &gt;::difference_type rhs) noexcept</td></tr>
<tr class="separator:a263746dc1191cf46905dbe951ff4a378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc04693e469b283cba46573bdcf42ec"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Iterator &gt; </td></tr>
<tr class="memitem:affc04693e469b283cba46573bdcf42ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; N, Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#affc04693e469b283cba46573bdcf42ec">make_tuple_element_iterator</a> (Iterator it)</td></tr>
<tr class="memdesc:affc04693e469b283cba46573bdcf42ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to type-deduce and make an iterator for iterating specific tuple elements.  <a href="#affc04693e469b283cba46573bdcf42ec">More...</a><br /></td></tr>
<tr class="separator:affc04693e469b283cba46573bdcf42ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb98239a989d7a4d511643e45b98bf71"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aeb98239a989d7a4d511643e45b98bf71"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aeb98239a989d7a4d511643e45b98bf71">make_key_iterator</a> (Iterator it)</td></tr>
<tr class="memdesc:aeb98239a989d7a4d511643e45b98bf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for making a tuple iterator that only iterates the first tuple element, which is the key in associative containers.  <a href="#aeb98239a989d7a4d511643e45b98bf71">More...</a><br /></td></tr>
<tr class="separator:aeb98239a989d7a4d511643e45b98bf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5463a0af76ffc03c812934a15b390d4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ae5463a0af76ffc03c812934a15b390d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae5463a0af76ffc03c812934a15b390d4">make_value_iterator</a> (Iterator it)</td></tr>
<tr class="memdesc:ae5463a0af76ffc03c812934a15b390d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for making a tuple iterator that only iterates the second tuple element, which is the value in associative containers.  <a href="#ae5463a0af76ffc03c812934a15b390d4">More...</a><br /></td></tr>
<tr class="separator:ae5463a0af76ffc03c812934a15b390d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d3341eb206c1e252ba3b4b6af3e08a"><td class="memTemplParams" colspan="2"><a id="a96d3341eb206c1e252ba3b4b6af3e08a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96d3341eb206c1e252ba3b4b6af3e08a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a96d3341eb206c1e252ba3b4b6af3e08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efd8da749e24f613328a69af8ce0755"><td class="memTemplParams" colspan="2"><a id="a0efd8da749e24f613328a69af8ce0755"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0efd8da749e24f613328a69af8ce0755"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0efd8da749e24f613328a69af8ce0755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859cd701388ae3fd5ff115645348cc24"><td class="memTemplParams" colspan="2"><a id="a859cd701388ae3fd5ff115645348cc24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a859cd701388ae3fd5ff115645348cc24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a859cd701388ae3fd5ff115645348cc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd85ab3cf2c06d08441bb6565fa805e6"><td class="memTemplParams" colspan="2"><a id="abd85ab3cf2c06d08441bb6565fa805e6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd85ab3cf2c06d08441bb6565fa805e6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:abd85ab3cf2c06d08441bb6565fa805e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e079c60613d0f40a71467de98255224"><td class="memTemplParams" colspan="2"><a id="a7e079c60613d0f40a71467de98255224"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e079c60613d0f40a71467de98255224"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7e079c60613d0f40a71467de98255224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08153c1f18e5df2a3a403f770cae5a80"><td class="memTemplParams" colspan="2"><a id="a08153c1f18e5df2a3a403f770cae5a80"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08153c1f18e5df2a3a403f770cae5a80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a08153c1f18e5df2a3a403f770cae5a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95487145d29c03ee0a60709523580a1"><td class="memTemplParams" colspan="2"><a id="ae95487145d29c03ee0a60709523580a1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae95487145d29c03ee0a60709523580a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ae95487145d29c03ee0a60709523580a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429b67d8fd8985a875ab2e502a674a35"><td class="memTemplParams" colspan="2"><a id="a429b67d8fd8985a875ab2e502a674a35"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a429b67d8fd8985a875ab2e502a674a35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a429b67d8fd8985a875ab2e502a674a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e708e9261d271b8febf0a53e6a7ea42"><td class="memTemplParams" colspan="2"><a id="a9e708e9261d271b8febf0a53e6a7ea42"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e708e9261d271b8febf0a53e6a7ea42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a9e708e9261d271b8febf0a53e6a7ea42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f551a6b8449d1d1f7c218284754882"><td class="memTemplParams" colspan="2"><a id="af2f551a6b8449d1d1f7c218284754882"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2f551a6b8449d1d1f7c218284754882"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af2f551a6b8449d1d1f7c218284754882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d732a798e26c01833afcd7a504d5bf6"><td class="memTemplParams" colspan="2"><a id="a9d732a798e26c01833afcd7a504d5bf6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d732a798e26c01833afcd7a504d5bf6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a9d732a798e26c01833afcd7a504d5bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ce4da63ead9c50efc4aa8623ae6eb"><td class="memTemplParams" colspan="2"><a id="a9f3ce4da63ead9c50efc4aa8623ae6eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f3ce4da63ead9c50efc4aa8623ae6eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (std::nullptr_t, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9f3ce4da63ead9c50efc4aa8623ae6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf88b2794a6aa5542594ffd38a0d2d37"><td class="memTemplParams" colspan="2"><a id="abf88b2794a6aa5542594ffd38a0d2d37"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf88b2794a6aa5542594ffd38a0d2d37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:abf88b2794a6aa5542594ffd38a0d2d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a3541a8aec18b1c099c83ed0b570c0"><td class="memTemplParams" colspan="2"><a id="a56a3541a8aec18b1c099c83ed0b570c0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56a3541a8aec18b1c099c83ed0b570c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (std::nullptr_t, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a56a3541a8aec18b1c099c83ed0b570c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406345206c1599b308c470c99a116c4d"><td class="memTemplParams" colspan="2"><a id="a406345206c1599b308c470c99a116c4d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a406345206c1599b308c470c99a116c4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a406345206c1599b308c470c99a116c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209c9b9e257a4e5e446a9afcaec59762"><td class="memTemplParams" colspan="2"><a id="a209c9b9e257a4e5e446a9afcaec59762"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a209c9b9e257a4e5e446a9afcaec59762"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (std::nullptr_t, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a209c9b9e257a4e5e446a9afcaec59762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5b8b21280fa22f84d3a98d9a288812"><td class="memTemplParams" colspan="2"><a id="a1c5b8b21280fa22f84d3a98d9a288812"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c5b8b21280fa22f84d3a98d9a288812"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a1c5b8b21280fa22f84d3a98d9a288812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2e42ff5b747b7666c781f006cfbe1b"><td class="memTemplParams" colspan="2"><a id="aaa2e42ff5b747b7666c781f006cfbe1b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa2e42ff5b747b7666c781f006cfbe1b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (std::nullptr_t, const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aaa2e42ff5b747b7666c781f006cfbe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b0e01a85704c50710bac007b6d8aaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34b0e01a85704c50710bac007b6d8aaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a34b0e01a85704c50710bac007b6d8aaf">swap</a> (<a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a34b0e01a85704c50710bac007b6d8aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of <code>lhs</code> with <code>rhs</code>.  <a href="#a34b0e01a85704c50710bac007b6d8aaf">More...</a><br /></td></tr>
<tr class="separator:a34b0e01a85704c50710bac007b6d8aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f503ae080ce536353c2e1888cfadb69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f503ae080ce536353c2e1888cfadb69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3f503ae080ce536353c2e1888cfadb69">hash_value</a> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:a3f503ae080ce536353c2e1888cfadb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes this <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a>.  <a href="#a3f503ae080ce536353c2e1888cfadb69">More...</a><br /></td></tr>
<tr class="separator:a3f503ae080ce536353c2e1888cfadb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72e9e9bd0666bf000471641e06606fd"><td class="memTemplParams" colspan="2">template&lt;typename Deleter , typename T &gt; </td></tr>
<tr class="memitem:ac72e9e9bd0666bf000471641e06606fd"><td class="memTemplItemLeft" align="right" valign="top">Deleter *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac72e9e9bd0666bf000471641e06606fd">get_deleter</a> (const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ac72e9e9bd0666bf000471641e06606fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the deleter from <code>ptr</code>.  <a href="#ac72e9e9bd0666bf000471641e06606fd">More...</a><br /></td></tr>
<tr class="separator:ac72e9e9bd0666bf000471641e06606fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385758d8cbdedd7ccf47abb1af349086"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a385758d8cbdedd7ccf47abb1af349086"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a385758d8cbdedd7ccf47abb1af349086">make_exclusive</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a385758d8cbdedd7ccf47abb1af349086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a> from the given <code>args</code>.  <a href="#a385758d8cbdedd7ccf47abb1af349086">More...</a><br /></td></tr>
<tr class="separator:a385758d8cbdedd7ccf47abb1af349086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72b086c85f13bf0c6bb6bdf36b33dc3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator , typename... Args&gt; </td></tr>
<tr class="memitem:ad72b086c85f13bf0c6bb6bdf36b33dc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad72b086c85f13bf0c6bb6bdf36b33dc3">allocate_exclusive</a> (const Allocator &amp;allocator, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ad72b086c85f13bf0c6bb6bdf36b33dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a>, forwarding <code>args</code> to the underyling constructor.  <a href="#ad72b086c85f13bf0c6bb6bdf36b33dc3">More...</a><br /></td></tr>
<tr class="separator:ad72b086c85f13bf0c6bb6bdf36b33dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592ab70b4f1bdab17b3997e99b7315a2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a592ab70b4f1bdab17b3997e99b7315a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a592ab70b4f1bdab17b3997e99b7315a2">address_from</a> (InputIterator &amp;it) noexcept -&gt; typename std::iterator_traits&lt; InputIterator &gt;::value_type *</td></tr>
<tr class="memdesc:a592ab70b4f1bdab17b3997e99b7315a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object referenced through an iterator <code>it</code>.  <a href="#a592ab70b4f1bdab17b3997e99b7315a2">More...</a><br /></td></tr>
<tr class="separator:a592ab70b4f1bdab17b3997e99b7315a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1db675d6cd6e7be647306f52d1c4922"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1db675d6cd6e7be647306f52d1c4922"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af1db675d6cd6e7be647306f52d1c4922">dereference</a> (T &amp;ptr)</td></tr>
<tr class="memdesc:af1db675d6cd6e7be647306f52d1c4922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences all levels of pointer indirection from the supplied pointer.  <a href="#af1db675d6cd6e7be647306f52d1c4922">More...</a><br /></td></tr>
<tr class="separator:af1db675d6cd6e7be647306f52d1c4922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e195c7a8247a0098abbfa167aed1ade"><td class="memItemLeft" align="right" valign="top">std::uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2e195c7a8247a0098abbfa167aed1ade">to_address</a> (void *ptr) noexcept</td></tr>
<tr class="memdesc:a2e195c7a8247a0098abbfa167aed1ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer <code>ptr</code> into an integral type representing the address.  <a href="#a2e195c7a8247a0098abbfa167aed1ade">More...</a><br /></td></tr>
<tr class="separator:a2e195c7a8247a0098abbfa167aed1ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b6a1261d77a5190c87bb6b68b568c3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab7b6a1261d77a5190c87bb6b68b568c3">from_address</a> (std::uintptr_t address) noexcept</td></tr>
<tr class="memdesc:ab7b6a1261d77a5190c87bb6b68b568c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric address <code>address</code> into a pointer pointing to the address location.  <a href="#ab7b6a1261d77a5190c87bb6b68b568c3">More...</a><br /></td></tr>
<tr class="separator:ab7b6a1261d77a5190c87bb6b68b568c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f8137a00f2758c28b20a903ee3500"><td class="memTemplParams" colspan="2"><a id="a168f8137a00f2758c28b20a903ee3500"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a168f8137a00f2758c28b20a903ee3500"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a168f8137a00f2758c28b20a903ee3500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7d2c29fd1b44c891fa15c223b5ad30"><td class="memTemplParams" colspan="2"><a id="aee7d2c29fd1b44c891fa15c223b5ad30"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aee7d2c29fd1b44c891fa15c223b5ad30"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aee7d2c29fd1b44c891fa15c223b5ad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdea967c50c515fcb2e44fcb7ac0b2a"><td class="memTemplParams" colspan="2"><a id="a6bdea967c50c515fcb2e44fcb7ac0b2a"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6bdea967c50c515fcb2e44fcb7ac0b2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a6bdea967c50c515fcb2e44fcb7ac0b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7291a43bbf49964f88d5bf32ab48ccbb"><td class="memTemplParams" colspan="2"><a id="a7291a43bbf49964f88d5bf32ab48ccbb"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7291a43bbf49964f88d5bf32ab48ccbb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7291a43bbf49964f88d5bf32ab48ccbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8aeda8a578ae911f6488f5faf039741"><td class="memTemplParams" colspan="2"><a id="ae8aeda8a578ae911f6488f5faf039741"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae8aeda8a578ae911f6488f5faf039741"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae8aeda8a578ae911f6488f5faf039741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77f5beae7894d0ff942f646476647bb"><td class="memTemplParams" colspan="2"><a id="ab77f5beae7894d0ff942f646476647bb"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab77f5beae7894d0ff942f646476647bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab77f5beae7894d0ff942f646476647bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0d07d6e99093d878cd4c07beeb87b0"><td class="memTemplParams" colspan="2"><a id="afa0d07d6e99093d878cd4c07beeb87b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa0d07d6e99093d878cd4c07beeb87b0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:afa0d07d6e99093d878cd4c07beeb87b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9679d858af983f23200fcde2c694c92a"><td class="memTemplParams" colspan="2"><a id="a9679d858af983f23200fcde2c694c92a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9679d858af983f23200fcde2c694c92a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a9679d858af983f23200fcde2c694c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08484c9cb094513b8e36b799a2d301b"><td class="memTemplParams" colspan="2"><a id="ac08484c9cb094513b8e36b799a2d301b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac08484c9cb094513b8e36b799a2d301b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac08484c9cb094513b8e36b799a2d301b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b2bb0497d9684bd1bfe7b8b697a6cf"><td class="memTemplParams" colspan="2"><a id="ad3b2bb0497d9684bd1bfe7b8b697a6cf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3b2bb0497d9684bd1bfe7b8b697a6cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ad3b2bb0497d9684bd1bfe7b8b697a6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba484f1896fefa5d6124e7ec445b5a4"><td class="memTemplParams" colspan="2"><a id="a2ba484f1896fefa5d6124e7ec445b5a4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ba484f1896fefa5d6124e7ec445b5a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (std::nullptr_t, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a2ba484f1896fefa5d6124e7ec445b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c392661884c9daf4e05986b98dbc85"><td class="memTemplParams" colspan="2"><a id="a96c392661884c9daf4e05986b98dbc85"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96c392661884c9daf4e05986b98dbc85"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a96c392661884c9daf4e05986b98dbc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e671a740af09e190a1edb90a5ec7633"><td class="memTemplParams" colspan="2"><a id="a1e671a740af09e190a1edb90a5ec7633"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e671a740af09e190a1edb90a5ec7633"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (std::nullptr_t, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1e671a740af09e190a1edb90a5ec7633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1add33519054155b2c837f46360a09b"><td class="memTemplParams" colspan="2"><a id="ab1add33519054155b2c837f46360a09b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1add33519054155b2c837f46360a09b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ab1add33519054155b2c837f46360a09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c557a35eea0a11f4cb9e8b5137b11d"><td class="memTemplParams" colspan="2"><a id="a03c557a35eea0a11f4cb9e8b5137b11d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03c557a35eea0a11f4cb9e8b5137b11d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (std::nullptr_t, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a03c557a35eea0a11f4cb9e8b5137b11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5222caa839499639a7fea0ddd40f6a5d"><td class="memTemplParams" colspan="2"><a id="a5222caa839499639a7fea0ddd40f6a5d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5222caa839499639a7fea0ddd40f6a5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a5222caa839499639a7fea0ddd40f6a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97730656f077f38c298042560076ad61"><td class="memTemplParams" colspan="2"><a id="a97730656f077f38c298042560076ad61"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97730656f077f38c298042560076ad61"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (std::nullptr_t, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a97730656f077f38c298042560076ad61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9c24e99dc974ea64afe6af5e40fb61"><td class="memTemplParams" colspan="2"><a id="a4f9c24e99dc974ea64afe6af5e40fb61"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f9c24e99dc974ea64afe6af5e40fb61"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a4f9c24e99dc974ea64afe6af5e40fb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78f96999221619f9ee39fbd14586d62"><td class="memTemplParams" colspan="2"><a id="aa78f96999221619f9ee39fbd14586d62"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aa78f96999221619f9ee39fbd14586d62"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T *lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa78f96999221619f9ee39fbd14586d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65379415ea8d34b7bb7c44c1b4b7de37"><td class="memTemplParams" colspan="2"><a id="a65379415ea8d34b7bb7c44c1b4b7de37"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a65379415ea8d34b7bb7c44c1b4b7de37"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a65379415ea8d34b7bb7c44c1b4b7de37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7490b954d2e25a591cb6ec429e65286d"><td class="memTemplParams" colspan="2"><a id="a7490b954d2e25a591cb6ec429e65286d"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a7490b954d2e25a591cb6ec429e65286d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T *lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7490b954d2e25a591cb6ec429e65286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ae4b1ed150d68f790c269fe3586257"><td class="memTemplParams" colspan="2"><a id="ab8ae4b1ed150d68f790c269fe3586257"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ab8ae4b1ed150d68f790c269fe3586257"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:ab8ae4b1ed150d68f790c269fe3586257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3baf4451543f0cb3aa2461ef87c918"><td class="memTemplParams" colspan="2"><a id="a1c3baf4451543f0cb3aa2461ef87c918"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a1c3baf4451543f0cb3aa2461ef87c918"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T *lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1c3baf4451543f0cb3aa2461ef87c918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf4e7335e7c8c60eb057aea42df95c1"><td class="memTemplParams" colspan="2"><a id="adcf4e7335e7c8c60eb057aea42df95c1"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:adcf4e7335e7c8c60eb057aea42df95c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:adcf4e7335e7c8c60eb057aea42df95c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee5ef537ba57e62d7dc80abfad51bfa"><td class="memTemplParams" colspan="2"><a id="a1ee5ef537ba57e62d7dc80abfad51bfa"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a1ee5ef537ba57e62d7dc80abfad51bfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T *lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1ee5ef537ba57e62d7dc80abfad51bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fb02a514659e08bc5bf944f1061069"><td class="memTemplParams" colspan="2"><a id="a83fb02a514659e08bc5bf944f1061069"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a83fb02a514659e08bc5bf944f1061069"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a83fb02a514659e08bc5bf944f1061069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1dba4c310c03163fba314b8bf99256"><td class="memTemplParams" colspan="2"><a id="ace1dba4c310c03163fba314b8bf99256"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ace1dba4c310c03163fba314b8bf99256"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T *lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ace1dba4c310c03163fba314b8bf99256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18b82e8726ecee528011499da356a43"><td class="memTemplParams" colspan="2"><a id="ab18b82e8726ecee528011499da356a43"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ab18b82e8726ecee528011499da356a43"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:ab18b82e8726ecee528011499da356a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac765dde99f544b06e32335526f6db306"><td class="memTemplParams" colspan="2"><a id="ac765dde99f544b06e32335526f6db306"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ac765dde99f544b06e32335526f6db306"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T *lhs, const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac765dde99f544b06e32335526f6db306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc101df9c8d6c127f731edf6b3bdc5a"><td class="memTemplParams" colspan="2"><a id="a5fc101df9c8d6c127f731edf6b3bdc5a"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a5fc101df9c8d6c127f731edf6b3bdc5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a5fc101df9c8d6c127f731edf6b3bdc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bcacde1d6dd37205e7366afce04dea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7bcacde1d6dd37205e7366afce04dea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae7bcacde1d6dd37205e7366afce04dea">swap</a> (<a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae7bcacde1d6dd37205e7366afce04dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> <code>lhs</code> with <code>rhs</code>.  <a href="#ae7bcacde1d6dd37205e7366afce04dea">More...</a><br /></td></tr>
<tr class="separator:ae7bcacde1d6dd37205e7366afce04dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7109380717cfe420349abf170ea884c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7109380717cfe420349abf170ea884c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa7109380717cfe420349abf170ea884c">hash_value</a> (const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:aa7109380717cfe420349abf170ea884c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes this <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a>.  <a href="#aa7109380717cfe420349abf170ea884c">More...</a><br /></td></tr>
<tr class="separator:aa7109380717cfe420349abf170ea884c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916d653daf216702003d0a122d6fd744"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a916d653daf216702003d0a122d6fd744"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a916d653daf216702003d0a122d6fd744">make_observer</a> (T *ptr) noexcept</td></tr>
<tr class="memdesc:a916d653daf216702003d0a122d6fd744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a raw pointer.  <a href="#a916d653daf216702003d0a122d6fd744">More...</a><br /></td></tr>
<tr class="separator:a916d653daf216702003d0a122d6fd744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29089b0b119e21e2f65a5b7449f0c9ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename  = std::enable_if_t&lt;!std::is_same&lt;T,U&gt;::value &amp;&amp; std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a29089b0b119e21e2f65a5b7449f0c9ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a29089b0b119e21e2f65a5b7449f0c9ba">make_observer</a> (U *ptr) noexcept</td></tr>
<tr class="memdesc:a29089b0b119e21e2f65a5b7449f0c9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a raw pointer, and coerces it to the specified type.  <a href="#a29089b0b119e21e2f65a5b7449f0c9ba">More...</a><br /></td></tr>
<tr class="separator:a29089b0b119e21e2f65a5b7449f0c9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd28445da50e3e955e6744428192dbc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Pointer , typename  = std::enable_if_t&lt;detail::is_ptr_observable&lt;Pointer&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aecd28445da50e3e955e6744428192dbc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aecd28445da50e3e955e6744428192dbc">make_observer</a> (const Pointer &amp;ptr) noexcept</td></tr>
<tr class="memdesc:aecd28445da50e3e955e6744428192dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a smart pointer.  <a href="#aecd28445da50e3e955e6744428192dbc">More...</a><br /></td></tr>
<tr class="separator:aecd28445da50e3e955e6744428192dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62350f3471df4a3d8cbc0035df5524f6"><td class="memTemplParams" colspan="2"><a id="a62350f3471df4a3d8cbc0035df5524f6"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a62350f3471df4a3d8cbc0035df5524f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a62350f3471df4a3d8cbc0035df5524f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa01dcffcab544d7ea2a4f0a18633cb4"><td class="memTemplParams" colspan="2"><a id="afa01dcffcab544d7ea2a4f0a18633cb4"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:afa01dcffcab544d7ea2a4f0a18633cb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:afa01dcffcab544d7ea2a4f0a18633cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ec6beee5dc97ecfd4804db613fad74"><td class="memTemplParams" colspan="2"><a id="a29ec6beee5dc97ecfd4804db613fad74"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a29ec6beee5dc97ecfd4804db613fad74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a29ec6beee5dc97ecfd4804db613fad74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa5218a1695e0d64f2a545a3e6da17f"><td class="memTemplParams" colspan="2"><a id="aeaa5218a1695e0d64f2a545a3e6da17f"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aeaa5218a1695e0d64f2a545a3e6da17f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aeaa5218a1695e0d64f2a545a3e6da17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dafa6ad77f8035c4577657b72d641dc"><td class="memTemplParams" colspan="2"><a id="a1dafa6ad77f8035c4577657b72d641dc"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1dafa6ad77f8035c4577657b72d641dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1dafa6ad77f8035c4577657b72d641dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e173ee5e337d2b5b9fd63df2dfb12e9"><td class="memTemplParams" colspan="2"><a id="a6e173ee5e337d2b5b9fd63df2dfb12e9"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6e173ee5e337d2b5b9fd63df2dfb12e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a6e173ee5e337d2b5b9fd63df2dfb12e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd3146e4739f6b74006036dc30afb91"><td class="memTemplParams" colspan="2"><a id="a0fd3146e4739f6b74006036dc30afb91"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0fd3146e4739f6b74006036dc30afb91"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a0fd3146e4739f6b74006036dc30afb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654753d9a6ae0d62d82825581f0a5dc2"><td class="memTemplParams" colspan="2"><a id="a654753d9a6ae0d62d82825581f0a5dc2"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a654753d9a6ae0d62d82825581f0a5dc2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T *lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a654753d9a6ae0d62d82825581f0a5dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807c4a74d14b6c119c34588448c348a3"><td class="memTemplParams" colspan="2"><a id="a807c4a74d14b6c119c34588448c348a3"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a807c4a74d14b6c119c34588448c348a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a807c4a74d14b6c119c34588448c348a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a62c4a16fb911dd31e14d82465b374"><td class="memTemplParams" colspan="2"><a id="a78a62c4a16fb911dd31e14d82465b374"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a78a62c4a16fb911dd31e14d82465b374"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T *lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a78a62c4a16fb911dd31e14d82465b374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a926a11341fa3a4426bd4e464a4239"><td class="memTemplParams" colspan="2"><a id="a28a926a11341fa3a4426bd4e464a4239"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a28a926a11341fa3a4426bd4e464a4239"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a28a926a11341fa3a4426bd4e464a4239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c10a6688bf15c91aca26f3501d72e45"><td class="memTemplParams" colspan="2"><a id="a1c10a6688bf15c91aca26f3501d72e45"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1c10a6688bf15c91aca26f3501d72e45"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T *lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1c10a6688bf15c91aca26f3501d72e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad410b12345e9b25d58ea5e10716098fe"><td class="memTemplParams" colspan="2"><a id="ad410b12345e9b25d58ea5e10716098fe"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad410b12345e9b25d58ea5e10716098fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:ad410b12345e9b25d58ea5e10716098fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad713e2fb4e4616f1322b3708f64b65f"><td class="memTemplParams" colspan="2"><a id="aad713e2fb4e4616f1322b3708f64b65f"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aad713e2fb4e4616f1322b3708f64b65f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T *lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aad713e2fb4e4616f1322b3708f64b65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82d177f5e69db7a702779dccc2a3dec"><td class="memTemplParams" colspan="2"><a id="ab82d177f5e69db7a702779dccc2a3dec"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab82d177f5e69db7a702779dccc2a3dec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:ab82d177f5e69db7a702779dccc2a3dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4df8e13b13796533991efa94e74cc4"><td class="memTemplParams" colspan="2"><a id="a4e4df8e13b13796533991efa94e74cc4"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4e4df8e13b13796533991efa94e74cc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T *lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4e4df8e13b13796533991efa94e74cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c12b1f8c81dbc0ffa98799b52e8732"><td class="memTemplParams" colspan="2"><a id="a19c12b1f8c81dbc0ffa98799b52e8732"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a19c12b1f8c81dbc0ffa98799b52e8732"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a19c12b1f8c81dbc0ffa98799b52e8732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15c09aa58fba7228d44cfcccbc90037"><td class="memTemplParams" colspan="2"><a id="aa15c09aa58fba7228d44cfcccbc90037"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa15c09aa58fba7228d44cfcccbc90037"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T *lhs, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa15c09aa58fba7228d44cfcccbc90037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c7da5d6c82057f6c0e5a4e96c2365c"><td class="memTemplParams" colspan="2"><a id="a65c7da5d6c82057f6c0e5a4e96c2365c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65c7da5d6c82057f6c0e5a4e96c2365c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a65c7da5d6c82057f6c0e5a4e96c2365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9876a82af3b29da8df416f4de932745f"><td class="memTemplParams" colspan="2"><a id="a9876a82af3b29da8df416f4de932745f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9876a82af3b29da8df416f4de932745f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9876a82af3b29da8df416f4de932745f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e323e3ca2b537e909c47f824aa6f33"><td class="memTemplParams" colspan="2"><a id="a50e323e3ca2b537e909c47f824aa6f33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50e323e3ca2b537e909c47f824aa6f33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a50e323e3ca2b537e909c47f824aa6f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91daa049b9f827f55f77f47881f19f27"><td class="memTemplParams" colspan="2"><a id="a91daa049b9f827f55f77f47881f19f27"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91daa049b9f827f55f77f47881f19f27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a91daa049b9f827f55f77f47881f19f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ce60dac695420c576854a6090ce2fc"><td class="memTemplParams" colspan="2"><a id="ab9ce60dac695420c576854a6090ce2fc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9ce60dac695420c576854a6090ce2fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ab9ce60dac695420c576854a6090ce2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ed07e1af702ee3369d8b29ed3f09c1"><td class="memTemplParams" colspan="2"><a id="aa5ed07e1af702ee3369d8b29ed3f09c1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5ed07e1af702ee3369d8b29ed3f09c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (std::nullptr_t, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa5ed07e1af702ee3369d8b29ed3f09c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd0139da88c6e8c494519c651cf20e0"><td class="memTemplParams" colspan="2"><a id="a2bd0139da88c6e8c494519c651cf20e0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2bd0139da88c6e8c494519c651cf20e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a2bd0139da88c6e8c494519c651cf20e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b8db163c949c5d3086f56becfa5c7d"><td class="memTemplParams" colspan="2"><a id="aa0b8db163c949c5d3086f56becfa5c7d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0b8db163c949c5d3086f56becfa5c7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (std::nullptr_t, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa0b8db163c949c5d3086f56becfa5c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f20ced05c3d874b58eac0d5a1d8704"><td class="memTemplParams" colspan="2"><a id="a29f20ced05c3d874b58eac0d5a1d8704"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29f20ced05c3d874b58eac0d5a1d8704"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a29f20ced05c3d874b58eac0d5a1d8704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbf908497bcab4b4caa7e93a87c2050"><td class="memTemplParams" colspan="2"><a id="aedbf908497bcab4b4caa7e93a87c2050"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedbf908497bcab4b4caa7e93a87c2050"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (std::nullptr_t, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aedbf908497bcab4b4caa7e93a87c2050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22f1ab8d13dd02d6fbc6c95c96b7155"><td class="memTemplParams" colspan="2"><a id="ab22f1ab8d13dd02d6fbc6c95c96b7155"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab22f1ab8d13dd02d6fbc6c95c96b7155"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ab22f1ab8d13dd02d6fbc6c95c96b7155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa617cd8dd710b4344e24f89933e098"><td class="memTemplParams" colspan="2"><a id="acfa617cd8dd710b4344e24f89933e098"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfa617cd8dd710b4344e24f89933e098"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (std::nullptr_t, const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:acfa617cd8dd710b4344e24f89933e098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f95f40c6b858137740e5f8fb36170b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76f95f40c6b858137740e5f8fb36170b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a76f95f40c6b858137740e5f8fb36170b">swap</a> (<a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a76f95f40c6b858137740e5f8fb36170b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the instances of two <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html" title="An offset pointer based on boost::offset_ptr. ">offset_ptr</a>.  <a href="#a76f95f40c6b858137740e5f8fb36170b">More...</a><br /></td></tr>
<tr class="separator:a76f95f40c6b858137740e5f8fb36170b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026d3af804429d3bb087db5170194ddf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a026d3af804429d3bb087db5170194ddf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a026d3af804429d3bb087db5170194ddf">hash_value</a> (const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:a026d3af804429d3bb087db5170194ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html" title="An offset pointer based on boost::offset_ptr. ">offset_ptr</a>.  <a href="#a026d3af804429d3bb087db5170194ddf">More...</a><br /></td></tr>
<tr class="separator:a026d3af804429d3bb087db5170194ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb838cba647dd556b5981b76ed464c90"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:abb838cba647dd556b5981b76ed464c90"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">move_range</a>&lt; Iterator, Sentinel &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#abb838cba647dd556b5981b76ed464c90">make_move_range</a> (Iterator iterator, Sentinel sentinel)</td></tr>
<tr class="memdesc:abb838cba647dd556b5981b76ed464c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a movable range from a given <code>iterator</code> <code>sentinal</code> pair.  <a href="#abb838cba647dd556b5981b76ed464c90">More...</a><br /></td></tr>
<tr class="separator:abb838cba647dd556b5981b76ed464c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdf325132341e974eb8423c9cfa78c8"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a1bdf325132341e974eb8423c9cfa78c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1bdf325132341e974eb8423c9cfa78c8">make_move_range</a> (Range &amp;&amp;r) -&gt; decltype(::bit::core::make_move_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a1bdf325132341e974eb8423c9cfa78c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a reverse range from a given <code>iterator</code> <code>sentinal</code> pair.  <a href="#a1bdf325132341e974eb8423c9cfa78c8">More...</a><br /></td></tr>
<tr class="separator:a1bdf325132341e974eb8423c9cfa78c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f59dd8230c8127468ac26d70025a00"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a63f59dd8230c8127468ac26d70025a00"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; I, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a63f59dd8230c8127468ac26d70025a00">make_range</a> (I iterator, S sentinel)</td></tr>
<tr class="memdesc:a63f59dd8230c8127468ac26d70025a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair.  <a href="#a63f59dd8230c8127468ac26d70025a00">More...</a><br /></td></tr>
<tr class="separator:a63f59dd8230c8127468ac26d70025a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b9ec1eedbb80a15cb163f203d7a9d4"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ab4b9ec1eedbb80a15cb163f203d7a9d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">detail::reverse_range_t</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab4b9ec1eedbb80a15cb163f203d7a9d4">make_reverse_range</a> (Range &amp;&amp;<a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>)</td></tr>
<tr class="memdesc:ab4b9ec1eedbb80a15cb163f203d7a9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a reverse range from a given range.  <a href="#ab4b9ec1eedbb80a15cb163f203d7a9d4">More...</a><br /></td></tr>
<tr class="separator:ab4b9ec1eedbb80a15cb163f203d7a9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb29edf2515986a0e1bb95a208ca3f3"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:affb29edf2515986a0e1bb95a208ca3f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">tuple_element_range</a>&lt; N, Iterator, Sentinel &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#affb29edf2515986a0e1bb95a208ca3f3">make_tuple_element_range</a> (Iterator iterator, Sentinel sentinel)</td></tr>
<tr class="memdesc:affb29edf2515986a0e1bb95a208ca3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating values of a given tuple.  <a href="#affb29edf2515986a0e1bb95a208ca3f3">More...</a><br /></td></tr>
<tr class="separator:affb29edf2515986a0e1bb95a208ca3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13c16d01325a532ecc115e0b2a2f331"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Range &gt; </td></tr>
<tr class="memitem:af13c16d01325a532ecc115e0b2a2f331"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af13c16d01325a532ecc115e0b2a2f331">make_tuple_element_range</a> (Range &amp;&amp;r) -&gt; decltype(::bit::core::make_tuple_element_range&lt; N &gt;(r.begin(), r.end()))</td></tr>
<tr class="memdesc:af13c16d01325a532ecc115e0b2a2f331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a tuple element range from a range.  <a href="#af13c16d01325a532ecc115e0b2a2f331">More...</a><br /></td></tr>
<tr class="separator:af13c16d01325a532ecc115e0b2a2f331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8ec3aaf89c882b592115d42bc67d70"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:a3d8ec3aaf89c882b592115d42bc67d70"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3d8ec3aaf89c882b592115d42bc67d70">make_key_range</a> (Iterator iterator, Sentinel sentinel) -&gt; <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Iterator &gt;, <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Sentinel &gt;&gt;</td></tr>
<tr class="memdesc:a3d8ec3aaf89c882b592115d42bc67d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the first value of a given tuple.  <a href="#a3d8ec3aaf89c882b592115d42bc67d70">More...</a><br /></td></tr>
<tr class="separator:a3d8ec3aaf89c882b592115d42bc67d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce611d88f46a64e4a2480807cdc47b8"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:afce611d88f46a64e4a2480807cdc47b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#afce611d88f46a64e4a2480807cdc47b8">make_key_range</a> (Range &amp;&amp;r) -&gt; decltype(::bit::core::make_key_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:afce611d88f46a64e4a2480807cdc47b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a key range from another range.  <a href="#afce611d88f46a64e4a2480807cdc47b8">More...</a><br /></td></tr>
<tr class="separator:afce611d88f46a64e4a2480807cdc47b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0772faac81cf87c326051a340d3ab5"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:a5b0772faac81cf87c326051a340d3ab5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a5b0772faac81cf87c326051a340d3ab5">make_value_range</a> (Iterator iterator, Sentinel sentinel) -&gt; <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Iterator &gt;, <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Sentinel &gt;&gt;</td></tr>
<tr class="memdesc:a5b0772faac81cf87c326051a340d3ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the second value of a given tuple.  <a href="#a5b0772faac81cf87c326051a340d3ab5">More...</a><br /></td></tr>
<tr class="separator:a5b0772faac81cf87c326051a340d3ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df7a2934a585ba992e7a67d400b3069"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a8df7a2934a585ba992e7a67d400b3069"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a8df7a2934a585ba992e7a67d400b3069">make_value_range</a> (Range &amp;&amp;r) -&gt; decltype(::bit::core::make_value_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a8df7a2934a585ba992e7a67d400b3069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a value range from another range.  <a href="#a8df7a2934a585ba992e7a67d400b3069">More...</a><br /></td></tr>
<tr class="separator:a8df7a2934a585ba992e7a67d400b3069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec81bb60c8ba82b284aa4ed201a5bc9"><td class="memTemplParams" colspan="2">template&lt;typename Range0 , typename... RangeN&gt; </td></tr>
<tr class="memitem:a9ec81bb60c8ba82b284aa4ed201a5bc9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9ec81bb60c8ba82b284aa4ed201a5bc9">make_zip_range</a> (Range0 &amp;&amp;r0, RangeN &amp;&amp;...rn) -&gt; <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; <a class="el" href="../../d6/d80/classbit_1_1core_1_1zip__iterator.html">zip_iterator</a>&lt; decltype(r0.begin()), decltype(rn.begin())... &gt;, <a class="el" href="../../d6/d80/classbit_1_1core_1_1zip__iterator.html">zip_iterator</a>&lt; decltype(r0.end()), decltype(rn.end())... &gt;&gt;</td></tr>
<tr class="memdesc:a9ec81bb60c8ba82b284aa4ed201a5bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a zip range from a selection of zip iterators.  <a href="#a9ec81bb60c8ba82b284aa4ed201a5bc9">More...</a><br /></td></tr>
<tr class="separator:a9ec81bb60c8ba82b284aa4ed201a5bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c3d39fb84af47f0b985434e2de1d84"><td class="memTemplParams" colspan="2"><a id="a67c3d39fb84af47f0b985434e2de1d84"></a>
template&lt;typename IntT , typename  = std::enable_if_t&lt;std::is_integral&lt;IntT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a67c3d39fb84af47f0b985434e2de1d84"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> lhs, IntT shift) noexcept</td></tr>
<tr class="separator:a67c3d39fb84af47f0b985434e2de1d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05382ea3b17ef399e33d5e4ad90d353e"><td class="memTemplParams" colspan="2"><a id="a05382ea3b17ef399e33d5e4ad90d353e"></a>
template&lt;typename IntT , typename  = std::enable_if_t&lt;std::is_integral&lt;IntT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a05382ea3b17ef399e33d5e4ad90d353e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> lhs, IntT shift) noexcept</td></tr>
<tr class="separator:a05382ea3b17ef399e33d5e4ad90d353e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7737cb35d449744a872eb7bfe74ed0ea"><td class="memItemLeft" align="right" valign="top"><a id="a7737cb35d449744a872eb7bfe74ed0ea"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> rhs) noexcept</td></tr>
<tr class="separator:a7737cb35d449744a872eb7bfe74ed0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f398965b4cc0e23ac64c4c0a7901bce"><td class="memItemLeft" align="right" valign="top"><a id="a6f398965b4cc0e23ac64c4c0a7901bce"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator &amp;</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> rhs) noexcept</td></tr>
<tr class="separator:a6f398965b4cc0e23ac64c4c0a7901bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6daad269df38f58cf71fbae9f8d20f8"><td class="memItemLeft" align="right" valign="top"><a id="ae6daad269df38f58cf71fbae9f8d20f8"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> rhs) noexcept</td></tr>
<tr class="separator:ae6daad269df38f58cf71fbae9f8d20f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75141258a189beb2a7acf811559612f"><td class="memItemLeft" align="right" valign="top"><a id="aa75141258a189beb2a7acf811559612f"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator~</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> lhs) noexcept</td></tr>
<tr class="separator:aa75141258a189beb2a7acf811559612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86513a658b7777fc0378aae6895c2552"><td class="memTemplParams" colspan="2"><a id="a86513a658b7777fc0378aae6895c2552"></a>
template&lt;typename IntT , typename  = std::enable_if_t&lt;std::is_integral&lt;IntT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a86513a658b7777fc0378aae6895c2552"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;lhs, IntT shift) noexcept</td></tr>
<tr class="separator:a86513a658b7777fc0378aae6895c2552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54ca90481efa1420f41ececf499958b"><td class="memTemplParams" colspan="2"><a id="ac54ca90481efa1420f41ececf499958b"></a>
template&lt;typename IntT , typename  = std::enable_if_t&lt;std::is_integral&lt;IntT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ac54ca90481efa1420f41ececf499958b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;lhs, IntT shift) noexcept</td></tr>
<tr class="separator:ac54ca90481efa1420f41ececf499958b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031f885e9a5cc95920a5c316635e8c62"><td class="memItemLeft" align="right" valign="top"><a id="a031f885e9a5cc95920a5c316635e8c62"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator|=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> rhs) noexcept</td></tr>
<tr class="separator:a031f885e9a5cc95920a5c316635e8c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a4666862e057552d32752d87523216"><td class="memItemLeft" align="right" valign="top"><a id="a12a4666862e057552d32752d87523216"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator^=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> rhs) noexcept</td></tr>
<tr class="separator:a12a4666862e057552d32752d87523216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd5b2476bc6f068a00d04f0ea63d1cc"><td class="memItemLeft" align="right" valign="top"><a id="a8bd5b2476bc6f068a00d04f0ea63d1cc"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator &amp;=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">byte</a> rhs) noexcept</td></tr>
<tr class="separator:a8bd5b2476bc6f068a00d04f0ea63d1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f7bba23e278cd7b5aa3b7337276c23"><td class="memTemplParams" colspan="2"><a id="a29f7bba23e278cd7b5aa3b7337276c23"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a29f7bba23e278cd7b5aa3b7337276c23"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a29f7bba23e278cd7b5aa3b7337276c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db7fdc5b80991a927524c2927ddffa0"><td class="memTemplParams" colspan="2"><a id="a1db7fdc5b80991a927524c2927ddffa0"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1db7fdc5b80991a927524c2927ddffa0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a1db7fdc5b80991a927524c2927ddffa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac909375d6a2d072226f805c36275d3"><td class="memTemplParams" colspan="2"><a id="a1ac909375d6a2d072226f805c36275d3"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1ac909375d6a2d072226f805c36275d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a1ac909375d6a2d072226f805c36275d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4e36380816277bd8cfa49c788d8fb2"><td class="memTemplParams" colspan="2"><a id="a6c4e36380816277bd8cfa49c788d8fb2"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a6c4e36380816277bd8cfa49c788d8fb2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a6c4e36380816277bd8cfa49c788d8fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12765078c4b92205ff8f49362f7e6a8e"><td class="memTemplParams" colspan="2"><a id="a12765078c4b92205ff8f49362f7e6a8e"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a12765078c4b92205ff8f49362f7e6a8e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a12765078c4b92205ff8f49362f7e6a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f253f4e8cbc3a6f99f6c7e4010dcc6"><td class="memTemplParams" colspan="2"><a id="a46f253f4e8cbc3a6f99f6c7e4010dcc6"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a46f253f4e8cbc3a6f99f6c7e4010dcc6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a46f253f4e8cbc3a6f99f6c7e4010dcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae39492e9d5baad61bef8464b9567c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a3ae39492e9d5baad61bef8464b9567c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3ae39492e9d5baad61bef8464b9567c9">hash_value</a> (const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T, U &gt; &amp;pair)</td></tr>
<tr class="memdesc:a3ae39492e9d5baad61bef8464b9567c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a std::pair.  <a href="#a3ae39492e9d5baad61bef8464b9567c9">More...</a><br /></td></tr>
<tr class="separator:a3ae39492e9d5baad61bef8464b9567c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae43c1e99b659be1a036f7a3cf54af68"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aae43c1e99b659be1a036f7a3cf54af68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aae43c1e99b659be1a036f7a3cf54af68">swap</a> (<a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aae43c1e99b659be1a036f7a3cf54af68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two compressed_pairs.  <a href="#aae43c1e99b659be1a036f7a3cf54af68">More...</a><br /></td></tr>
<tr class="separator:aae43c1e99b659be1a036f7a3cf54af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5392c28ec969231146b7924b5b816bd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa5392c28ec969231146b7924b5b816bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; std::decay_t&lt; T1 &gt;, std::decay_t&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa5392c28ec969231146b7924b5b816bd">make_compressed_pair</a> (T1 &amp;&amp;x, T2 &amp;&amp;y)</td></tr>
<tr class="memdesc:aa5392c28ec969231146b7924b5b816bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make utility to create a type-deduced compressed pair.  <a href="#aa5392c28ec969231146b7924b5b816bd">More...</a><br /></td></tr>
<tr class="separator:aa5392c28ec969231146b7924b5b816bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0532e88ecae2ebb120d2c7f51e0af9"><td class="memTemplParams" colspan="2"><a id="a9c0532e88ecae2ebb120d2c7f51e0af9"></a>
template&lt;std::size_t Idx, typename U1 , typename U2 &gt; </td></tr>
<tr class="memitem:a9c0532e88ecae2ebb120d2c7f51e0af9"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_t&lt; Idx, <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &amp;p) noexcept</td></tr>
<tr class="separator:a9c0532e88ecae2ebb120d2c7f51e0af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3b8a4aa6d3340c6d29e669e51bbc5d"><td class="memTemplParams" colspan="2"><a id="a0a3b8a4aa6d3340c6d29e669e51bbc5d"></a>
template&lt;std::size_t Idx, typename U1 , typename U2 &gt; </td></tr>
<tr class="memitem:a0a3b8a4aa6d3340c6d29e669e51bbc5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const tuple_element_t&lt; Idx, <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &amp;p) noexcept</td></tr>
<tr class="separator:a0a3b8a4aa6d3340c6d29e669e51bbc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6b7b8a336774d395576ba1e8f6f508"><td class="memTemplParams" colspan="2"><a id="aee6b7b8a336774d395576ba1e8f6f508"></a>
template&lt;std::size_t Idx, typename U1 , typename U2 &gt; </td></tr>
<tr class="memitem:aee6b7b8a336774d395576ba1e8f6f508"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_t&lt; Idx, <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &amp;&amp;p) noexcept</td></tr>
<tr class="separator:aee6b7b8a336774d395576ba1e8f6f508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f7553538b1bee2b7d47f829695ce68"><td class="memTemplParams" colspan="2"><a id="ab8f7553538b1bee2b7d47f829695ce68"></a>
template&lt;std::size_t Idx, typename U1 , typename U2 &gt; </td></tr>
<tr class="memitem:ab8f7553538b1bee2b7d47f829695ce68"><td class="memTemplItemLeft" align="right" valign="top">constexpr const tuple_element_t&lt; Idx, <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &amp;&amp;p) noexcept</td></tr>
<tr class="separator:ab8f7553538b1bee2b7d47f829695ce68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d616c3d0b4ac17409787c047d46c75"><td class="memTemplParams" colspan="2"><a id="a96d616c3d0b4ac17409787c047d46c75"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a96d616c3d0b4ac17409787c047d46c75"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a96d616c3d0b4ac17409787c047d46c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a27a6cc40bb1b9554350ccb74f29ae7"><td class="memTemplParams" colspan="2"><a id="a0a27a6cc40bb1b9554350ccb74f29ae7"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a0a27a6cc40bb1b9554350ccb74f29ae7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0a27a6cc40bb1b9554350ccb74f29ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32edd5a1163095747dce86b492dd69eb"><td class="memTemplParams" colspan="2"><a id="a32edd5a1163095747dce86b492dd69eb"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a32edd5a1163095747dce86b492dd69eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a32edd5a1163095747dce86b492dd69eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e919716f13adc121cde1a68faa3b36"><td class="memTemplParams" colspan="2"><a id="ad6e919716f13adc121cde1a68faa3b36"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ad6e919716f13adc121cde1a68faa3b36"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad6e919716f13adc121cde1a68faa3b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f199bd37c1f8080585a9fadc490c6c8"><td class="memTemplParams" colspan="2"><a id="a8f199bd37c1f8080585a9fadc490c6c8"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a8f199bd37c1f8080585a9fadc490c6c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8f199bd37c1f8080585a9fadc490c6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a1a84c68314272e5622f31aa463d91"><td class="memTemplParams" colspan="2"><a id="a94a1a84c68314272e5622f31aa463d91"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a94a1a84c68314272e5622f31aa463d91"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a94a1a84c68314272e5622f31aa463d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0535af8cfaddfcc7402117aca335472e"><td class="memTemplParams" colspan="2"><a id="a0535af8cfaddfcc7402117aca335472e"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a0535af8cfaddfcc7402117aca335472e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs)</td></tr>
<tr class="separator:a0535af8cfaddfcc7402117aca335472e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6602fbb59cf4f08bd0a0120bb7c38d"><td class="memTemplParams" colspan="2"><a id="adf6602fbb59cf4f08bd0a0120bb7c38d"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adf6602fbb59cf4f08bd0a0120bb7c38d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; std::decay_t&lt; Args &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_compressed_tuple</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:adf6602fbb59cf4f08bd0a0120bb7c38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a3a5faeba8782d2c8e383cb58876a8"><td class="memTemplParams" colspan="2"><a id="aa7a3a5faeba8782d2c8e383cb58876a8"></a>
template&lt;std::size_t I, typename... UTypes&gt; </td></tr>
<tr class="memitem:aa7a3a5faeba8782d2c8e383cb58876a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_t&lt; I, <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &amp;tuple) noexcept</td></tr>
<tr class="separator:aa7a3a5faeba8782d2c8e383cb58876a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88add5ceb7575810d502a9ca6f4941f8"><td class="memTemplParams" colspan="2"><a id="a88add5ceb7575810d502a9ca6f4941f8"></a>
template&lt;std::size_t I, typename... UTypes&gt; </td></tr>
<tr class="memitem:a88add5ceb7575810d502a9ca6f4941f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_t&lt; I, <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &amp;&amp;tuple) noexcept</td></tr>
<tr class="separator:a88add5ceb7575810d502a9ca6f4941f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2395034facb14694cd01760dad3634d"><td class="memTemplParams" colspan="2"><a id="ab2395034facb14694cd01760dad3634d"></a>
template&lt;std::size_t I, typename... UTypes&gt; </td></tr>
<tr class="memitem:ab2395034facb14694cd01760dad3634d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const tuple_element_t&lt; I, <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &amp;tuple) noexcept</td></tr>
<tr class="separator:ab2395034facb14694cd01760dad3634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03692e80b1c42f4c8f53aa7e5505cca1"><td class="memTemplParams" colspan="2"><a id="a03692e80b1c42f4c8f53aa7e5505cca1"></a>
template&lt;std::size_t I, typename... UTypes&gt; </td></tr>
<tr class="memitem:a03692e80b1c42f4c8f53aa7e5505cca1"><td class="memTemplItemLeft" align="right" valign="top">constexpr const tuple_element_t&lt; I, <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../df/da4/classbit_1_1core_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &amp;&amp;tuple) noexcept</td></tr>
<tr class="separator:a03692e80b1c42f4c8f53aa7e5505cca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35fa1305981737caa85398a336a3254"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae35fa1305981737caa85398a336a3254"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae35fa1305981737caa85398a336a3254">at</a> (T(&amp;array)[N], std::size_t n)</td></tr>
<tr class="memdesc:ae35fa1305981737caa85398a336a3254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the element at <code>n</code> with bounds-checking.  <a href="#ae35fa1305981737caa85398a336a3254">More...</a><br /></td></tr>
<tr class="separator:ae35fa1305981737caa85398a336a3254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917a5c61b0f62afa9ad874020a8cc10f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a917a5c61b0f62afa9ad874020a8cc10f"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a917a5c61b0f62afa9ad874020a8cc10f">at</a> (std::initializer_list&lt; T &gt; il, std::size_t n)</td></tr>
<tr class="memdesc:a917a5c61b0f62afa9ad874020a8cc10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the element at <code>n</code> with bounds-checking.  <a href="#a917a5c61b0f62afa9ad874020a8cc10f">More...</a><br /></td></tr>
<tr class="separator:a917a5c61b0f62afa9ad874020a8cc10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c6402efda390b93c9704f3537a3b76"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a66c6402efda390b93c9704f3537a3b76"><td class="memTemplItemLeft" align="right" valign="top">constexpr T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a66c6402efda390b93c9704f3537a3b76">data</a> (T(&amp;array)[N]) noexcept</td></tr>
<tr class="memdesc:a66c6402efda390b93c9704f3537a3b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to contiguous data from a specified <code>array</code>.  <a href="#a66c6402efda390b93c9704f3537a3b76">More...</a><br /></td></tr>
<tr class="separator:a66c6402efda390b93c9704f3537a3b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea7826b865e212b9ef982b564106fd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adea7826b865e212b9ef982b564106fd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#adea7826b865e212b9ef982b564106fd8">data</a> (std::initializer_list&lt; T &gt; il) noexcept</td></tr>
<tr class="memdesc:adea7826b865e212b9ef982b564106fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to contiguous data from a specified initializer list.  <a href="#adea7826b865e212b9ef982b564106fd8">More...</a><br /></td></tr>
<tr class="separator:adea7826b865e212b9ef982b564106fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cbfa02664b96a6f457ec32a39b702b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a12cbfa02664b96a6f457ec32a39b702b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a12cbfa02664b96a6f457ec32a39b702b">front</a> (T(&amp;array)[N]) noexcept</td></tr>
<tr class="memdesc:a12cbfa02664b96a6f457ec32a39b702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the first entry in the given <code>array</code>.  <a href="#a12cbfa02664b96a6f457ec32a39b702b">More...</a><br /></td></tr>
<tr class="separator:a12cbfa02664b96a6f457ec32a39b702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b598d5ce425d87697a13a541c0f3bb4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b598d5ce425d87697a13a541c0f3bb4"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0b598d5ce425d87697a13a541c0f3bb4">front</a> (std::initializer_list&lt; T &gt; il) noexcept</td></tr>
<tr class="memdesc:a0b598d5ce425d87697a13a541c0f3bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the first entry in the given initializer list.  <a href="#a0b598d5ce425d87697a13a541c0f3bb4">More...</a><br /></td></tr>
<tr class="separator:a0b598d5ce425d87697a13a541c0f3bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971cc81c70825b79d1b4cec2966a9e07"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a971cc81c70825b79d1b4cec2966a9e07"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a971cc81c70825b79d1b4cec2966a9e07">back</a> (T(&amp;array)[N]) noexcept</td></tr>
<tr class="memdesc:a971cc81c70825b79d1b4cec2966a9e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the last entry in the given <code>array</code>.  <a href="#a971cc81c70825b79d1b4cec2966a9e07">More...</a><br /></td></tr>
<tr class="separator:a971cc81c70825b79d1b4cec2966a9e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87532ba958f1074256ab21b9e11e121"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac87532ba958f1074256ab21b9e11e121"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac87532ba958f1074256ab21b9e11e121">back</a> (std::initializer_list&lt; T &gt; il) noexcept</td></tr>
<tr class="memdesc:ac87532ba958f1074256ab21b9e11e121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the last entry in the given initializer list.  <a href="#ac87532ba958f1074256ab21b9e11e121">More...</a><br /></td></tr>
<tr class="separator:ac87532ba958f1074256ab21b9e11e121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0e87256c02b6559307fb02f3f0ffb4"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aac0e87256c02b6559307fb02f3f0ffb4"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aac0e87256c02b6559307fb02f3f0ffb4">size</a> (T(&amp;array)[N]) noexcept</td></tr>
<tr class="memdesc:aac0e87256c02b6559307fb02f3f0ffb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the size of a given array.  <a href="#aac0e87256c02b6559307fb02f3f0ffb4">More...</a><br /></td></tr>
<tr class="separator:aac0e87256c02b6559307fb02f3f0ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a87a19f03eca7f4143c5f9045c7761"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:af1a87a19f03eca7f4143c5f9045c7761"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af1a87a19f03eca7f4143c5f9045c7761">size</a> (const C &amp;c) noexcept -&gt; decltype(c.size())</td></tr>
<tr class="memdesc:af1a87a19f03eca7f4143c5f9045c7761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the size of the specified container by delegating to the container's implementation.  <a href="#af1a87a19f03eca7f4143c5f9045c7761">More...</a><br /></td></tr>
<tr class="separator:af1a87a19f03eca7f4143c5f9045c7761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac384c942143284e55516f4c6cba7db81"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ac384c942143284e55516f4c6cba7db81"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac384c942143284e55516f4c6cba7db81">empty</a> (T(&amp;array)[N]) noexcept</td></tr>
<tr class="memdesc:ac384c942143284e55516f4c6cba7db81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the array is empty.  <a href="#ac384c942143284e55516f4c6cba7db81">More...</a><br /></td></tr>
<tr class="separator:ac384c942143284e55516f4c6cba7db81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cef9f854953065d5aba21b92a6931d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62cef9f854953065d5aba21b92a6931d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a62cef9f854953065d5aba21b92a6931d">empty</a> (std::initializer_list&lt; T &gt; il) noexcept</td></tr>
<tr class="memdesc:a62cef9f854953065d5aba21b92a6931d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the initializer list is empty.  <a href="#a62cef9f854953065d5aba21b92a6931d">More...</a><br /></td></tr>
<tr class="separator:a62cef9f854953065d5aba21b92a6931d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cc6271a63c342d4833d30d6d80e4d8"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a33cc6271a63c342d4833d30d6d80e4d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a33cc6271a63c342d4833d30d6d80e4d8">empty</a> (const C &amp;c) noexcept -&gt; decltype(c.empty())</td></tr>
<tr class="memdesc:a33cc6271a63c342d4833d30d6d80e4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the container is empty by delegating to the container's implementation.  <a href="#a33cc6271a63c342d4833d30d6d80e4d8">More...</a><br /></td></tr>
<tr class="separator:a33cc6271a63c342d4833d30d6d80e4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73d215df78fc529b3b3427c92d9f96c"><td class="memTemplParams" colspan="2"><a id="aa73d215df78fc529b3b3427c92d9f96c"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:aa73d215df78fc529b3b3427c92d9f96c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa73d215df78fc529b3b3427c92d9f96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2431e91a9a4372aae27998758d3d410d"><td class="memTemplParams" colspan="2"><a id="a2431e91a9a4372aae27998758d3d410d"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a2431e91a9a4372aae27998758d3d410d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a2431e91a9a4372aae27998758d3d410d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd282eee3d757bb10c45fc0616724677"><td class="memTemplParams" colspan="2"><a id="afd282eee3d757bb10c45fc0616724677"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:afd282eee3d757bb10c45fc0616724677"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:afd282eee3d757bb10c45fc0616724677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2102f2463d41074320599a2b61adb409"><td class="memTemplParams" colspan="2"><a id="a2102f2463d41074320599a2b61adb409"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a2102f2463d41074320599a2b61adb409"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a2102f2463d41074320599a2b61adb409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab471d6af6e61d93275ef9c8aff5dad88"><td class="memTemplParams" colspan="2"><a id="ab471d6af6e61d93275ef9c8aff5dad88"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:ab471d6af6e61d93275ef9c8aff5dad88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab471d6af6e61d93275ef9c8aff5dad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a13af5a61dffa3f1dd5041a4aacd98"><td class="memTemplParams" colspan="2"><a id="a33a13af5a61dffa3f1dd5041a4aacd98"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a33a13af5a61dffa3f1dd5041a4aacd98"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a33a13af5a61dffa3f1dd5041a4aacd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40f38581a85fe780c1e9b0791aa9420"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:ad40f38581a85fe780c1e9b0791aa9420"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad40f38581a85fe780c1e9b0791aa9420">hash_value</a> (const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;fn) noexcept</td></tr>
<tr class="memdesc:ad40f38581a85fe780c1e9b0791aa9420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the delegate <code>fn</code>.  <a href="#ad40f38581a85fe780c1e9b0791aa9420">More...</a><br /></td></tr>
<tr class="separator:ad40f38581a85fe780c1e9b0791aa9420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950ae8cea71fd2227bd7b2630d98b377"><td class="memTemplParams" colspan="2">template&lt;typename E , typename... Args&gt; </td></tr>
<tr class="memitem:a950ae8cea71fd2227bd7b2630d98b377"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a950ae8cea71fd2227bd7b2630d98b377">make_unexpected</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a950ae8cea71fd2227bd7b2630d98b377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an unexpected type <code>E</code>.  <a href="#a950ae8cea71fd2227bd7b2630d98b377">More...</a><br /></td></tr>
<tr class="separator:a950ae8cea71fd2227bd7b2630d98b377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2053e2d18795568583cafb9ef66d47"><td class="memTemplParams" colspan="2"><a id="aac2053e2d18795568583cafb9ef66d47"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:aac2053e2d18795568583cafb9ef66d47"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:aac2053e2d18795568583cafb9ef66d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dba19a1a4a6d42bfab90815d067a63e"><td class="memTemplParams" colspan="2"><a id="a4dba19a1a4a6d42bfab90815d067a63e"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a4dba19a1a4a6d42bfab90815d067a63e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a4dba19a1a4a6d42bfab90815d067a63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1357238cdf3f9a6293d76df579962a"><td class="memTemplParams" colspan="2"><a id="a2f1357238cdf3f9a6293d76df579962a"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a2f1357238cdf3f9a6293d76df579962a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a2f1357238cdf3f9a6293d76df579962a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33518d7381a2fd488f24e5d81ac0d07"><td class="memTemplParams" colspan="2"><a id="ac33518d7381a2fd488f24e5d81ac0d07"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:ac33518d7381a2fd488f24e5d81ac0d07"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:ac33518d7381a2fd488f24e5d81ac0d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad499b4223109a592f157b2b6ce025302"><td class="memTemplParams" colspan="2"><a id="ad499b4223109a592f157b2b6ce025302"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:ad499b4223109a592f157b2b6ce025302"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:ad499b4223109a592f157b2b6ce025302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff2cea4f713e52d5ce67751052cb68d"><td class="memTemplParams" colspan="2"><a id="a5ff2cea4f713e52d5ce67751052cb68d"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a5ff2cea4f713e52d5ce67751052cb68d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a5ff2cea4f713e52d5ce67751052cb68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35493823936982cc5b8331b543e41f85"><td class="memTemplParams" colspan="2"><a id="a35493823936982cc5b8331b543e41f85"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a35493823936982cc5b8331b543e41f85"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;rhs)</td></tr>
<tr class="separator:a35493823936982cc5b8331b543e41f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1c380a4f19873c1889d81f407c784e"><td class="memTemplParams" colspan="2"><a id="a9a1c380a4f19873c1889d81f407c784e"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a9a1c380a4f19873c1889d81f407c784e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;rhs)</td></tr>
<tr class="separator:a9a1c380a4f19873c1889d81f407c784e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c72705247e951a9203e0a05ecb6afd"><td class="memTemplParams" colspan="2"><a id="a49c72705247e951a9203e0a05ecb6afd"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a49c72705247e951a9203e0a05ecb6afd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;rhs)</td></tr>
<tr class="separator:a49c72705247e951a9203e0a05ecb6afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a03b4addfb8e39a6097b6885fd1746"><td class="memTemplParams" colspan="2"><a id="a20a03b4addfb8e39a6097b6885fd1746"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a20a03b4addfb8e39a6097b6885fd1746"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;rhs)</td></tr>
<tr class="separator:a20a03b4addfb8e39a6097b6885fd1746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7e9ec225f8d5f351ea14468fc8f4cf"><td class="memTemplParams" colspan="2"><a id="a1f7e9ec225f8d5f351ea14468fc8f4cf"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a1f7e9ec225f8d5f351ea14468fc8f4cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;rhs)</td></tr>
<tr class="separator:a1f7e9ec225f8d5f351ea14468fc8f4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584e1f1d54c73b5bffd66557cbfbe1a8"><td class="memTemplParams" colspan="2"><a id="a584e1f1d54c73b5bffd66557cbfbe1a8"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a584e1f1d54c73b5bffd66557cbfbe1a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;rhs)</td></tr>
<tr class="separator:a584e1f1d54c73b5bffd66557cbfbe1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2238a91b6d30169e5a2795a145f4ec"><td class="memTemplParams" colspan="2"><a id="aef2238a91b6d30169e5a2795a145f4ec"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:aef2238a91b6d30169e5a2795a145f4ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const T &amp;v)</td></tr>
<tr class="separator:aef2238a91b6d30169e5a2795a145f4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17472070da6ab76c6df2e5f05c4d38dd"><td class="memTemplParams" colspan="2"><a id="a17472070da6ab76c6df2e5f05c4d38dd"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a17472070da6ab76c6df2e5f05c4d38dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;v, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:a17472070da6ab76c6df2e5f05c4d38dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3b0f2a8f90309fd2452273719f9a1e"><td class="memTemplParams" colspan="2"><a id="a3a3b0f2a8f90309fd2452273719f9a1e"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a3a3b0f2a8f90309fd2452273719f9a1e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const T &amp;v)</td></tr>
<tr class="separator:a3a3b0f2a8f90309fd2452273719f9a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4296e32123551ce828b8be9ffc9d1cd7"><td class="memTemplParams" colspan="2"><a id="a4296e32123551ce828b8be9ffc9d1cd7"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a4296e32123551ce828b8be9ffc9d1cd7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;v, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:a4296e32123551ce828b8be9ffc9d1cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed6a3f7b25b90abf56ac4bcb0fc4301"><td class="memTemplParams" colspan="2"><a id="a9ed6a3f7b25b90abf56ac4bcb0fc4301"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a9ed6a3f7b25b90abf56ac4bcb0fc4301"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const T &amp;v)</td></tr>
<tr class="separator:a9ed6a3f7b25b90abf56ac4bcb0fc4301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81610140603de965341e115828576c3a"><td class="memTemplParams" colspan="2"><a id="a81610140603de965341e115828576c3a"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a81610140603de965341e115828576c3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T &amp;v, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:a81610140603de965341e115828576c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae89995c23e2433988020e37c9c55e6f"><td class="memTemplParams" colspan="2"><a id="aae89995c23e2433988020e37c9c55e6f"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:aae89995c23e2433988020e37c9c55e6f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const T &amp;v)</td></tr>
<tr class="separator:aae89995c23e2433988020e37c9c55e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac871b121378b15159c5fab8d1e21bf01"><td class="memTemplParams" colspan="2"><a id="ac871b121378b15159c5fab8d1e21bf01"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:ac871b121378b15159c5fab8d1e21bf01"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;v, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:ac871b121378b15159c5fab8d1e21bf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa416f3cf2fc8605730c3ebddf6949aff"><td class="memTemplParams" colspan="2"><a id="aa416f3cf2fc8605730c3ebddf6949aff"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:aa416f3cf2fc8605730c3ebddf6949aff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const T &amp;v)</td></tr>
<tr class="separator:aa416f3cf2fc8605730c3ebddf6949aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01362aafd5ee30685aadb32d5091be6a"><td class="memTemplParams" colspan="2"><a id="a01362aafd5ee30685aadb32d5091be6a"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a01362aafd5ee30685aadb32d5091be6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;v, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:a01362aafd5ee30685aadb32d5091be6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca452c438ad24a2db9d1d1a729dfd2d6"><td class="memTemplParams" colspan="2"><a id="aca452c438ad24a2db9d1d1a729dfd2d6"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:aca452c438ad24a2db9d1d1a729dfd2d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const T &amp;v)</td></tr>
<tr class="separator:aca452c438ad24a2db9d1d1a729dfd2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa590e55f7f2a3ea2c34bc0394b95fa6c"><td class="memTemplParams" colspan="2"><a id="aa590e55f7f2a3ea2c34bc0394b95fa6c"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:aa590e55f7f2a3ea2c34bc0394b95fa6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;v, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:aa590e55f7f2a3ea2c34bc0394b95fa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae4431f3adf2145069c62ca10de29ef"><td class="memTemplParams" colspan="2"><a id="a3ae4431f3adf2145069c62ca10de29ef"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a3ae4431f3adf2145069c62ca10de29ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:a3ae4431f3adf2145069c62ca10de29ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b9b1147e6a357d72eb97901943e035"><td class="memTemplParams" colspan="2"><a id="ac6b9b1147e6a357d72eb97901943e035"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:ac6b9b1147e6a357d72eb97901943e035"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:ac6b9b1147e6a357d72eb97901943e035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42e5ff771da21fdfb1c0ac4118b8ad8"><td class="memTemplParams" colspan="2"><a id="ab42e5ff771da21fdfb1c0ac4118b8ad8"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:ab42e5ff771da21fdfb1c0ac4118b8ad8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:ab42e5ff771da21fdfb1c0ac4118b8ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc45d179e62e1f3b5c722031226b41a"><td class="memTemplParams" colspan="2"><a id="affc45d179e62e1f3b5c722031226b41a"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:affc45d179e62e1f3b5c722031226b41a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:affc45d179e62e1f3b5c722031226b41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4c52df8034963f2d64ab2a85fe1156"><td class="memTemplParams" colspan="2"><a id="ada4c52df8034963f2d64ab2a85fe1156"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:ada4c52df8034963f2d64ab2a85fe1156"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:ada4c52df8034963f2d64ab2a85fe1156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951b87216ef02f699e323048bd7ad873"><td class="memTemplParams" colspan="2"><a id="a951b87216ef02f699e323048bd7ad873"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a951b87216ef02f699e323048bd7ad873"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:a951b87216ef02f699e323048bd7ad873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d2fe36ee0725bf8528e73825dabe27"><td class="memTemplParams" colspan="2"><a id="a29d2fe36ee0725bf8528e73825dabe27"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a29d2fe36ee0725bf8528e73825dabe27"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:a29d2fe36ee0725bf8528e73825dabe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12144f2c34bd34aede34eb166928a43"><td class="memTemplParams" colspan="2"><a id="ac12144f2c34bd34aede34eb166928a43"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:ac12144f2c34bd34aede34eb166928a43"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:ac12144f2c34bd34aede34eb166928a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb35b5a8d46461080e72d2c6959c149e"><td class="memTemplParams" colspan="2"><a id="adb35b5a8d46461080e72d2c6959c149e"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:adb35b5a8d46461080e72d2c6959c149e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:adb35b5a8d46461080e72d2c6959c149e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48f66ebd7b1eca86dae1259f46eb370"><td class="memTemplParams" colspan="2"><a id="ae48f66ebd7b1eca86dae1259f46eb370"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:ae48f66ebd7b1eca86dae1259f46eb370"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:ae48f66ebd7b1eca86dae1259f46eb370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287f5c16693099217694aa57d6e494fc"><td class="memTemplParams" colspan="2"><a id="a287f5c16693099217694aa57d6e494fc"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a287f5c16693099217694aa57d6e494fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x, const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:a287f5c16693099217694aa57d6e494fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eabd0c65e8bca673827bdfe2848b648"><td class="memTemplParams" colspan="2"><a id="a6eabd0c65e8bca673827bdfe2848b648"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a6eabd0c65e8bca673827bdfe2848b648"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;e, const <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;x)</td></tr>
<tr class="separator:a6eabd0c65e8bca673827bdfe2848b648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc57cca5bbac742e58a3f3585474915"><td class="memTemplParams" colspan="2"><a id="a6bc57cca5bbac742e58a3f3585474915"></a>
template&lt;typename T , typename E &gt; </td></tr>
<tr class="memitem:a6bc57cca5bbac742e58a3f3585474915"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;lhs, <a class="el" href="../../d6/d06/classbit_1_1core_1_1expected.html">expected</a>&lt; T, E &gt; &amp;rhs)</td></tr>
<tr class="separator:a6bc57cca5bbac742e58a3f3585474915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c4dd718a34972243c60b4db59b76c9"><td class="memItemLeft" align="right" valign="top"><a id="a09c4dd718a34972243c60b4db59b76c9"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:a09c4dd718a34972243c60b4db59b76c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688d717c7a18e5af747f7cdd85309685"><td class="memItemLeft" align="right" valign="top"><a id="a688d717c7a18e5af747f7cdd85309685"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:a688d717c7a18e5af747f7cdd85309685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dd1b32e2f6f633359eff847dfb5927"><td class="memItemLeft" align="right" valign="top"><a id="ae5dd1b32e2f6f633359eff847dfb5927"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:ae5dd1b32e2f6f633359eff847dfb5927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a7af406fbbd6b2474e64bd6301765c"><td class="memItemLeft" align="right" valign="top"><a id="a14a7af406fbbd6b2474e64bd6301765c"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:a14a7af406fbbd6b2474e64bd6301765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594216e1ff59a23f81e46ce8d02dc98c"><td class="memItemLeft" align="right" valign="top"><a id="a594216e1ff59a23f81e46ce8d02dc98c"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator%=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:a594216e1ff59a23f81e46ce8d02dc98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf67428e138072b1fe6018c01d832e7f"><td class="memItemLeft" align="right" valign="top"><a id="adf67428e138072b1fe6018c01d832e7f"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator &amp;=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:adf67428e138072b1fe6018c01d832e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f958f01edd497b42fcd08bb2e521474"><td class="memItemLeft" align="right" valign="top"><a id="a8f958f01edd497b42fcd08bb2e521474"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator|=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:a8f958f01edd497b42fcd08bb2e521474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16af8b0e94549560c0c3de17921150bf"><td class="memItemLeft" align="right" valign="top"><a id="a16af8b0e94549560c0c3de17921150bf"></a>
<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator^=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:a16af8b0e94549560c0c3de17921150bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78ed27b83a2d241dfe88271946d4f97"><td class="memTemplParams" colspan="2"><a id="ac78ed27b83a2d241dfe88271946d4f97"></a>
template&lt;typename IntT , typename  = std::enable_if_t&lt;std::is_integral&lt;IntT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ac78ed27b83a2d241dfe88271946d4f97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, IntT rhs) noexcept</td></tr>
<tr class="separator:ac78ed27b83a2d241dfe88271946d4f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1582553df118971d98fa70416038ad8d"><td class="memTemplParams" colspan="2"><a id="a1582553df118971d98fa70416038ad8d"></a>
template&lt;typename IntT , typename  = std::enable_if_t&lt;std::is_integral&lt;IntT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a1582553df118971d98fa70416038ad8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> &amp;lhs, IntT rhs) noexcept</td></tr>
<tr class="separator:a1582553df118971d98fa70416038ad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab379a50e2b0b391be5b9184f787df870"><td class="memItemLeft" align="right" valign="top"><a id="ab379a50e2b0b391be5b9184f787df870"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:ab379a50e2b0b391be5b9184f787df870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9406bf14f4f37547fa5b5b673b870cc"><td class="memItemLeft" align="right" valign="top"><a id="aa9406bf14f4f37547fa5b5b673b870cc"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:aa9406bf14f4f37547fa5b5b673b870cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b890a915f058b7503c63dc9aa091cb"><td class="memItemLeft" align="right" valign="top"><a id="ac2b890a915f058b7503c63dc9aa091cb"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:ac2b890a915f058b7503c63dc9aa091cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e24fe38c8df676612a865b022a7586"><td class="memItemLeft" align="right" valign="top"><a id="a52e24fe38c8df676612a865b022a7586"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:a52e24fe38c8df676612a865b022a7586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af283b8d593a5b98d1e7c1fae5d58e020"><td class="memItemLeft" align="right" valign="top"><a id="af283b8d593a5b98d1e7c1fae5d58e020"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator%</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:af283b8d593a5b98d1e7c1fae5d58e020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eeefa24b01f084158c35eb350128d04"><td class="memItemLeft" align="right" valign="top"><a id="a8eeefa24b01f084158c35eb350128d04"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator &amp;</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:a8eeefa24b01f084158c35eb350128d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc69c5bd154fcdce651f24f289eb640d"><td class="memItemLeft" align="right" valign="top"><a id="afc69c5bd154fcdce651f24f289eb640d"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:afc69c5bd154fcdce651f24f289eb640d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26a1ae381146d313506aa360a5adb04"><td class="memItemLeft" align="right" valign="top"><a id="ad26a1ae381146d313506aa360a5adb04"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> rhs) noexcept</td></tr>
<tr class="separator:ad26a1ae381146d313506aa360a5adb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ba307fa0365242c49dbf8942a9706e"><td class="memTemplParams" colspan="2"><a id="a85ba307fa0365242c49dbf8942a9706e"></a>
template&lt;typename IntT , typename  = std::enable_if_t&lt;std::is_integral&lt;IntT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a85ba307fa0365242c49dbf8942a9706e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, IntT rhs) noexcept</td></tr>
<tr class="separator:a85ba307fa0365242c49dbf8942a9706e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248bb52a536b61c110fabc4506e537f8"><td class="memTemplParams" colspan="2"><a id="a248bb52a536b61c110fabc4506e537f8"></a>
template&lt;typename IntT , typename  = std::enable_if_t&lt;std::is_integral&lt;IntT&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a248bb52a536b61c110fabc4506e537f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> lhs, IntT rhs) noexcept</td></tr>
<tr class="separator:a248bb52a536b61c110fabc4506e537f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3646e85a78b3b10ea26053dfd8b29c00"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3646e85a78b3b10ea26053dfd8b29c00">hash_value</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a3646e85a78b3b10ea26053dfd8b29c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of a null pointer.  <a href="#a3646e85a78b3b10ea26053dfd8b29c00">More...</a><br /></td></tr>
<tr class="separator:a3646e85a78b3b10ea26053dfd8b29c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c00861c3509e4c2074a0829bfe8efa3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a6c00861c3509e4c2074a0829bfe8efa3">hash_value</a> (bool val) noexcept</td></tr>
<tr class="memdesc:a6c00861c3509e4c2074a0829bfe8efa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given bool.  <a href="#a6c00861c3509e4c2074a0829bfe8efa3">More...</a><br /></td></tr>
<tr class="separator:a6c00861c3509e4c2074a0829bfe8efa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1df6f04ec5f0ac82788acc30913bd2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aab1df6f04ec5f0ac82788acc30913bd2">hash_value</a> (char val) noexcept</td></tr>
<tr class="memdesc:aab1df6f04ec5f0ac82788acc30913bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given char.  <a href="#aab1df6f04ec5f0ac82788acc30913bd2">More...</a><br /></td></tr>
<tr class="separator:aab1df6f04ec5f0ac82788acc30913bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916f409a35fdbe28162d0d98aff785c8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a916f409a35fdbe28162d0d98aff785c8">hash_value</a> (signed char val) noexcept</td></tr>
<tr class="memdesc:a916f409a35fdbe28162d0d98aff785c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given signed char.  <a href="#a916f409a35fdbe28162d0d98aff785c8">More...</a><br /></td></tr>
<tr class="separator:a916f409a35fdbe28162d0d98aff785c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31afbb6d269fe1478d86e104df076685"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a31afbb6d269fe1478d86e104df076685">hash_value</a> (unsigned char val) noexcept</td></tr>
<tr class="memdesc:a31afbb6d269fe1478d86e104df076685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned char.  <a href="#a31afbb6d269fe1478d86e104df076685">More...</a><br /></td></tr>
<tr class="separator:a31afbb6d269fe1478d86e104df076685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0926dbe5d9eff8b994789936aa40cd38"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0926dbe5d9eff8b994789936aa40cd38">hash_value</a> (wchar_t val) noexcept</td></tr>
<tr class="memdesc:a0926dbe5d9eff8b994789936aa40cd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given wchar_t.  <a href="#a0926dbe5d9eff8b994789936aa40cd38">More...</a><br /></td></tr>
<tr class="separator:a0926dbe5d9eff8b994789936aa40cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ae062c7eeea0afd09e1f1d608d1296"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a79ae062c7eeea0afd09e1f1d608d1296">hash_value</a> (char16_t val) noexcept</td></tr>
<tr class="memdesc:a79ae062c7eeea0afd09e1f1d608d1296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given char16_t.  <a href="#a79ae062c7eeea0afd09e1f1d608d1296">More...</a><br /></td></tr>
<tr class="separator:a79ae062c7eeea0afd09e1f1d608d1296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4b5975973389fb74387552e4f41780"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#abb4b5975973389fb74387552e4f41780">hash_value</a> (char32_t val) noexcept</td></tr>
<tr class="memdesc:abb4b5975973389fb74387552e4f41780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given char32_t.  <a href="#abb4b5975973389fb74387552e4f41780">More...</a><br /></td></tr>
<tr class="separator:abb4b5975973389fb74387552e4f41780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7581c377ce2e9e2d7506e13f023bdcd9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7581c377ce2e9e2d7506e13f023bdcd9">hash_value</a> (short val) noexcept</td></tr>
<tr class="memdesc:a7581c377ce2e9e2d7506e13f023bdcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given short.  <a href="#a7581c377ce2e9e2d7506e13f023bdcd9">More...</a><br /></td></tr>
<tr class="separator:a7581c377ce2e9e2d7506e13f023bdcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc0be67f97ee381cbab2f76a7fcaefc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#afbc0be67f97ee381cbab2f76a7fcaefc">hash_value</a> (unsigned short val) noexcept</td></tr>
<tr class="memdesc:afbc0be67f97ee381cbab2f76a7fcaefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned short.  <a href="#afbc0be67f97ee381cbab2f76a7fcaefc">More...</a><br /></td></tr>
<tr class="separator:afbc0be67f97ee381cbab2f76a7fcaefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27993124b4eddc0b1e39c2afef288b53"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a27993124b4eddc0b1e39c2afef288b53">hash_value</a> (int val) noexcept</td></tr>
<tr class="memdesc:a27993124b4eddc0b1e39c2afef288b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given int.  <a href="#a27993124b4eddc0b1e39c2afef288b53">More...</a><br /></td></tr>
<tr class="separator:a27993124b4eddc0b1e39c2afef288b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9eff787554f00284e1e0630751a53b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#adf9eff787554f00284e1e0630751a53b">hash_value</a> (unsigned int val) noexcept</td></tr>
<tr class="memdesc:adf9eff787554f00284e1e0630751a53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned int.  <a href="#adf9eff787554f00284e1e0630751a53b">More...</a><br /></td></tr>
<tr class="separator:adf9eff787554f00284e1e0630751a53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64430bb06e89a5ee445810541ad24570"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a64430bb06e89a5ee445810541ad24570">hash_value</a> (long val) noexcept</td></tr>
<tr class="memdesc:a64430bb06e89a5ee445810541ad24570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given long.  <a href="#a64430bb06e89a5ee445810541ad24570">More...</a><br /></td></tr>
<tr class="separator:a64430bb06e89a5ee445810541ad24570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67883a77ae7eb4e67373c35892405aef"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a67883a77ae7eb4e67373c35892405aef">hash_value</a> (unsigned long val) noexcept</td></tr>
<tr class="memdesc:a67883a77ae7eb4e67373c35892405aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned long.  <a href="#a67883a77ae7eb4e67373c35892405aef">More...</a><br /></td></tr>
<tr class="separator:a67883a77ae7eb4e67373c35892405aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab200faa1197be3dae43472662bea6e11"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab200faa1197be3dae43472662bea6e11">hash_value</a> (long long val) noexcept</td></tr>
<tr class="memdesc:ab200faa1197be3dae43472662bea6e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given long long.  <a href="#ab200faa1197be3dae43472662bea6e11">More...</a><br /></td></tr>
<tr class="separator:ab200faa1197be3dae43472662bea6e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0809bccdeae9b7c9eb5289ab847544"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0d0809bccdeae9b7c9eb5289ab847544">hash_value</a> (unsigned long long val) noexcept</td></tr>
<tr class="memdesc:a0d0809bccdeae9b7c9eb5289ab847544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned long long.  <a href="#a0d0809bccdeae9b7c9eb5289ab847544">More...</a><br /></td></tr>
<tr class="separator:a0d0809bccdeae9b7c9eb5289ab847544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a464bfaa85557128b7c6a4bbd4d968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a96a464bfaa85557128b7c6a4bbd4d968">hash_value</a> (float val) noexcept</td></tr>
<tr class="memdesc:a96a464bfaa85557128b7c6a4bbd4d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given float.  <a href="#a96a464bfaa85557128b7c6a4bbd4d968">More...</a><br /></td></tr>
<tr class="separator:a96a464bfaa85557128b7c6a4bbd4d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f653fc485b211136a292901103cede4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3f653fc485b211136a292901103cede4">hash_value</a> (double val) noexcept</td></tr>
<tr class="memdesc:a3f653fc485b211136a292901103cede4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given double.  <a href="#a3f653fc485b211136a292901103cede4">More...</a><br /></td></tr>
<tr class="separator:a3f653fc485b211136a292901103cede4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9299b0cc16bb9842b31cdb2d83021dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9299b0cc16bb9842b31cdb2d83021dae">hash_value</a> (long double val) noexcept</td></tr>
<tr class="memdesc:a9299b0cc16bb9842b31cdb2d83021dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given long double.  <a href="#a9299b0cc16bb9842b31cdb2d83021dae">More...</a><br /></td></tr>
<tr class="separator:a9299b0cc16bb9842b31cdb2d83021dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cab286759f64965ed073bc322e8bd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91cab286759f64965ed073bc322e8bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a91cab286759f64965ed073bc322e8bd5">hash_value</a> (T *val) noexcept</td></tr>
<tr class="memdesc:a91cab286759f64965ed073bc322e8bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given pointer.  <a href="#a91cab286759f64965ed073bc322e8bd5">More...</a><br /></td></tr>
<tr class="separator:a91cab286759f64965ed073bc322e8bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6e8f8ee3600cf7e1f181b7ab042c5e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a8e6e8f8ee3600cf7e1f181b7ab042c5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a8e6e8f8ee3600cf7e1f181b7ab042c5e">hash_value</a> (R(*val)(Args...)) noexcept</td></tr>
<tr class="memdesc:a8e6e8f8ee3600cf7e1f181b7ab042c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given function pointer.  <a href="#a8e6e8f8ee3600cf7e1f181b7ab042c5e">More...</a><br /></td></tr>
<tr class="separator:a8e6e8f8ee3600cf7e1f181b7ab042c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dba90796b6fa79d2c6dbc99d5e9e5f"><td class="memTemplParams" colspan="2">template&lt;typename R , typename C &gt; </td></tr>
<tr class="memitem:a85dba90796b6fa79d2c6dbc99d5e9e5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a85dba90796b6fa79d2c6dbc99d5e9e5f">hash_value</a> (R C::*val) noexcept</td></tr>
<tr class="memdesc:a85dba90796b6fa79d2c6dbc99d5e9e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given member pointer.  <a href="#a85dba90796b6fa79d2c6dbc99d5e9e5f">More...</a><br /></td></tr>
<tr class="separator:a85dba90796b6fa79d2c6dbc99d5e9e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7465e6eca64b98688c7f090beb6a3e96"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:a7465e6eca64b98688c7f090beb6a3e96"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7465e6eca64b98688c7f090beb6a3e96">hash_value</a> (Enum val) noexcept</td></tr>
<tr class="memdesc:a7465e6eca64b98688c7f090beb6a3e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes enum values.  <a href="#a7465e6eca64b98688c7f090beb6a3e96">More...</a><br /></td></tr>
<tr class="separator:a7465e6eca64b98688c7f090beb6a3e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1877296e32889d983ea3b6bb067b900f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1877296e32889d983ea3b6bb067b900f">hash_combine</a> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> seed, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> <a class="el" href="../../db/d10/structbit_1_1core_1_1hash.html">hash</a>) noexcept</td></tr>
<tr class="memdesc:a1877296e32889d983ea3b6bb067b900f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two hash values.  <a href="#a1877296e32889d983ea3b6bb067b900f">More...</a><br /></td></tr>
<tr class="separator:a1877296e32889d983ea3b6bb067b900f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caf854e63614ed2ba6a366e23bd65b5"><td class="memTemplParams" colspan="2">template&lt;typename... Hashes, typename  = std::enable_if&lt;(sizeof...(Hashes)&gt;0&gt; </td></tr>
<tr class="memitem:a5caf854e63614ed2ba6a366e23bd65b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a5caf854e63614ed2ba6a366e23bd65b5">hash_combine</a> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> seed, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> hash0, Hashes...hashes) noexcept</td></tr>
<tr class="memdesc:a5caf854e63614ed2ba6a366e23bd65b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines n hash values.  <a href="#a5caf854e63614ed2ba6a366e23bd65b5">More...</a><br /></td></tr>
<tr class="separator:a5caf854e63614ed2ba6a366e23bd65b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2669bce95a2431bf03a059245573f481"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a2669bce95a2431bf03a059245573f481"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2669bce95a2431bf03a059245573f481">hash_range</a> (InputIterator first, InputIterator last) noexcept(<a class="el" href="../../df/d0a/structbit_1_1core_1_1is__nothrow__hashable.html">is_nothrow_hashable</a>&lt; typename std::iterator_traits&lt; InputIterator &gt;::value_type &gt;::value)</td></tr>
<tr class="memdesc:a2669bce95a2431bf03a059245573f481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a range of entries, returning the result.  <a href="#a2669bce95a2431bf03a059245573f481">More...</a><br /></td></tr>
<tr class="separator:a2669bce95a2431bf03a059245573f481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0514f296deed170893498184033a474f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0514f296deed170893498184033a474f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0514f296deed170893498184033a474f">hash_values</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a0514f296deed170893498184033a474f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes all the specified <code>args</code> and combines the results.  <a href="#a0514f296deed170893498184033a474f">More...</a><br /></td></tr>
<tr class="separator:a0514f296deed170893498184033a474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c1e455166eaeae136eaf1788d9e4b8"><td class="memTemplParams" colspan="2">template&lt;typename CharT &gt; </td></tr>
<tr class="memitem:a80c1e455166eaeae136eaf1788d9e4b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a80c1e455166eaeae136eaf1788d9e4b8">hash_string_segment</a> (const CharT *str, std::size_t count) noexcept</td></tr>
<tr class="memdesc:a80c1e455166eaeae136eaf1788d9e4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a segment of a given string.  <a href="#a80c1e455166eaeae136eaf1788d9e4b8">More...</a><br /></td></tr>
<tr class="separator:a80c1e455166eaeae136eaf1788d9e4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e5974ac125794d6a8bdb1052a8029e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49e5974ac125794d6a8bdb1052a8029e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a49e5974ac125794d6a8bdb1052a8029e">hash_raw</a> (const T &amp;<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a66c6402efda390b93c9704f3537a3b76">data</a>) noexcept</td></tr>
<tr class="memdesc:a49e5974ac125794d6a8bdb1052a8029e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the raw memory from a given type.  <a href="#a49e5974ac125794d6a8bdb1052a8029e">More...</a><br /></td></tr>
<tr class="separator:a49e5974ac125794d6a8bdb1052a8029e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad433f17c43899a3cf2532a8df7489068"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename... Args&gt; </td></tr>
<tr class="memitem:ad433f17c43899a3cf2532a8df7489068"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad433f17c43899a3cf2532a8df7489068">invoke</a> (Func &amp;&amp;function, Args &amp;&amp;... args) noexcept(noexcept(detail::invoke_impl(std::forward&lt; Func &gt;(function), std::forward&lt; Args &gt;(args)...))) -&gt; decltype(detail::invoke_impl(std::forward&lt; Func &gt;(function), std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:ad433f17c43899a3cf2532a8df7489068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the Callable object <code>function</code> with the parameters <code>args</code>.  <a href="#ad433f17c43899a3cf2532a8df7489068">More...</a><br /></td></tr>
<tr class="separator:ad433f17c43899a3cf2532a8df7489068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad874efe0856adf8264bc8fd2e6eeba62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad874efe0856adf8264bc8fd2e6eeba62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad874efe0856adf8264bc8fd2e6eeba62">hash_value</a> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;val)</td></tr>
<tr class="memdesc:ad874efe0856adf8264bc8fd2e6eeba62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a hash of the underlying lazy, instantiating it if not already instantiated.  <a href="#ad874efe0856adf8264bc8fd2e6eeba62">More...</a><br /></td></tr>
<tr class="separator:ad874efe0856adf8264bc8fd2e6eeba62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57604cec41abca73b3f51425b2bc07d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:af57604cec41abca73b3f51425b2bc07d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af57604cec41abca73b3f51425b2bc07d">make_lazy</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:af57604cec41abca73b3f51425b2bc07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a lazy type from the given arguments.  <a href="#af57604cec41abca73b3f51425b2bc07d">More...</a><br /></td></tr>
<tr class="separator:af57604cec41abca73b3f51425b2bc07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcce9500567e547c2fc4721d861b67f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a0fcce9500567e547c2fc4721d861b67f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0fcce9500567e547c2fc4721d861b67f">make_lazy</a> (std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a0fcce9500567e547c2fc4721d861b67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a lazy type from the given arguments.  <a href="#a0fcce9500567e547c2fc4721d861b67f">More...</a><br /></td></tr>
<tr class="separator:a0fcce9500567e547c2fc4721d861b67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696082f2cb7f9cdb953a66dc1521fe03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ctor &gt; </td></tr>
<tr class="memitem:a696082f2cb7f9cdb953a66dc1521fe03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a696082f2cb7f9cdb953a66dc1521fe03">make_lazy_generator</a> (Ctor &amp;&amp;ctor)</td></tr>
<tr class="memdesc:a696082f2cb7f9cdb953a66dc1521fe03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a lazy type that uses a generator function to generate the arguments that will be forwarded to T's constructor.  <a href="#a696082f2cb7f9cdb953a66dc1521fe03">More...</a><br /></td></tr>
<tr class="separator:a696082f2cb7f9cdb953a66dc1521fe03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5aeff9341b2675bd0dd78cbb668e821"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5aeff9341b2675bd0dd78cbb668e821"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac5aeff9341b2675bd0dd78cbb668e821">swap</a> (<a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac5aeff9341b2675bd0dd78cbb668e821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the lazy from <code>lhs</code> and <code>rhs</code>.  <a href="#ac5aeff9341b2675bd0dd78cbb668e821">More...</a><br /></td></tr>
<tr class="separator:ac5aeff9341b2675bd0dd78cbb668e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c03d46451c3a9751a1baf2353afb12"><td class="memTemplParams" colspan="2"><a id="a76c03d46451c3a9751a1baf2353afb12"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76c03d46451c3a9751a1baf2353afb12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a76c03d46451c3a9751a1baf2353afb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b348f0fec43329bc07c312ea291261"><td class="memTemplParams" colspan="2"><a id="a24b348f0fec43329bc07c312ea291261"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24b348f0fec43329bc07c312ea291261"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a24b348f0fec43329bc07c312ea291261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5f972131ebf2a0cc7d45677a6cb9c6"><td class="memTemplParams" colspan="2"><a id="a3c5f972131ebf2a0cc7d45677a6cb9c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c5f972131ebf2a0cc7d45677a6cb9c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a3c5f972131ebf2a0cc7d45677a6cb9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287400b85fa6280c34ccf8f4bee08526"><td class="memTemplParams" colspan="2"><a id="a287400b85fa6280c34ccf8f4bee08526"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a287400b85fa6280c34ccf8f4bee08526"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a287400b85fa6280c34ccf8f4bee08526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e204fa9d4e038ca3aa1aca1e3c9884"><td class="memTemplParams" colspan="2"><a id="ad8e204fa9d4e038ca3aa1aca1e3c9884"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad8e204fa9d4e038ca3aa1aca1e3c9884"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:ad8e204fa9d4e038ca3aa1aca1e3c9884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db8e86af968afb2fb8a015d9c4874cb"><td class="memTemplParams" colspan="2"><a id="a5db8e86af968afb2fb8a015d9c4874cb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5db8e86af968afb2fb8a015d9c4874cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a5db8e86af968afb2fb8a015d9c4874cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fb21cb04a655aa1717668c0d9f5fd4"><td class="memTemplParams" colspan="2"><a id="a76fb21cb04a655aa1717668c0d9f5fd4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76fb21cb04a655aa1717668c0d9f5fd4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a76fb21cb04a655aa1717668c0d9f5fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f7a865f85d3667548010d52abfb716"><td class="memTemplParams" colspan="2"><a id="ab2f7a865f85d3667548010d52abfb716"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2f7a865f85d3667548010d52abfb716"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:ab2f7a865f85d3667548010d52abfb716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e47217225b51144cf56c50a0e36fcb"><td class="memTemplParams" colspan="2"><a id="a65e47217225b51144cf56c50a0e36fcb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65e47217225b51144cf56c50a0e36fcb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a65e47217225b51144cf56c50a0e36fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e7de237c2bb94de051430b3e51bb54"><td class="memTemplParams" colspan="2"><a id="a55e7de237c2bb94de051430b3e51bb54"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55e7de237c2bb94de051430b3e51bb54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a55e7de237c2bb94de051430b3e51bb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37acc1449013179276fe518d8a180bc4"><td class="memTemplParams" colspan="2"><a id="a37acc1449013179276fe518d8a180bc4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37acc1449013179276fe518d8a180bc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a37acc1449013179276fe518d8a180bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bf03cffaa1633d32d453ca898c4ee7"><td class="memTemplParams" colspan="2"><a id="a64bf03cffaa1633d32d453ca898c4ee7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64bf03cffaa1633d32d453ca898c4ee7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a64bf03cffaa1633d32d453ca898c4ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd89ae3e507fa443490a3f01ca909f0e"><td class="memTemplParams" colspan="2"><a id="afd89ae3e507fa443490a3f01ca909f0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd89ae3e507fa443490a3f01ca909f0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:afd89ae3e507fa443490a3f01ca909f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81e4d400a8493bba4602fee65a94742"><td class="memTemplParams" colspan="2"><a id="ac81e4d400a8493bba4602fee65a94742"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac81e4d400a8493bba4602fee65a94742"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:ac81e4d400a8493bba4602fee65a94742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd276d0742f3b47d09155443fa356383"><td class="memTemplParams" colspan="2"><a id="afd276d0742f3b47d09155443fa356383"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd276d0742f3b47d09155443fa356383"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:afd276d0742f3b47d09155443fa356383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8924a8ec4ecb7d95ad087fe2c58c8e63"><td class="memTemplParams" colspan="2"><a id="a8924a8ec4ecb7d95ad087fe2c58c8e63"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8924a8ec4ecb7d95ad087fe2c58c8e63"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a8924a8ec4ecb7d95ad087fe2c58c8e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880c4029977ce7a0ae1fc5f23032ebeb"><td class="memTemplParams" colspan="2"><a id="a880c4029977ce7a0ae1fc5f23032ebeb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a880c4029977ce7a0ae1fc5f23032ebeb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a880c4029977ce7a0ae1fc5f23032ebeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6d39b050e4374bf00f56125005361d"><td class="memTemplParams" colspan="2"><a id="acb6d39b050e4374bf00f56125005361d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb6d39b050e4374bf00f56125005361d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;lhs, const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:acb6d39b050e4374bf00f56125005361d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea17030a1fd41ff98d66aaa5412722f6"><td class="memItemLeft" align="right" valign="top"><a id="aea17030a1fd41ff98d66aaa5412722f6"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:aea17030a1fd41ff98d66aaa5412722f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbdc086c07a7bab35bfda15c9a8ef30"><td class="memItemLeft" align="right" valign="top"><a id="a6dbdc086c07a7bab35bfda15c9a8ef30"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:a6dbdc086c07a7bab35bfda15c9a8ef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6032315bc50eaaa030650f0281bce287"><td class="memItemLeft" align="right" valign="top"><a id="a6032315bc50eaaa030650f0281bce287"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:a6032315bc50eaaa030650f0281bce287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab9903adbe0341b2989b31f6a448ab8"><td class="memItemLeft" align="right" valign="top"><a id="a3ab9903adbe0341b2989b31f6a448ab8"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:a3ab9903adbe0341b2989b31f6a448ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f07f165b6daaaac68b40578a2fbe11"><td class="memItemLeft" align="right" valign="top"><a id="aa5f07f165b6daaaac68b40578a2fbe11"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:aa5f07f165b6daaaac68b40578a2fbe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d768af3801e7ffb3846125f635084"><td class="memItemLeft" align="right" valign="top"><a id="a682d768af3801e7ffb3846125f635084"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:a682d768af3801e7ffb3846125f635084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6056e72eee2ae8cd6ca23635ad0894c1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a6056e72eee2ae8cd6ca23635ad0894c1">hash_value</a> (const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a> &amp;)</td></tr>
<tr class="memdesc:a6056e72eee2ae8cd6ca23635ad0894c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the monostate.  <a href="#a6056e72eee2ae8cd6ca23635ad0894c1">More...</a><br /></td></tr>
<tr class="separator:a6056e72eee2ae8cd6ca23635ad0894c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4039fdf18e15ef63038db0514840389"><td class="memTemplParams" colspan="2"><a id="aa4039fdf18e15ef63038db0514840389"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4039fdf18e15ef63038db0514840389"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aa4039fdf18e15ef63038db0514840389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9854e0ce6c6aac391f4f23945a263bcc"><td class="memTemplParams" colspan="2"><a id="a9854e0ce6c6aac391f4f23945a263bcc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9854e0ce6c6aac391f4f23945a263bcc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a9854e0ce6c6aac391f4f23945a263bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad673ea04f8c52fe1bd0156cabab27755"><td class="memTemplParams" colspan="2"><a id="ad673ea04f8c52fe1bd0156cabab27755"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad673ea04f8c52fe1bd0156cabab27755"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ad673ea04f8c52fe1bd0156cabab27755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bf2d6d360c92caa47a8ff485be84f1"><td class="memTemplParams" colspan="2"><a id="a27bf2d6d360c92caa47a8ff485be84f1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27bf2d6d360c92caa47a8ff485be84f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a27bf2d6d360c92caa47a8ff485be84f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f6b7e52d5ab3b1dbd5a535cb65796"><td class="memTemplParams" colspan="2"><a id="aac0f6b7e52d5ab3b1dbd5a535cb65796"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac0f6b7e52d5ab3b1dbd5a535cb65796"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aac0f6b7e52d5ab3b1dbd5a535cb65796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb88121466efeee7f0d22fc3a0031e92"><td class="memTemplParams" colspan="2"><a id="aeb88121466efeee7f0d22fc3a0031e92"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb88121466efeee7f0d22fc3a0031e92"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:aeb88121466efeee7f0d22fc3a0031e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a898b102f44602a57f455165e2895b9"><td class="memTemplParams" colspan="2"><a id="a5a898b102f44602a57f455165e2895b9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a898b102f44602a57f455165e2895b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a5a898b102f44602a57f455165e2895b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422efa47a35a23bcfb3ea680fb5a9ce9"><td class="memTemplParams" colspan="2"><a id="a422efa47a35a23bcfb3ea680fb5a9ce9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a422efa47a35a23bcfb3ea680fb5a9ce9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:a422efa47a35a23bcfb3ea680fb5a9ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e963384c164f0214cc93b9a60b3bab"><td class="memTemplParams" colspan="2"><a id="ab8e963384c164f0214cc93b9a60b3bab"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8e963384c164f0214cc93b9a60b3bab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:ab8e963384c164f0214cc93b9a60b3bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600d936520798bcee3ebc64c45646182"><td class="memTemplParams" colspan="2"><a id="a600d936520798bcee3ebc64c45646182"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a600d936520798bcee3ebc64c45646182"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:a600d936520798bcee3ebc64c45646182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee78e99b11dd3e1ec406b3071fe1d42c"><td class="memTemplParams" colspan="2"><a id="aee78e99b11dd3e1ec406b3071fe1d42c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee78e99b11dd3e1ec406b3071fe1d42c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:aee78e99b11dd3e1ec406b3071fe1d42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9aacb3b20cb9c8d4e1e2b57a66db62"><td class="memTemplParams" colspan="2"><a id="a8a9aacb3b20cb9c8d4e1e2b57a66db62"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a9aacb3b20cb9c8d4e1e2b57a66db62"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:a8a9aacb3b20cb9c8d4e1e2b57a66db62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a66076be2bfb85e6776a0b49986bdaa"><td class="memTemplParams" colspan="2"><a id="a9a66076be2bfb85e6776a0b49986bdaa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a66076be2bfb85e6776a0b49986bdaa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a9a66076be2bfb85e6776a0b49986bdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d61199da837c3a924a86f4b4b62e852"><td class="memTemplParams" colspan="2"><a id="a2d61199da837c3a924a86f4b4b62e852"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d61199da837c3a924a86f4b4b62e852"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:a2d61199da837c3a924a86f4b4b62e852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b0d6c0e54161bc0e3e004dfb9deccf"><td class="memTemplParams" colspan="2"><a id="ae7b0d6c0e54161bc0e3e004dfb9deccf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7b0d6c0e54161bc0e3e004dfb9deccf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:ae7b0d6c0e54161bc0e3e004dfb9deccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83172635d69b6a461296f302fe781d9"><td class="memTemplParams" colspan="2"><a id="ac83172635d69b6a461296f302fe781d9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac83172635d69b6a461296f302fe781d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:ac83172635d69b6a461296f302fe781d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6709b503f378541a029af9f35b69d3bc"><td class="memTemplParams" colspan="2"><a id="a6709b503f378541a029af9f35b69d3bc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6709b503f378541a029af9f35b69d3bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a6709b503f378541a029af9f35b69d3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2f4907614201f0f7d4b74586176dd8"><td class="memTemplParams" colspan="2"><a id="a4f2f4907614201f0f7d4b74586176dd8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f2f4907614201f0f7d4b74586176dd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:a4f2f4907614201f0f7d4b74586176dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af314b5fe90101dba40b58a9c099c4bab"><td class="memTemplParams" colspan="2"><a id="af314b5fe90101dba40b58a9c099c4bab"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af314b5fe90101dba40b58a9c099c4bab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:af314b5fe90101dba40b58a9c099c4bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0108d9939d3b368e1545454721770392"><td class="memTemplParams" colspan="2"><a id="a0108d9939d3b368e1545454721770392"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0108d9939d3b368e1545454721770392"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;value, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:a0108d9939d3b368e1545454721770392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafedb5910ca3685eef211eadc490cb63"><td class="memTemplParams" colspan="2"><a id="aafedb5910ca3685eef211eadc490cb63"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafedb5910ca3685eef211eadc490cb63"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:aafedb5910ca3685eef211eadc490cb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a71d770faca3ade59b6ff400a1408c4"><td class="memTemplParams" colspan="2"><a id="a5a71d770faca3ade59b6ff400a1408c4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a71d770faca3ade59b6ff400a1408c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;value, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:a5a71d770faca3ade59b6ff400a1408c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bbb95b2a1bb58e2767ad7923019b5f"><td class="memTemplParams" colspan="2"><a id="af6bbb95b2a1bb58e2767ad7923019b5f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6bbb95b2a1bb58e2767ad7923019b5f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:af6bbb95b2a1bb58e2767ad7923019b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24008812a04d5d099a2de41cbeb6f7a"><td class="memTemplParams" colspan="2"><a id="ab24008812a04d5d099a2de41cbeb6f7a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab24008812a04d5d099a2de41cbeb6f7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T &amp;value, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:ab24008812a04d5d099a2de41cbeb6f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac98eaa4b6d201340fb92325f57dadb"><td class="memTemplParams" colspan="2"><a id="a0ac98eaa4b6d201340fb92325f57dadb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ac98eaa4b6d201340fb92325f57dadb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:a0ac98eaa4b6d201340fb92325f57dadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad4e563a6f000f96ea35da4bf97364e"><td class="memTemplParams" colspan="2"><a id="a0ad4e563a6f000f96ea35da4bf97364e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ad4e563a6f000f96ea35da4bf97364e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;value, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:a0ad4e563a6f000f96ea35da4bf97364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cf2dc512f30cfd38c3668e95adf29a"><td class="memTemplParams" colspan="2"><a id="a43cf2dc512f30cfd38c3668e95adf29a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43cf2dc512f30cfd38c3668e95adf29a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:a43cf2dc512f30cfd38c3668e95adf29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a3265ae10efb224f69847d02fbb6b3"><td class="memTemplParams" colspan="2"><a id="aa7a3265ae10efb224f69847d02fbb6b3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7a3265ae10efb224f69847d02fbb6b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;value, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:aa7a3265ae10efb224f69847d02fbb6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c8ee9decce12f327234c23d4d280a8"><td class="memTemplParams" colspan="2"><a id="a81c8ee9decce12f327234c23d4d280a8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81c8ee9decce12f327234c23d4d280a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:a81c8ee9decce12f327234c23d4d280a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042e930957f5dd4df4bb2169647cf136"><td class="memTemplParams" colspan="2"><a id="a042e930957f5dd4df4bb2169647cf136"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a042e930957f5dd4df4bb2169647cf136"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;value, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:a042e930957f5dd4df4bb2169647cf136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a09b31fcf37df74b65ba906bac5c20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7a09b31fcf37df74b65ba906bac5c20"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; std::decay_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae7a09b31fcf37df74b65ba906bac5c20">make_optional</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:ae7a09b31fcf37df74b65ba906bac5c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object from <code>value</code>.  <a href="#ae7a09b31fcf37df74b65ba906bac5c20">More...</a><br /></td></tr>
<tr class="separator:ae7a09b31fcf37df74b65ba906bac5c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665d9cab4ad4ec500efcc95a52d0a476"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a665d9cab4ad4ec500efcc95a52d0a476"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a665d9cab4ad4ec500efcc95a52d0a476">make_optional</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a665d9cab4ad4ec500efcc95a52d0a476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object of type <code>T</code> from the given <code>args</code>.  <a href="#a665d9cab4ad4ec500efcc95a52d0a476">More...</a><br /></td></tr>
<tr class="separator:a665d9cab4ad4ec500efcc95a52d0a476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f18c94f402d0f37b1809825525d6fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a00f18c94f402d0f37b1809825525d6fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a00f18c94f402d0f37b1809825525d6fc">make_optional</a> (std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a00f18c94f402d0f37b1809825525d6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object of type <code>T</code> from the given <code>il</code> <code>args</code>.  <a href="#a00f18c94f402d0f37b1809825525d6fc">More...</a><br /></td></tr>
<tr class="separator:a00f18c94f402d0f37b1809825525d6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b26ad5ab22a544ec4ff8296d974409"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22b26ad5ab22a544ec4ff8296d974409"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a22b26ad5ab22a544ec4ff8296d974409">swap</a> (<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a22b26ad5ab22a544ec4ff8296d974409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>lhs</code> and <code>rhs</code>.  <a href="#a22b26ad5ab22a544ec4ff8296d974409">More...</a><br /></td></tr>
<tr class="separator:a22b26ad5ab22a544ec4ff8296d974409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16023c1d180ed1b9f2b481ab3a251ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af16023c1d180ed1b9f2b481ab3a251ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af16023c1d180ed1b9f2b481ab3a251ae">hash_value</a> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;s) noexcept</td></tr>
<tr class="memdesc:af16023c1d180ed1b9f2b481ab3a251ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given optional.  <a href="#af16023c1d180ed1b9f2b481ab3a251ae">More...</a><br /></td></tr>
<tr class="separator:af16023c1d180ed1b9f2b481ab3a251ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365a50d9856e072a234e809f525482c9"><td class="memTemplParams" colspan="2"><a id="a365a50d9856e072a234e809f525482c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a365a50d9856e072a234e809f525482c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a365a50d9856e072a234e809f525482c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7027d2dd8202fe69698b4b2feba3ee2"><td class="memTemplParams" colspan="2"><a id="ae7027d2dd8202fe69698b4b2feba3ee2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7027d2dd8202fe69698b4b2feba3ee2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae7027d2dd8202fe69698b4b2feba3ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07e2a127d46428c973e955bcd72a668"><td class="memTemplParams" colspan="2"><a id="aa07e2a127d46428c973e955bcd72a668"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa07e2a127d46428c973e955bcd72a668"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa07e2a127d46428c973e955bcd72a668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d35ba12239209d1ca8616744f2830ab"><td class="memTemplParams" colspan="2"><a id="a7d35ba12239209d1ca8616744f2830ab"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d35ba12239209d1ca8616744f2830ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7d35ba12239209d1ca8616744f2830ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492cca8a0983af9556aa9b3215e1605d"><td class="memTemplParams" colspan="2"><a id="a492cca8a0983af9556aa9b3215e1605d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a492cca8a0983af9556aa9b3215e1605d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a492cca8a0983af9556aa9b3215e1605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e600b32fa8bc5b159ee387e1ec98f81"><td class="memTemplParams" colspan="2"><a id="a2e600b32fa8bc5b159ee387e1ec98f81"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e600b32fa8bc5b159ee387e1ec98f81"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a2e600b32fa8bc5b159ee387e1ec98f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fa329af982df3616cd10ba72e11c9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48fa329af982df3616cd10ba72e11c9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a48fa329af982df3616cd10ba72e11c9d">swap</a> (<a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a48fa329af982df3616cd10ba72e11c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the two propagate_consts.  <a href="#a48fa329af982df3616cd10ba72e11c9d">More...</a><br /></td></tr>
<tr class="separator:a48fa329af982df3616cd10ba72e11c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bff4068bff0d16f5386c746d3c389ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bff4068bff0d16f5386c746d3c389ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9bff4068bff0d16f5386c746d3c389ca">hash_value</a> (const <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a9bff4068bff0d16f5386c746d3c389ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the value of the underlying type of the <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html" title="A wrapper to propagate the const qualifier. ">propagate_const</a>.  <a href="#a9bff4068bff0d16f5386c746d3c389ca">More...</a><br /></td></tr>
<tr class="separator:a9bff4068bff0d16f5386c746d3c389ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252978c0dc21f3e845a1b707fb469404"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a252978c0dc21f3e845a1b707fb469404"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d6/dbc/classbit_1_1core_1_1scope__guard.html">scope_guard</a>&lt; std::decay_t&lt; Fn &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a252978c0dc21f3e845a1b707fb469404">on_scope_exit</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a252978c0dc21f3e845a1b707fb469404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scope guard that executes at the end of the scope.  <a href="#a252978c0dc21f3e845a1b707fb469404">More...</a><br /></td></tr>
<tr class="separator:a252978c0dc21f3e845a1b707fb469404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb23fe1fe030da04880550467c6a43ef"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:acb23fe1fe030da04880550467c6a43ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d6/dbc/classbit_1_1core_1_1scope__guard.html">scope_guard</a>&lt; std::decay_t&lt; Fn &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#acb23fe1fe030da04880550467c6a43ef">on_scope_error_exit</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:acb23fe1fe030da04880550467c6a43ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scope guard that executes at the end of the scope only if an exception has been thrown.  <a href="#acb23fe1fe030da04880550467c6a43ef">More...</a><br /></td></tr>
<tr class="separator:acb23fe1fe030da04880550467c6a43ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a8c4c1bd9b1f96ada40849312947f"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a896a8c4c1bd9b1f96ada40849312947f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d6/dbc/classbit_1_1core_1_1scope__guard.html">scope_guard</a>&lt; std::decay_t&lt; Fn &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a896a8c4c1bd9b1f96ada40849312947f">on_scope_clean_exit</a> (Fn &amp;&amp;fn)</td></tr>
<tr class="memdesc:a896a8c4c1bd9b1f96ada40849312947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a scope guard that executes at the end of the scope only if no exception has propagated.  <a href="#a896a8c4c1bd9b1f96ada40849312947f">More...</a><br /></td></tr>
<tr class="separator:a896a8c4c1bd9b1f96ada40849312947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c397566b743fd24f8951624dd130e05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2c397566b743fd24f8951624dd130e05">operator==</a> (const <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html">source_location</a> &amp;lhs, const <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html">source_location</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2c397566b743fd24f8951624dd130e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines equality between two source_locations.  <a href="#a2c397566b743fd24f8951624dd130e05">More...</a><br /></td></tr>
<tr class="separator:a2c397566b743fd24f8951624dd130e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5864ea98813dae6f823bf69f1acda15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac5864ea98813dae6f823bf69f1acda15">operator!=</a> (const <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html">source_location</a> &amp;lhs, const <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html">source_location</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac5864ea98813dae6f823bf69f1acda15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines inequality between two source_locations.  <a href="#ac5864ea98813dae6f823bf69f1acda15">More...</a><br /></td></tr>
<tr class="separator:ac5864ea98813dae6f823bf69f1acda15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ec7ba016233046c155dc8565e08b5e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a04ec7ba016233046c155dc8565e08b5e">indeterminate</a> (const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a04ec7ba016233046c155dc8565e08b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tribool is indeterminate.  <a href="#a04ec7ba016233046c155dc8565e08b5e">More...</a><br /></td></tr>
<tr class="separator:a04ec7ba016233046c155dc8565e08b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00beb108332e69fbfea16ea991ecea2a"><td class="memItemLeft" align="right" valign="top"><a id="a00beb108332e69fbfea16ea991ecea2a"></a>
constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> t) noexcept</td></tr>
<tr class="separator:a00beb108332e69fbfea16ea991ecea2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0771b6f752691243cf4adc7c28b8c0dc"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0771b6f752691243cf4adc7c28b8c0dc">operator==</a> (const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0771b6f752691243cf4adc7c28b8c0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#a0771b6f752691243cf4adc7c28b8c0dc">More...</a><br /></td></tr>
<tr class="separator:a0771b6f752691243cf4adc7c28b8c0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfb22ace12711e200da5bcb4e80a6f9"><td class="memItemLeft" align="right" valign="top"><a id="aabfb22ace12711e200da5bcb4e80a6f9"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7bae740c09e530ae1f079d37793d55b9">indeterminate_t</a>, const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:aabfb22ace12711e200da5bcb4e80a6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f380a45c0f0f41e2a1a00c51b42d171"><td class="memItemLeft" align="right" valign="top"><a id="a9f380a45c0f0f41e2a1a00c51b42d171"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7bae740c09e530ae1f079d37793d55b9">indeterminate_t</a>) noexcept</td></tr>
<tr class="separator:a9f380a45c0f0f41e2a1a00c51b42d171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dadd05673cd742c7b2b0da0871ad01b"><td class="memItemLeft" align="right" valign="top"><a id="a2dadd05673cd742c7b2b0da0871ad01b"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;lhs, bool rhs) noexcept</td></tr>
<tr class="separator:a2dadd05673cd742c7b2b0da0871ad01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcddf23fb178f8f9bb12b6c4fdda2c3"><td class="memItemLeft" align="right" valign="top"><a id="a9bcddf23fb178f8f9bb12b6c4fdda2c3"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (bool lhs, const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a9bcddf23fb178f8f9bb12b6c4fdda2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c3fe306a36400488aac7865f2f515e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac9c3fe306a36400488aac7865f2f515e">operator!=</a> (const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac9c3fe306a36400488aac7865f2f515e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#ac9c3fe306a36400488aac7865f2f515e">More...</a><br /></td></tr>
<tr class="separator:ac9c3fe306a36400488aac7865f2f515e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8c145ba10dce0d1ddc9cee5cbb7321"><td class="memItemLeft" align="right" valign="top"><a id="ada8c145ba10dce0d1ddc9cee5cbb7321"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7bae740c09e530ae1f079d37793d55b9">indeterminate_t</a>, const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:ada8c145ba10dce0d1ddc9cee5cbb7321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad778a4fb27680d30be04daed02f77fa2"><td class="memItemLeft" align="right" valign="top"><a id="ad778a4fb27680d30be04daed02f77fa2"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;lhs, <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7bae740c09e530ae1f079d37793d55b9">indeterminate_t</a>) noexcept</td></tr>
<tr class="separator:ad778a4fb27680d30be04daed02f77fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affca234f401730091054026969277b60"><td class="memItemLeft" align="right" valign="top"><a id="affca234f401730091054026969277b60"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;lhs, bool rhs) noexcept</td></tr>
<tr class="separator:affca234f401730091054026969277b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e6c267334dda8c84b377f70c7f5b60"><td class="memItemLeft" align="right" valign="top"><a id="a82e6c267334dda8c84b377f70c7f5b60"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (bool lhs, const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a82e6c267334dda8c84b377f70c7f5b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590edce3b1934f91b5e0a45def3c8ae4"><td class="memItemLeft" align="right" valign="top"><a id="a590edce3b1934f91b5e0a45def3c8ae4"></a>
constexpr <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a590edce3b1934f91b5e0a45def3c8ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace002ab9575f62d72af5a322e8b131cf"><td class="memItemLeft" align="right" valign="top"><a id="ace002ab9575f62d72af5a322e8b131cf"></a>
constexpr <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:ace002ab9575f62d72af5a322e8b131cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad743b670f6bf2728c3cf70238911a8c7"><td class="memTemplParams" colspan="2"><a id="ad743b670f6bf2728c3cf70238911a8c7"></a>
template&lt;std::size_t Idx, typename Tuple &gt; </td></tr>
<tr class="memitem:ad743b670f6bf2728c3cf70238911a8c7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adl_get</b> (Tuple &amp;&amp;tuple)</td></tr>
<tr class="separator:ad743b670f6bf2728c3cf70238911a8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692e290b0e84335bb232b7f044830643"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename Tuple &gt; </td></tr>
<tr class="memitem:a692e290b0e84335bb232b7f044830643"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a692e290b0e84335bb232b7f044830643">apply</a> (Func &amp;&amp;function, Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:a692e290b0e84335bb232b7f044830643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the Callable object <code>function</code> with a <code>tuple</code> of arguments.  <a href="#a692e290b0e84335bb232b7f044830643">More...</a><br /></td></tr>
<tr class="separator:a692e290b0e84335bb232b7f044830643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c34577b8c71606e6656934ebe13535"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:af2c34577b8c71606e6656934ebe13535"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af2c34577b8c71606e6656934ebe13535">make_from_tuple</a> (Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:af2c34577b8c71606e6656934ebe13535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object of type  T, using the elements of the tuple t as the arguments to the constructor.  <a href="#af2c34577b8c71606e6656934ebe13535">More...</a><br /></td></tr>
<tr class="separator:af2c34577b8c71606e6656934ebe13535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1326ae6cfa6a20e3a31f4f353d018"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7dc1326ae6cfa6a20e3a31f4f353d018"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7dc1326ae6cfa6a20e3a31f4f353d018">uninitialized_default_construct_at</a> (void *ptr)</td></tr>
<tr class="memdesc:a7dc1326ae6cfa6a20e3a31f4f353d018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructs an instance of type <code>T</code> in the given memory.  <a href="#a7dc1326ae6cfa6a20e3a31f4f353d018">More...</a><br /></td></tr>
<tr class="separator:a7dc1326ae6cfa6a20e3a31f4f353d018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1d00426bd79b404f141a23711002d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b1d00426bd79b404f141a23711002d9"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3b1d00426bd79b404f141a23711002d9">uninitialized_copy_at</a> (void *ptr, const T &amp;other)</td></tr>
<tr class="memdesc:a3b1d00426bd79b404f141a23711002d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an instance of type <code>T</code> in the given memory.  <a href="#a3b1d00426bd79b404f141a23711002d9">More...</a><br /></td></tr>
<tr class="separator:a3b1d00426bd79b404f141a23711002d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972a3a74ef52c90323a0a08f54b27e94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a972a3a74ef52c90323a0a08f54b27e94"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a972a3a74ef52c90323a0a08f54b27e94">uninitialized_move_at</a> (void *ptr, T &amp;&amp;other)</td></tr>
<tr class="memdesc:a972a3a74ef52c90323a0a08f54b27e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs an instance of type <code>T</code> in the given memory.  <a href="#a972a3a74ef52c90323a0a08f54b27e94">More...</a><br /></td></tr>
<tr class="separator:a972a3a74ef52c90323a0a08f54b27e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e1e68b92eb5619d3ef30d36b11b934"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a06e1e68b92eb5619d3ef30d36b11b934"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a06e1e68b92eb5619d3ef30d36b11b934">uninitialized_construct_at</a> (void *ptr, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a06e1e68b92eb5619d3ef30d36b11b934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory location specified in <code>ptr</code>.  <a href="#a06e1e68b92eb5619d3ef30d36b11b934">More...</a><br /></td></tr>
<tr class="separator:a06e1e68b92eb5619d3ef30d36b11b934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8f5946de25b209a570a37b436c2c40"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:aca8f5946de25b209a570a37b436c2c40"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aca8f5946de25b209a570a37b436c2c40">uninitialized_tuple_construct_at</a> (void *ptr, Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:aca8f5946de25b209a570a37b436c2c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>tuple</code> at the memory location specified in <code>ptr</code>.  <a href="#aca8f5946de25b209a570a37b436c2c40">More...</a><br /></td></tr>
<tr class="separator:aca8f5946de25b209a570a37b436c2c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63dd3adf63dc0c3427b881aa1f7d1dc"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ab63dd3adf63dc0c3427b881aa1f7d1dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab63dd3adf63dc0c3427b881aa1f7d1dc">uninitialized_construct</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:ab63dd3adf63dc0c3427b881aa1f7d1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>last</code> )  <a href="#ab63dd3adf63dc0c3427b881aa1f7d1dc">More...</a><br /></td></tr>
<tr class="separator:ab63dd3adf63dc0c3427b881aa1f7d1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab858c50ae1c989635724abb58ef1ffe0"><td class="memTemplParams" colspan="2"><a id="ab858c50ae1c989635724abb58ef1ffe0"></a>
template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ab858c50ae1c989635724abb58ef1ffe0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>uninitialized_construct</b> (ForwardIterator first, ForwardIterator last, const typename std::iterator_traits&lt; ForwardIterator &gt;::value_type &amp;copy)</td></tr>
<tr class="separator:ab858c50ae1c989635724abb58ef1ffe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0de5e078e11eede138af0d701dc94ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0de5e078e11eede138af0d701dc94ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af0de5e078e11eede138af0d701dc94ee">destroy_at</a> (T *p)</td></tr>
<tr class="memdesc:af0de5e078e11eede138af0d701dc94ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the destructor of the object pointed to by p, as if by p-&gt;~T().  <a href="#af0de5e078e11eede138af0d701dc94ee">More...</a><br /></td></tr>
<tr class="separator:af0de5e078e11eede138af0d701dc94ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe204bcdcfaa842d61490dbbca87c42"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a1fe204bcdcfaa842d61490dbbca87c42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1fe204bcdcfaa842d61490dbbca87c42">destroy</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:a1fe204bcdcfaa842d61490dbbca87c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the objects in the range <code></code>[first, <code>last</code>)  <a href="#a1fe204bcdcfaa842d61490dbbca87c42">More...</a><br /></td></tr>
<tr class="separator:a1fe204bcdcfaa842d61490dbbca87c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a07bcad989da353c4f7a6725b74d4ab"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Size &gt; </td></tr>
<tr class="memitem:a3a07bcad989da353c4f7a6725b74d4ab"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3a07bcad989da353c4f7a6725b74d4ab">destroy_n</a> (ForwardIterator first, Size n)</td></tr>
<tr class="memdesc:a3a07bcad989da353c4f7a6725b74d4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <code>n</code> objects in the range starting at <code>first</code>.  <a href="#a3a07bcad989da353c4f7a6725b74d4ab">More...</a><br /></td></tr>
<tr class="separator:a3a07bcad989da353c4f7a6725b74d4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea54a6ec899b16ac7588783e35391c0c"><td class="memTemplParams" colspan="2"><a id="aea54a6ec899b16ac7588783e35391c0c"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:aea54a6ec899b16ac7588783e35391c0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aea54a6ec899b16ac7588783e35391c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd7b4ebfebe13fee8e7a9b42d743893"><td class="memTemplParams" colspan="2"><a id="a9bd7b4ebfebe13fee8e7a9b42d743893"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a9bd7b4ebfebe13fee8e7a9b42d743893"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9bd7b4ebfebe13fee8e7a9b42d743893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292c8b83606063ba940cf34ea71c4831"><td class="memTemplParams" colspan="2"><a id="a292c8b83606063ba940cf34ea71c4831"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a292c8b83606063ba940cf34ea71c4831"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a292c8b83606063ba940cf34ea71c4831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b22290387357b27543c8cc9e1681d7"><td class="memTemplParams" colspan="2"><a id="a34b22290387357b27543c8cc9e1681d7"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a34b22290387357b27543c8cc9e1681d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a34b22290387357b27543c8cc9e1681d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735bd2a18bee3c69d96e977aa501654c"><td class="memTemplParams" colspan="2"><a id="a735bd2a18bee3c69d96e977aa501654c"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a735bd2a18bee3c69d96e977aa501654c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a735bd2a18bee3c69d96e977aa501654c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253366e57158859f9d06500cdeb798ef"><td class="memTemplParams" colspan="2"><a id="a253366e57158859f9d06500cdeb798ef"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a253366e57158859f9d06500cdeb798ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a253366e57158859f9d06500cdeb798ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9818a93d98871306da76168556a3e7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:aec9818a93d98871306da76168556a3e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aec9818a93d98871306da76168556a3e7">holds_alternative</a> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:aec9818a93d98871306da76168556a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the variant v holds the alternative T.  <a href="#aec9818a93d98871306da76168556a3e7">More...</a><br /></td></tr>
<tr class="separator:aec9818a93d98871306da76168556a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1040f99274d130fa8f8e27a7cf9af7"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a8e1040f99274d130fa8f8e27a7cf9af7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a8e1040f99274d130fa8f8e27a7cf9af7">hash_value</a> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:a8e1040f99274d130fa8f8e27a7cf9af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash of this variant.  <a href="#a8e1040f99274d130fa8f8e27a7cf9af7">More...</a><br /></td></tr>
<tr class="separator:a8e1040f99274d130fa8f8e27a7cf9af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afa394559e2bd507e27ef72ffe98f4595"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:afa394559e2bd507e27ef72ffe98f4595"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#afa394559e2bd507e27ef72ffe98f4595">get</a> (<a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;x) noexcept</td></tr>
<tr class="memdesc:afa394559e2bd507e27ef72ffe98f4595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code>Nth</code> element from <code>x</code>.  <a href="#afa394559e2bd507e27ef72ffe98f4595">More...</a><br /></td></tr>
<tr class="separator:afa394559e2bd507e27ef72ffe98f4595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa4d6a6fb3fa4a537180d8ccdb8ebcd"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:adaa4d6a6fb3fa4a537180d8ccdb8ebcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#adaa4d6a6fb3fa4a537180d8ccdb8ebcd">get</a> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;x) noexcept</td></tr>
<tr class="memdesc:adaa4d6a6fb3fa4a537180d8ccdb8ebcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code>Nth</code> element from <code>x</code>.  <a href="#adaa4d6a6fb3fa4a537180d8ccdb8ebcd">More...</a><br /></td></tr>
<tr class="separator:adaa4d6a6fb3fa4a537180d8ccdb8ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575be5722c5ecc2ff9f3041c0377e14a"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a575be5722c5ecc2ff9f3041c0377e14a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a575be5722c5ecc2ff9f3041c0377e14a">get</a> (<a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:a575be5722c5ecc2ff9f3041c0377e14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code>Nth</code> element from <code>x</code>.  <a href="#a575be5722c5ecc2ff9f3041c0377e14a">More...</a><br /></td></tr>
<tr class="separator:a575be5722c5ecc2ff9f3041c0377e14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586a08ad40ade60348e849097b377f23"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a586a08ad40ade60348e849097b377f23"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a586a08ad40ade60348e849097b377f23">get</a> (const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:a586a08ad40ade60348e849097b377f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <code>Nth</code> element from <code>x</code>.  <a href="#a586a08ad40ade60348e849097b377f23">More...</a><br /></td></tr>
<tr class="separator:a586a08ad40ade60348e849097b377f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a103a5deb93be662372b777e3c1666bc3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a103a5deb93be662372b777e3c1666bc3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a103a5deb93be662372b777e3c1666bc3">deep_compare</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a103a5deb93be662372b777e3c1666bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a103a5deb93be662372b777e3c1666bc3">More...</a><br /></td></tr>
<tr class="separator:a103a5deb93be662372b777e3c1666bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130a84a0b8363904331d217b8ce899e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a130a84a0b8363904331d217b8ce899e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a130a84a0b8363904331d217b8ce899e7">deep_compare</a> (std::nullptr_t, const T &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a130a84a0b8363904331d217b8ce899e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a130a84a0b8363904331d217b8ce899e7">More...</a><br /></td></tr>
<tr class="separator:a130a84a0b8363904331d217b8ce899e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c9d6dad46100369c7555aee033a20f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2c9d6dad46100369c7555aee033a20f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad2c9d6dad46100369c7555aee033a20f">deep_compare</a> (const T &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:ad2c9d6dad46100369c7555aee033a20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#ad2c9d6dad46100369c7555aee033a20f">More...</a><br /></td></tr>
<tr class="separator:ad2c9d6dad46100369c7555aee033a20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38657589568f9ac3da93109b7613d196"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a38657589568f9ac3da93109b7613d196">deep_compare</a> (std::nullptr_t, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a38657589568f9ac3da93109b7613d196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a38657589568f9ac3da93109b7613d196">More...</a><br /></td></tr>
<tr class="separator:a38657589568f9ac3da93109b7613d196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1bb844fbb8e0294cbc64b77372020b18"><td class="memTemplParams" colspan="2">template&lt;typename C , typename Key &gt; </td></tr>
<tr class="memitem:a1bb844fbb8e0294cbc64b77372020b18"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1bb844fbb8e0294cbc64b77372020b18">at</a> (C &amp;c, Key &amp;&amp;key) -&gt; decltype(c.at(std::forward&lt; Key &gt;(key)))</td></tr>
<tr class="memdesc:a1bb844fbb8e0294cbc64b77372020b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the element from the container with the given <code>key</code>.  <a href="#a1bb844fbb8e0294cbc64b77372020b18">More...</a><br /></td></tr>
<tr class="separator:a1bb844fbb8e0294cbc64b77372020b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399c77dafe665f46c2d5e672812c6a77"><td class="memTemplParams" colspan="2">template&lt;typename C , typename Key &gt; </td></tr>
<tr class="memitem:a399c77dafe665f46c2d5e672812c6a77"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a399c77dafe665f46c2d5e672812c6a77">at</a> (const C &amp;c, Key &amp;&amp;key) -&gt; decltype(c.at(std::forward&lt; Key &gt;(key)))</td></tr>
<tr class="memdesc:a399c77dafe665f46c2d5e672812c6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the element from the container with the given <code>key</code>.  <a href="#a399c77dafe665f46c2d5e672812c6a77">More...</a><br /></td></tr>
<tr class="separator:a399c77dafe665f46c2d5e672812c6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aced4497f464f7a31d443327f99b3bc7d"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aced4497f464f7a31d443327f99b3bc7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aced4497f464f7a31d443327f99b3bc7d">data</a> (C &amp;c) -&gt; decltype(c.data())</td></tr>
<tr class="memdesc:aced4497f464f7a31d443327f99b3bc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to contiguous data in a container by delegating to the container.  <a href="#aced4497f464f7a31d443327f99b3bc7d">More...</a><br /></td></tr>
<tr class="separator:aced4497f464f7a31d443327f99b3bc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea38530996aac13beeed507a320a33d9"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aea38530996aac13beeed507a320a33d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aea38530996aac13beeed507a320a33d9">data</a> (const C &amp;c) -&gt; decltype(c.data())</td></tr>
<tr class="memdesc:aea38530996aac13beeed507a320a33d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to contiguous data in a container by delegating to the container.  <a href="#aea38530996aac13beeed507a320a33d9">More...</a><br /></td></tr>
<tr class="separator:aea38530996aac13beeed507a320a33d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a305ef47989897767dcaddd9d981ff974"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a305ef47989897767dcaddd9d981ff974"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a305ef47989897767dcaddd9d981ff974">front</a> (C &amp;c) noexcept -&gt; decltype(c.front())</td></tr>
<tr class="memdesc:a305ef47989897767dcaddd9d981ff974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the first entry in the given container by delegating the call to the container.  <a href="#a305ef47989897767dcaddd9d981ff974">More...</a><br /></td></tr>
<tr class="separator:a305ef47989897767dcaddd9d981ff974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be040bde12ac0b4095de82072365345"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a1be040bde12ac0b4095de82072365345"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1be040bde12ac0b4095de82072365345">front</a> (const C &amp;c) noexcept -&gt; decltype(c.front())</td></tr>
<tr class="memdesc:a1be040bde12ac0b4095de82072365345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the first entry in the given container by delegating the call to the container.  <a href="#a1be040bde12ac0b4095de82072365345">More...</a><br /></td></tr>
<tr class="separator:a1be040bde12ac0b4095de82072365345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a82952b2b002a9a78b62f31b7737174dc"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a82952b2b002a9a78b62f31b7737174dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a82952b2b002a9a78b62f31b7737174dc">back</a> (C &amp;c) noexcept -&gt; decltype(c.back())</td></tr>
<tr class="memdesc:a82952b2b002a9a78b62f31b7737174dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the last entry in the given container by delegating the call to the container.  <a href="#a82952b2b002a9a78b62f31b7737174dc">More...</a><br /></td></tr>
<tr class="separator:a82952b2b002a9a78b62f31b7737174dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d5f76937c0a01d114ccd2a5d78ff9e"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a31d5f76937c0a01d114ccd2a5d78ff9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a31d5f76937c0a01d114ccd2a5d78ff9e">back</a> (const C &amp;c) noexcept -&gt; decltype(c.back())</td></tr>
<tr class="memdesc:a31d5f76937c0a01d114ccd2a5d78ff9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the last entry in the given container by delegating the call to the container.  <a href="#a31d5f76937c0a01d114ccd2a5d78ff9e">More...</a><br /></td></tr>
<tr class="separator:a31d5f76937c0a01d114ccd2a5d78ff9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2f42ca7dfce022572daf371b4e2e1d1d"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a2f42ca7dfce022572daf371b4e2e1d1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af840a751e699cded9aab77b10c5a2bca">underlying_container_type_t</a>&lt; C &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2f42ca7dfce022572daf371b4e2e1d1d">get_underlying_container</a> (C &amp;container)</td></tr>
<tr class="memdesc:a2f42ca7dfce022572daf371b4e2e1d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying container of a given container adapter.  <a href="#a2f42ca7dfce022572daf371b4e2e1d1d">More...</a><br /></td></tr>
<tr class="separator:a2f42ca7dfce022572daf371b4e2e1d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3896843013a3359c6715056b6564bb"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a6e3896843013a3359c6715056b6564bb"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#af840a751e699cded9aab77b10c5a2bca">underlying_container_type_t</a>&lt; C &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a6e3896843013a3359c6715056b6564bb">get_underlying_container</a> (const C &amp;container)</td></tr>
<tr class="memdesc:a6e3896843013a3359c6715056b6564bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying container of a given container adapter.  <a href="#a6e3896843013a3359c6715056b6564bb">More...</a><br /></td></tr>
<tr class="separator:a6e3896843013a3359c6715056b6564bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1d9c0968c2f98d231e32aa8ce251c7"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a7d1d9c0968c2f98d231e32aa8ce251c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af840a751e699cded9aab77b10c5a2bca">underlying_container_type_t</a>&lt; C &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7d1d9c0968c2f98d231e32aa8ce251c7">get_underlying_container</a> (C &amp;&amp;container)</td></tr>
<tr class="memdesc:a7d1d9c0968c2f98d231e32aa8ce251c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying container of a given container adapter.  <a href="#a7d1d9c0968c2f98d231e32aa8ce251c7">More...</a><br /></td></tr>
<tr class="separator:a7d1d9c0968c2f98d231e32aa8ce251c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d5c4be91794078459da185d57c147e"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a40d5c4be91794078459da185d57c147e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#af840a751e699cded9aab77b10c5a2bca">underlying_container_type_t</a>&lt; C &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a40d5c4be91794078459da185d57c147e">get_underlying_container</a> (const C &amp;&amp;container)</td></tr>
<tr class="memdesc:a40d5c4be91794078459da185d57c147e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying container of a given container adapter.  <a href="#a40d5c4be91794078459da185d57c147e">More...</a><br /></td></tr>
<tr class="separator:a40d5c4be91794078459da185d57c147e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0706e5b253fafc6b29cc33578f48f1b6"><td class="memTemplParams" colspan="2">template&lt;typename R , typename C , typename... Args&gt; </td></tr>
<tr class="memitem:a0706e5b253fafc6b29cc33578f48f1b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0706e5b253fafc6b29cc33578f48f1b6">hash_value</a> (R(C::*val)(Args...)) noexcept</td></tr>
<tr class="memdesc:a0706e5b253fafc6b29cc33578f48f1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given member function pointer.  <a href="#a0706e5b253fafc6b29cc33578f48f1b6">More...</a><br /></td></tr>
<tr class="separator:a0706e5b253fafc6b29cc33578f48f1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a286f256fcf2305d0da9ec0482ce4214d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a286f256fcf2305d0da9ec0482ce4214d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a286f256fcf2305d0da9ec0482ce4214d">hash_value</a> (T(&amp;val)[N])</td></tr>
<tr class="memdesc:a286f256fcf2305d0da9ec0482ce4214d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given T array.  <a href="#a286f256fcf2305d0da9ec0482ce4214d">More...</a><br /></td></tr>
<tr class="separator:a286f256fcf2305d0da9ec0482ce4214d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3367f727959b10b889d08e8fc3c0ff"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a1d3367f727959b10b889d08e8fc3c0ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1d3367f727959b10b889d08e8fc3c0ff">hash_value</a> (const T(&amp;val)[N])</td></tr>
<tr class="memdesc:a1d3367f727959b10b889d08e8fc3c0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given T array.  <a href="#a1d3367f727959b10b889d08e8fc3c0ff">More...</a><br /></td></tr>
<tr class="separator:a1d3367f727959b10b889d08e8fc3c0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a888eff8e740584365fe4113777227d55"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Size &gt; </td></tr>
<tr class="memitem:a888eff8e740584365fe4113777227d55"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a888eff8e740584365fe4113777227d55">uninitialized_construct_n</a> (ForwardIterator first, Size n)</td></tr>
<tr class="memdesc:a888eff8e740584365fe4113777227d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>first</code> + <code>n</code> )  <a href="#a888eff8e740584365fe4113777227d55">More...</a><br /></td></tr>
<tr class="separator:a888eff8e740584365fe4113777227d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bae090d25705f96983335e3cf3649f5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Size &gt; </td></tr>
<tr class="memitem:a5bae090d25705f96983335e3cf3649f5"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a5bae090d25705f96983335e3cf3649f5">uninitialized_construct_n</a> (ForwardIterator first, Size n, const typename std::iterator_traits&lt; ForwardIterator &gt;::value_type &amp;copy)</td></tr>
<tr class="memdesc:a5bae090d25705f96983335e3cf3649f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>first</code> + <code>n</code> )  <a href="#a5bae090d25705f96983335e3cf3649f5">More...</a><br /></td></tr>
<tr class="separator:a5bae090d25705f96983335e3cf3649f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2e6e66864f254d1cd938a515082c57ce"><td class="memTemplParams" colspan="2"><a id="a2e6e66864f254d1cd938a515082c57ce"></a>
template&lt;std::size_t I, typename... Types&gt; </td></tr>
<tr class="memitem:a2e6e66864f254d1cd938a515082c57ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr variant_alternative_t&lt; I, <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;v)</td></tr>
<tr class="separator:a2e6e66864f254d1cd938a515082c57ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111fbfae263c9f3bcb822819741c310b"><td class="memTemplParams" colspan="2"><a id="a111fbfae263c9f3bcb822819741c310b"></a>
template&lt;std::size_t I, typename... Types&gt; </td></tr>
<tr class="memitem:a111fbfae263c9f3bcb822819741c310b"><td class="memTemplItemLeft" align="right" valign="top">constexpr variant_alternative_t&lt; I, <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&amp;v)</td></tr>
<tr class="separator:a111fbfae263c9f3bcb822819741c310b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11da94e227541ac8e2f57db52776c3db"><td class="memTemplParams" colspan="2"><a id="a11da94e227541ac8e2f57db52776c3db"></a>
template&lt;std::size_t I, typename... Types&gt; </td></tr>
<tr class="memitem:a11da94e227541ac8e2f57db52776c3db"><td class="memTemplItemLeft" align="right" valign="top">constexpr const variant_alternative_t&lt; I, <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;v)</td></tr>
<tr class="separator:a11da94e227541ac8e2f57db52776c3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6f561dd317aede7b20283c4eba8b43"><td class="memTemplParams" colspan="2"><a id="aee6f561dd317aede7b20283c4eba8b43"></a>
template&lt;std::size_t I, typename... Types&gt; </td></tr>
<tr class="memitem:aee6f561dd317aede7b20283c4eba8b43"><td class="memTemplItemLeft" align="right" valign="top">constexpr const variant_alternative_t&lt; I, <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&amp;v)</td></tr>
<tr class="separator:aee6f561dd317aede7b20283c4eba8b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9e33a514d678ae30919ad9f1a804d834"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a9e33a514d678ae30919ad9f1a804d834"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9e33a514d678ae30919ad9f1a804d834">get</a> (<a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;v)</td></tr>
<tr class="memdesc:a9e33a514d678ae30919ad9f1a804d834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the.  <a href="#a9e33a514d678ae30919ad9f1a804d834">More...</a><br /></td></tr>
<tr class="separator:a9e33a514d678ae30919ad9f1a804d834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c334d6e887191085cb5aa6c6a15894"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ad6c334d6e887191085cb5aa6c6a15894"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad6c334d6e887191085cb5aa6c6a15894">get</a> (<a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&amp;v)</td></tr>
<tr class="memdesc:ad6c334d6e887191085cb5aa6c6a15894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the.  <a href="#ad6c334d6e887191085cb5aa6c6a15894">More...</a><br /></td></tr>
<tr class="separator:ad6c334d6e887191085cb5aa6c6a15894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1a8c2c7655cdd77777a3cbdfda1892"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a8c1a8c2c7655cdd77777a3cbdfda1892"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a8c1a8c2c7655cdd77777a3cbdfda1892">get</a> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;v)</td></tr>
<tr class="memdesc:a8c1a8c2c7655cdd77777a3cbdfda1892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the.  <a href="#a8c1a8c2c7655cdd77777a3cbdfda1892">More...</a><br /></td></tr>
<tr class="separator:a8c1a8c2c7655cdd77777a3cbdfda1892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770a846dee0632f51b6b9915fbe45203"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a770a846dee0632f51b6b9915fbe45203"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a770a846dee0632f51b6b9915fbe45203">get</a> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&amp;v)</td></tr>
<tr class="memdesc:a770a846dee0632f51b6b9915fbe45203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the.  <a href="#a770a846dee0632f51b6b9915fbe45203">More...</a><br /></td></tr>
<tr class="separator:a770a846dee0632f51b6b9915fbe45203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4e0692e7a0f194394b9f4dbc17a02910"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename... Types&gt; </td></tr>
<tr class="memitem:a4e0692e7a0f194394b9f4dbc17a02910"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::add_pointer_t&lt; variant_alternative_t&lt; I, <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a4e0692e7a0f194394b9f4dbc17a02910">get_if</a> (<a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; *pv) noexcept</td></tr>
<tr class="memdesc:a4e0692e7a0f194394b9f4dbc17a02910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor.  <a href="#a4e0692e7a0f194394b9f4dbc17a02910">More...</a><br /></td></tr>
<tr class="separator:a4e0692e7a0f194394b9f4dbc17a02910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cdacd1d9f9526ec1ece0f968bd63cd"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename... Types&gt; </td></tr>
<tr class="memitem:ab4cdacd1d9f9526ec1ece0f968bd63cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::add_pointer_t&lt; const variant_alternative_t&lt; I, <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab4cdacd1d9f9526ec1ece0f968bd63cd">get_if</a> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; *pv) noexcept</td></tr>
<tr class="memdesc:ab4cdacd1d9f9526ec1ece0f968bd63cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index-based non-throwing accessor.  <a href="#ab4cdacd1d9f9526ec1ece0f968bd63cd">More...</a><br /></td></tr>
<tr class="separator:ab4cdacd1d9f9526ec1ece0f968bd63cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1c5d6bd02a1f6e0df15174eba83b3f59"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a1c5d6bd02a1f6e0df15174eba83b3f59"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::add_pointer_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1c5d6bd02a1f6e0df15174eba83b3f59">get_if</a> (<a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; *pv) noexcept</td></tr>
<tr class="memdesc:a1c5d6bd02a1f6e0df15174eba83b3f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-based non-throwing accessor.  <a href="#a1c5d6bd02a1f6e0df15174eba83b3f59">More...</a><br /></td></tr>
<tr class="separator:a1c5d6bd02a1f6e0df15174eba83b3f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1021e598ea8f73a96cd5d98d44c43f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:aac1021e598ea8f73a96cd5d98d44c43f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::add_pointer_t&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aac1021e598ea8f73a96cd5d98d44c43f">get_if</a> (const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; *pv) noexcept</td></tr>
<tr class="memdesc:aac1021e598ea8f73a96cd5d98d44c43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-based non-throwing accessor.  <a href="#aac1021e598ea8f73a96cd5d98d44c43f">More...</a><br /></td></tr>
<tr class="separator:aac1021e598ea8f73a96cd5d98d44c43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa00bc01a2a09d1b1ee7996cd0330f79c"><td class="memItemLeft" align="right" valign="top"><a id="aa00bc01a2a09d1b1ee7996cd0330f79c"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa00bc01a2a09d1b1ee7996cd0330f79c">dynamic_extent</a> = std::ptrdiff_t{-1}</td></tr>
<tr class="memdesc:aa00bc01a2a09d1b1ee7996cd0330f79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to represent dynamic-extents. <br /></td></tr>
<tr class="separator:aa00bc01a2a09d1b1ee7996cd0330f79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504eba41c7fd7d1dbd5e04f8579e3630"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:a504eba41c7fd7d1dbd5e04f8579e3630"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; std::remove_pointer_t&lt; decltype(std::declval&lt; const Pointer &amp; &gt;).<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a47d690dc876b4908b42c8d33f73fe6a9">get</a>())&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a504eba41c7fd7d1dbd5e04f8579e3630">make_observer</a> (const Pointer &amp;ptr) noexcept</td></tr>
<tr class="memdesc:a504eba41c7fd7d1dbd5e04f8579e3630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a smart pointer.  <a href="#a504eba41c7fd7d1dbd5e04f8579e3630">More...</a><br /></td></tr>
<tr class="separator:a504eba41c7fd7d1dbd5e04f8579e3630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e94d709bc3526358602db98d408e71a"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:a4e94d709bc3526358602db98d408e71a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a4e94d709bc3526358602db98d408e71a">bool_constant_v</a> = <a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html">bool_constant</a>&lt;B&gt;::value</td></tr>
<tr class="memdesc:a4e94d709bc3526358602db98d408e71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable to extract bool_constant::value.  <a href="#a4e94d709bc3526358602db98d408e71a">More...</a><br /></td></tr>
<tr class="separator:a4e94d709bc3526358602db98d408e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83516b3f55cd6395bbd001865109bc09"><td class="memTemplParams" colspan="2"><a id="a83516b3f55cd6395bbd001865109bc09"></a>
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a83516b3f55cd6395bbd001865109bc09"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_v</b> = is_detected&lt;Op, Args...&gt;::value</td></tr>
<tr class="separator:a83516b3f55cd6395bbd001865109bc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddc8e00058bd882e3d13669b60f58f4"><td class="memTemplParams" colspan="2"><a id="aeddc8e00058bd882e3d13669b60f58f4"></a>
template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:aeddc8e00058bd882e3d13669b60f58f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_exact_v</b> = is_detected_exact&lt;Expected, Op, Args...&gt;::value</td></tr>
<tr class="separator:aeddc8e00058bd882e3d13669b60f58f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231f60f04e94f98520cd67388035f609"><td class="memTemplParams" colspan="2"><a id="a231f60f04e94f98520cd67388035f609"></a>
template&lt;typename To , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a231f60f04e94f98520cd67388035f609"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_convertible_v</b> = is_detected_convertible&lt;To, Op, Args...&gt;::value</td></tr>
<tr class="separator:a231f60f04e94f98520cd67388035f609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420e06176fac3f4065e7371fe63bc0ec"><td class="memTemplParams" colspan="2"><a id="a420e06176fac3f4065e7371fe63bc0ec"></a>
template&lt;typename T , T V&gt; </td></tr>
<tr class="memitem:a420e06176fac3f4065e7371fe63bc0ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integral_constant_v</b> = integral_constant&lt;T,V&gt;::value</td></tr>
<tr class="separator:a420e06176fac3f4065e7371fe63bc0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa915b880bed22d4ce34b97c241882a4f"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size&gt; </td></tr>
<tr class="memitem:aa915b880bed22d4ce34b97c241882a4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa915b880bed22d4ce34b97c241882a4f">size_constant_v</a> = <a class="el" href="../../d1/d94/structbit_1_1core_1_1size__constant.html">size_constant</a>&lt;Size&gt;::value</td></tr>
<tr class="memdesc:aa915b880bed22d4ce34b97c241882a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable to extract size_constant::value.  <a href="#aa915b880bed22d4ce34b97c241882a4f">More...</a><br /></td></tr>
<tr class="separator:aa915b880bed22d4ce34b97c241882a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e06361961664b22d9a6fce543393777"><td class="memTemplParams" colspan="2"><a id="a4e06361961664b22d9a6fce543393777"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4e06361961664b22d9a6fce543393777"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a4e06361961664b22d9a6fce543393777">is_assignable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab51f16431c3e7b201420c4b96ca59f58">is_assignable</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:a4e06361961664b22d9a6fce543393777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_assignable::type. <br /></td></tr>
<tr class="separator:a4e06361961664b22d9a6fce543393777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2344da6d12f8b378fb7cf68be34243"><td class="memTemplParams" colspan="2"><a id="a8b2344da6d12f8b378fb7cf68be34243"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a8b2344da6d12f8b378fb7cf68be34243"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a8b2344da6d12f8b378fb7cf68be34243">is_const_member_function_pointer_v</a> = <a class="el" href="../../d4/d63/structbit_1_1core_1_1is__const__member__function__pointer.html">is_const_member_function_pointer</a>&lt;Func&gt;::value</td></tr>
<tr class="memdesc:a8b2344da6d12f8b378fb7cf68be34243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_const_member_function_pointer::type. <br /></td></tr>
<tr class="separator:a8b2344da6d12f8b378fb7cf68be34243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace61a7180d29df1dbe85d6d6761e5775"><td class="memTemplParams" colspan="2"><a id="ace61a7180d29df1dbe85d6d6761e5775"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace61a7180d29df1dbe85d6d6761e5775"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ace61a7180d29df1dbe85d6d6761e5775">is_copy_assignable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3e4d09b7fe409dc363b65f21fb0b1b06">is_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ace61a7180d29df1dbe85d6d6761e5775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_copy_assignable::type. <br /></td></tr>
<tr class="separator:ace61a7180d29df1dbe85d6d6761e5775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520b512c2d334ee7da73409c75770da1"><td class="memTemplParams" colspan="2"><a id="a520b512c2d334ee7da73409c75770da1"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a520b512c2d334ee7da73409c75770da1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a520b512c2d334ee7da73409c75770da1">are_copy_assignable_v</a> = <a class="el" href="../../d8/d59/structbit_1_1core_1_1are__copy__assignable.html">are_copy_assignable</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a520b512c2d334ee7da73409c75770da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_copy_assignable::type. <br /></td></tr>
<tr class="separator:a520b512c2d334ee7da73409c75770da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef1a9904bd3c573f0f00505a11a6da2"><td class="memTemplParams" colspan="2"><a id="afef1a9904bd3c573f0f00505a11a6da2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afef1a9904bd3c573f0f00505a11a6da2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#afef1a9904bd3c573f0f00505a11a6da2">is_copy_constructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1771083dc64b5a241d9e36069a44cb6a">is_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:afef1a9904bd3c573f0f00505a11a6da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_copy_constructible::type. <br /></td></tr>
<tr class="separator:afef1a9904bd3c573f0f00505a11a6da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0861bbd7a5797b501f1206d5ad9381"><td class="memTemplParams" colspan="2"><a id="aaa0861bbd7a5797b501f1206d5ad9381"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:aaa0861bbd7a5797b501f1206d5ad9381"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aaa0861bbd7a5797b501f1206d5ad9381">are_copy_constructible_v</a> = <a class="el" href="../../dc/d55/structbit_1_1core_1_1are__copy__constructible.html">are_copy_constructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:aaa0861bbd7a5797b501f1206d5ad9381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_copy_constructible::type. <br /></td></tr>
<tr class="separator:aaa0861bbd7a5797b501f1206d5ad9381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7827182f5e0ebf284a10a23d14b2ebf"><td class="memTemplParams" colspan="2"><a id="ad7827182f5e0ebf284a10a23d14b2ebf"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ad7827182f5e0ebf284a10a23d14b2ebf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad7827182f5e0ebf284a10a23d14b2ebf">is_cv_member_function_poiner_v</a> = <a class="el" href="../../dd/d19/structbit_1_1core_1_1is__cv__member__function__pointer.html">is_cv_member_function_pointer</a>&lt;Func&gt;::value</td></tr>
<tr class="memdesc:ad7827182f5e0ebf284a10a23d14b2ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_cv_member_function_pointer::type. <br /></td></tr>
<tr class="separator:ad7827182f5e0ebf284a10a23d14b2ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b35e612266a49e4f4c4f7899dc4905"><td class="memTemplParams" colspan="2"><a id="a15b35e612266a49e4f4c4f7899dc4905"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15b35e612266a49e4f4c4f7899dc4905"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a15b35e612266a49e4f4c4f7899dc4905">is_default_constructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7075f46b78f22acb517a4fc86f9ee464">is_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a15b35e612266a49e4f4c4f7899dc4905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_default_constructible::type. <br /></td></tr>
<tr class="separator:a15b35e612266a49e4f4c4f7899dc4905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746b82843294dc9aa3cc7450033f54ae"><td class="memTemplParams" colspan="2"><a id="a746b82843294dc9aa3cc7450033f54ae"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a746b82843294dc9aa3cc7450033f54ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a746b82843294dc9aa3cc7450033f54ae">are_default_constructible_v</a> = <a class="el" href="../../d5/dae/structbit_1_1core_1_1are__default__constructible.html">are_default_constructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a746b82843294dc9aa3cc7450033f54ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_default_constructible::type. <br /></td></tr>
<tr class="separator:a746b82843294dc9aa3cc7450033f54ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634c73b9760ce34982dfc67c793c057a"><td class="memTemplParams" colspan="2"><a id="a634c73b9760ce34982dfc67c793c057a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a634c73b9760ce34982dfc67c793c057a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a634c73b9760ce34982dfc67c793c057a">is_destructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a414aed485401f8a9703416887ba9c2e8">is_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a634c73b9760ce34982dfc67c793c057a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_destructible::type. <br /></td></tr>
<tr class="separator:a634c73b9760ce34982dfc67c793c057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ba3ecd798d567cc2dc028fee91e67a"><td class="memTemplParams" colspan="2"><a id="aa3ba3ecd798d567cc2dc028fee91e67a"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:aa3ba3ecd798d567cc2dc028fee91e67a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa3ba3ecd798d567cc2dc028fee91e67a">are_destructible_v</a> = <a class="el" href="../../d1/dff/structbit_1_1core_1_1are__destructible.html">are_destructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:aa3ba3ecd798d567cc2dc028fee91e67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_destructible::type. <br /></td></tr>
<tr class="separator:aa3ba3ecd798d567cc2dc028fee91e67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2b044a6df7ad4656b15cba76fd628a"><td class="memTemplParams" colspan="2"><a id="a5e2b044a6df7ad4656b15cba76fd628a"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a5e2b044a6df7ad4656b15cba76fd628a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a5e2b044a6df7ad4656b15cba76fd628a">is_explicitly_constructible_v</a> = <a class="el" href="../../da/dae/structbit_1_1core_1_1is__explicitly__constructible.html">is_explicitly_constructible</a>&lt;T,Args...&gt;::value</td></tr>
<tr class="memdesc:a5e2b044a6df7ad4656b15cba76fd628a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_explicitly_constructible::type. <br /></td></tr>
<tr class="separator:a5e2b044a6df7ad4656b15cba76fd628a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ae3cb969a9f236312da202205f3303"><td class="memTemplParams" colspan="2"><a id="a05ae3cb969a9f236312da202205f3303"></a>
template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:a05ae3cb969a9f236312da202205f3303"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a05ae3cb969a9f236312da202205f3303">is_explicitly_convertible_v</a> = <a class="el" href="../../de/d22/structbit_1_1core_1_1is__explicitly__convertible.html">is_explicitly_convertible</a>&lt;From,To&gt;::value</td></tr>
<tr class="memdesc:a05ae3cb969a9f236312da202205f3303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_explicitly_convertible::type. <br /></td></tr>
<tr class="separator:a05ae3cb969a9f236312da202205f3303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959b42b64bc9c938ec41cee362ba1496"><td class="memTemplParams" colspan="2"><a id="a959b42b64bc9c938ec41cee362ba1496"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a959b42b64bc9c938ec41cee362ba1496"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a959b42b64bc9c938ec41cee362ba1496">is_implicitly_constructible_v</a> = <a class="el" href="../../d3/df7/structbit_1_1core_1_1is__implicitly__constructible.html">is_implicitly_constructible</a>&lt;T,Args...&gt;::value</td></tr>
<tr class="memdesc:a959b42b64bc9c938ec41cee362ba1496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_implicitly_constructible::type. <br /></td></tr>
<tr class="separator:a959b42b64bc9c938ec41cee362ba1496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf2c0745e998ad12cd59874cb01432e"><td class="memTemplParams" colspan="2"><a id="a2bf2c0745e998ad12cd59874cb01432e"></a>
template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:a2bf2c0745e998ad12cd59874cb01432e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2bf2c0745e998ad12cd59874cb01432e">is_implicitly_convertible_v</a> = <a class="el" href="../../d6/d0b/structbit_1_1core_1_1is__implicitly__convertible.html">is_implicitly_convertible</a>&lt;From,To&gt;::value</td></tr>
<tr class="memdesc:a2bf2c0745e998ad12cd59874cb01432e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_implicitly_convertible::type. <br /></td></tr>
<tr class="separator:a2bf2c0745e998ad12cd59874cb01432e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997bbae74bdcda56360d83981f1586d1"><td class="memTemplParams" colspan="2"><a id="a997bbae74bdcda56360d83981f1586d1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a997bbae74bdcda56360d83981f1586d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_member_function_pointer_v</b> = <a class="el" href="../../d6/d5e/structbit_1_1core_1_1is__member__function__pointer.html">is_member_function_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a997bbae74bdcda56360d83981f1586d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4407daf9fa2b2e2328c436dd12d10e"><td class="memTemplParams" colspan="2"><a id="a5d4407daf9fa2b2e2328c436dd12d10e"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a5d4407daf9fa2b2e2328c436dd12d10e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>are_member_function_pointers_v</b> = <a class="el" href="../../d9/da8/structbit_1_1core_1_1are__member__function__pointers.html">are_member_function_pointers</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a5d4407daf9fa2b2e2328c436dd12d10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfa8cbe1b4145e339e60ad32c9ce1d2"><td class="memTemplParams" colspan="2"><a id="a3bfa8cbe1b4145e339e60ad32c9ce1d2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3bfa8cbe1b4145e339e60ad32c9ce1d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_member_object_pointer_v</b> = <a class="el" href="../../d4/d1a/structbit_1_1core_1_1is__member__object__pointer.html">is_member_object_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a3bfa8cbe1b4145e339e60ad32c9ce1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62d4e52488c5c539923bc3c800aaaa6"><td class="memTemplParams" colspan="2"><a id="ac62d4e52488c5c539923bc3c800aaaa6"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ac62d4e52488c5c539923bc3c800aaaa6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>are_member_object_pointer_v</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">are_member_object_pointers</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:ac62d4e52488c5c539923bc3c800aaaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1e04e80d39be7f95dc4f8bb69b0fa0"><td class="memTemplParams" colspan="2"><a id="a8e1e04e80d39be7f95dc4f8bb69b0fa0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e1e04e80d39be7f95dc4f8bb69b0fa0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_member_pointer_v</b> = <a class="el" href="../../d6/dfa/structbit_1_1core_1_1is__member__pointer.html">is_member_pointer</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8e1e04e80d39be7f95dc4f8bb69b0fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4134801d9c9bdc767e123b9f8a806d28"><td class="memTemplParams" colspan="2"><a id="a4134801d9c9bdc767e123b9f8a806d28"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a4134801d9c9bdc767e123b9f8a806d28"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>are_member_pointers_v</b> = <a class="el" href="../../da/df5/structbit_1_1core_1_1are__member__pointers.html">are_member_pointers</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a4134801d9c9bdc767e123b9f8a806d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f63eef47fb5f73de0cc7e022a72d12"><td class="memTemplParams" colspan="2"><a id="a30f63eef47fb5f73de0cc7e022a72d12"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30f63eef47fb5f73de0cc7e022a72d12"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a30f63eef47fb5f73de0cc7e022a72d12">is_move_assignable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3b9e46d169a187adb1a07e0531e8a01a">is_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a30f63eef47fb5f73de0cc7e022a72d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_move_assignable::type. <br /></td></tr>
<tr class="separator:a30f63eef47fb5f73de0cc7e022a72d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73daece793e52a8d8276b6f754851a6b"><td class="memTemplParams" colspan="2"><a id="a73daece793e52a8d8276b6f754851a6b"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a73daece793e52a8d8276b6f754851a6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a73daece793e52a8d8276b6f754851a6b">are_move_assignable_v</a> = <a class="el" href="../../d4/db4/structbit_1_1core_1_1are__move__assignable.html">are_move_assignable</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a73daece793e52a8d8276b6f754851a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_move_assignable::type. <br /></td></tr>
<tr class="separator:a73daece793e52a8d8276b6f754851a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6891a341cef56929a1399f1ff7502f"><td class="memTemplParams" colspan="2"><a id="aca6891a341cef56929a1399f1ff7502f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca6891a341cef56929a1399f1ff7502f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aca6891a341cef56929a1399f1ff7502f">is_move_constructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a65ffdda9ec7463844a64a48dfeef2483">is_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:aca6891a341cef56929a1399f1ff7502f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_move_constructible::type. <br /></td></tr>
<tr class="separator:aca6891a341cef56929a1399f1ff7502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c9a5ff8ca4747409f3c402494df474"><td class="memTemplParams" colspan="2"><a id="a19c9a5ff8ca4747409f3c402494df474"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a19c9a5ff8ca4747409f3c402494df474"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a19c9a5ff8ca4747409f3c402494df474">are_move_constructible_v</a> = <a class="el" href="../../d9/d6c/structbit_1_1core_1_1are__move__constructible.html">are_move_constructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a19c9a5ff8ca4747409f3c402494df474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_move_constructible::type. <br /></td></tr>
<tr class="separator:a19c9a5ff8ca4747409f3c402494df474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfd39e8336ee19b9eb0cc31ef5a170d"><td class="memTemplParams" colspan="2"><a id="a2dfd39e8336ee19b9eb0cc31ef5a170d"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a2dfd39e8336ee19b9eb0cc31ef5a170d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2dfd39e8336ee19b9eb0cc31ef5a170d">is_trivially_assignable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#af9a6053cdf318c66148e586dfef7530a">is_trivially_assignable</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:a2dfd39e8336ee19b9eb0cc31ef5a170d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_trivially_assignable::type. <br /></td></tr>
<tr class="separator:a2dfd39e8336ee19b9eb0cc31ef5a170d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881da33139d4821e638c05e794d901bc"><td class="memTemplParams" colspan="2"><a id="a881da33139d4821e638c05e794d901bc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a881da33139d4821e638c05e794d901bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a881da33139d4821e638c05e794d901bc">is_nothrow_copy_assignable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a4664ddec42d92eb0982bd8d2cbcd5a7e">is_nothrow_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a881da33139d4821e638c05e794d901bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_nothrow_copy_assignable::type. <br /></td></tr>
<tr class="separator:a881da33139d4821e638c05e794d901bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add00945525ecb472fe68bb187cf4447d"><td class="memTemplParams" colspan="2"><a id="add00945525ecb472fe68bb187cf4447d"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:add00945525ecb472fe68bb187cf4447d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#add00945525ecb472fe68bb187cf4447d">are_nothrow_copy_assignable_v</a> = <a class="el" href="../../d5/da4/structbit_1_1core_1_1are__nothrow__copy__assignable.html">are_nothrow_copy_assignable</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:add00945525ecb472fe68bb187cf4447d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_nothrow_copy_assignable::type. <br /></td></tr>
<tr class="separator:add00945525ecb472fe68bb187cf4447d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4df69a3a9bc98916ffef401ba7dc1c"><td class="memTemplParams" colspan="2"><a id="aef4df69a3a9bc98916ffef401ba7dc1c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef4df69a3a9bc98916ffef401ba7dc1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aef4df69a3a9bc98916ffef401ba7dc1c">is_nothrow_copy_constructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0a3c99e273941fc29f98f96f802f0a7d">is_nothrow_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:aef4df69a3a9bc98916ffef401ba7dc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_nothrow_copy_constructible::type. <br /></td></tr>
<tr class="separator:aef4df69a3a9bc98916ffef401ba7dc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9d00f203b237f2c130275b0281ebfd"><td class="memTemplParams" colspan="2"><a id="a6e9d00f203b237f2c130275b0281ebfd"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a6e9d00f203b237f2c130275b0281ebfd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a6e9d00f203b237f2c130275b0281ebfd">are_nothrow_copy_constructible_v</a> = <a class="el" href="../../d0/de2/structbit_1_1core_1_1are__nothrow__copy__constructible.html">are_nothrow_copy_constructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a6e9d00f203b237f2c130275b0281ebfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_nothrow_copy_constructible::type. <br /></td></tr>
<tr class="separator:a6e9d00f203b237f2c130275b0281ebfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9a749ec4add594ce8a940eb4f18e38"><td class="memTemplParams" colspan="2"><a id="a1b9a749ec4add594ce8a940eb4f18e38"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b9a749ec4add594ce8a940eb4f18e38"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1b9a749ec4add594ce8a940eb4f18e38">is_nothrow_default_constructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a504a07f5c7a1615c06c5a59162c09a00">is_nothrow_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a1b9a749ec4add594ce8a940eb4f18e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_nothrow_default_constructible::type. <br /></td></tr>
<tr class="separator:a1b9a749ec4add594ce8a940eb4f18e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e8fd4ae5e51cc03c9587e27535f1cc"><td class="memTemplParams" colspan="2"><a id="ac1e8fd4ae5e51cc03c9587e27535f1cc"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ac1e8fd4ae5e51cc03c9587e27535f1cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac1e8fd4ae5e51cc03c9587e27535f1cc">are_nothrow_default_constructible_v</a> = <a class="el" href="../../da/d8e/structbit_1_1core_1_1are__nothrow__default__constructible.html">are_nothrow_default_constructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:ac1e8fd4ae5e51cc03c9587e27535f1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_nothrow_default_constructible::type. <br /></td></tr>
<tr class="separator:ac1e8fd4ae5e51cc03c9587e27535f1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e69aa99ff270aefd15fd69f6b7f3d79"><td class="memTemplParams" colspan="2"><a id="a5e69aa99ff270aefd15fd69f6b7f3d79"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e69aa99ff270aefd15fd69f6b7f3d79"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a5e69aa99ff270aefd15fd69f6b7f3d79">is_nothrow_destructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae1ee3460c056151459089407d1194b64">is_nothrow_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a5e69aa99ff270aefd15fd69f6b7f3d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_nothrow_destructible::type. <br /></td></tr>
<tr class="separator:a5e69aa99ff270aefd15fd69f6b7f3d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab223a1292dc9f6c94d7bc8dabadffae7"><td class="memTemplParams" colspan="2"><a id="ab223a1292dc9f6c94d7bc8dabadffae7"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab223a1292dc9f6c94d7bc8dabadffae7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab223a1292dc9f6c94d7bc8dabadffae7">are_nothrow_destructible_v</a> = <a class="el" href="../../d6/d2e/structbit_1_1core_1_1are__nothrow__destructible.html">are_nothrow_destructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:ab223a1292dc9f6c94d7bc8dabadffae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_nothrow_destructible::type. <br /></td></tr>
<tr class="separator:ab223a1292dc9f6c94d7bc8dabadffae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e54689bfc039914ea208a3cedcbdce"><td class="memTemplParams" colspan="2"><a id="af8e54689bfc039914ea208a3cedcbdce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8e54689bfc039914ea208a3cedcbdce"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af8e54689bfc039914ea208a3cedcbdce">is_nothrow_move_assignable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9518a91a11b6a4140499d395f7dc608a">is_nothrow_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:af8e54689bfc039914ea208a3cedcbdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_nothrow_move_assignable::type. <br /></td></tr>
<tr class="separator:af8e54689bfc039914ea208a3cedcbdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6362aec4dee62ad2885b7de469c0e4"><td class="memTemplParams" colspan="2"><a id="a9f6362aec4dee62ad2885b7de469c0e4"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a9f6362aec4dee62ad2885b7de469c0e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9f6362aec4dee62ad2885b7de469c0e4">are_nothrow_move_assignable_v</a> = <a class="el" href="../../d8/d19/structbit_1_1core_1_1are__nothrow__move__assignable.html">are_nothrow_move_assignable</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a9f6362aec4dee62ad2885b7de469c0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_nothrow_move_assignable::type. <br /></td></tr>
<tr class="separator:a9f6362aec4dee62ad2885b7de469c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba28799dbb061c97406b02d81660dcd"><td class="memTemplParams" colspan="2"><a id="a3ba28799dbb061c97406b02d81660dcd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ba28799dbb061c97406b02d81660dcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3ba28799dbb061c97406b02d81660dcd">is_nothrow_move_constructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa2c2235981ef56c0ef0a7b2d56738f44">is_nothrow_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a3ba28799dbb061c97406b02d81660dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_nothrow_move_constructible::type. <br /></td></tr>
<tr class="separator:a3ba28799dbb061c97406b02d81660dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20030dc050ed33681a387133fc1dc18a"><td class="memTemplParams" colspan="2"><a id="a20030dc050ed33681a387133fc1dc18a"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a20030dc050ed33681a387133fc1dc18a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20030dc050ed33681a387133fc1dc18a">are_nothrow_move_constructible_v</a> = <a class="el" href="../../db/d41/structbit_1_1core_1_1are__nothrow__move__constructible.html">are_nothrow_move_constructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a20030dc050ed33681a387133fc1dc18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_nothrow_move_constructible::type. <br /></td></tr>
<tr class="separator:a20030dc050ed33681a387133fc1dc18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea7b2daad6c7edcf483afc92ef916a9"><td class="memTemplParams" colspan="2"><a id="aaea7b2daad6c7edcf483afc92ef916a9"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aaea7b2daad6c7edcf483afc92ef916a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aaea7b2daad6c7edcf483afc92ef916a9">is_nothrow_assignable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#adc1a797ea83fba610a8acdebdba7dafe">is_nothrow_assignable</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:aaea7b2daad6c7edcf483afc92ef916a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_nothrow_assignable::type. <br /></td></tr>
<tr class="separator:aaea7b2daad6c7edcf483afc92ef916a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547cb3560b50fb12afd34190010c8e9d"><td class="memTemplParams" colspan="2"><a id="a547cb3560b50fb12afd34190010c8e9d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a547cb3560b50fb12afd34190010c8e9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a547cb3560b50fb12afd34190010c8e9d">is_trivially_copy_assignable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0891f6958fb7737380699c4d05c4bf64">is_trivially_copy_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a547cb3560b50fb12afd34190010c8e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_trivially_copy_assignable::type. <br /></td></tr>
<tr class="separator:a547cb3560b50fb12afd34190010c8e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483451d579b1ec2e93ed0a2d23cdc6c9"><td class="memTemplParams" colspan="2"><a id="a483451d579b1ec2e93ed0a2d23cdc6c9"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a483451d579b1ec2e93ed0a2d23cdc6c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a483451d579b1ec2e93ed0a2d23cdc6c9">are_trivially_copy_assignable_v</a> = <a class="el" href="../../d8/dd7/structbit_1_1core_1_1are__trivially__copy__assignable.html">are_trivially_copy_assignable</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a483451d579b1ec2e93ed0a2d23cdc6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_trivially_copy_assignable::type. <br /></td></tr>
<tr class="separator:a483451d579b1ec2e93ed0a2d23cdc6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c27aab0d7bbb9b1c5d2a7e32603ec7"><td class="memTemplParams" colspan="2"><a id="a91c27aab0d7bbb9b1c5d2a7e32603ec7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91c27aab0d7bbb9b1c5d2a7e32603ec7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a91c27aab0d7bbb9b1c5d2a7e32603ec7">is_trivially_copy_constructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a09839e41c2608b206f4a02d43f28fd8f">is_trivially_copy_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a91c27aab0d7bbb9b1c5d2a7e32603ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_trivially_copy_constructible::type. <br /></td></tr>
<tr class="separator:a91c27aab0d7bbb9b1c5d2a7e32603ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620dc60e6e0493d684c722f84e5277ba"><td class="memTemplParams" colspan="2"><a id="a620dc60e6e0493d684c722f84e5277ba"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a620dc60e6e0493d684c722f84e5277ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a620dc60e6e0493d684c722f84e5277ba">are_trivially_copy_constructible_v</a> = <a class="el" href="../../dc/d34/structbit_1_1core_1_1are__trivially__copy__constructible.html">are_trivially_copy_constructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a620dc60e6e0493d684c722f84e5277ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_trivially_copy_constructible::type. <br /></td></tr>
<tr class="separator:a620dc60e6e0493d684c722f84e5277ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78f3228502966b24cb87eeea0b27c18"><td class="memTemplParams" colspan="2"><a id="ae78f3228502966b24cb87eeea0b27c18"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae78f3228502966b24cb87eeea0b27c18"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae78f3228502966b24cb87eeea0b27c18">is_trivially_default_constructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7aecfc9d5ab4fa42b6289b479b37739b">is_trivially_default_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ae78f3228502966b24cb87eeea0b27c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_trivially_default_constructible::type. <br /></td></tr>
<tr class="separator:ae78f3228502966b24cb87eeea0b27c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131a7298539ac1e1e9e21d08dcf598c8"><td class="memTemplParams" colspan="2"><a id="a131a7298539ac1e1e9e21d08dcf598c8"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a131a7298539ac1e1e9e21d08dcf598c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a131a7298539ac1e1e9e21d08dcf598c8">are_trivially_default_constructible_v</a> = <a class="el" href="../../df/d13/structbit_1_1core_1_1are__trivially__default__constructible.html">are_trivially_default_constructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a131a7298539ac1e1e9e21d08dcf598c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_trivially_default_constructible::type. <br /></td></tr>
<tr class="separator:a131a7298539ac1e1e9e21d08dcf598c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016b7301ceda205290551ddb07a3c9d6"><td class="memTemplParams" colspan="2"><a id="a016b7301ceda205290551ddb07a3c9d6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a016b7301ceda205290551ddb07a3c9d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a016b7301ceda205290551ddb07a3c9d6">is_trivially_destructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#aadc833e0cdfa1b9c18c112b5164239c7">is_trivially_destructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a016b7301ceda205290551ddb07a3c9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_trivially_destructible::type. <br /></td></tr>
<tr class="separator:a016b7301ceda205290551ddb07a3c9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d99e2b2369ea3d9558369bbd913368"><td class="memTemplParams" colspan="2"><a id="ac5d99e2b2369ea3d9558369bbd913368"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ac5d99e2b2369ea3d9558369bbd913368"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac5d99e2b2369ea3d9558369bbd913368">are_trivially_destructible_v</a> = <a class="el" href="../../d2/d81/structbit_1_1core_1_1are__trivially__destructible.html">are_trivially_destructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:ac5d99e2b2369ea3d9558369bbd913368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_trivially_destructible::type. <br /></td></tr>
<tr class="separator:ac5d99e2b2369ea3d9558369bbd913368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1e7c3d13038a1912b72c175ae191ea"><td class="memTemplParams" colspan="2"><a id="a7d1e7c3d13038a1912b72c175ae191ea"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d1e7c3d13038a1912b72c175ae191ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7d1e7c3d13038a1912b72c175ae191ea">is_trivially_move_assignable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a35d6085a41d33b8ab2f232ad21392982">is_trivially_move_assignable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a7d1e7c3d13038a1912b72c175ae191ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_trivially_move_assignable::type. <br /></td></tr>
<tr class="separator:a7d1e7c3d13038a1912b72c175ae191ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c249ac330a47dac2a3f0c7815660a14"><td class="memTemplParams" colspan="2"><a id="a7c249ac330a47dac2a3f0c7815660a14"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a7c249ac330a47dac2a3f0c7815660a14"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7c249ac330a47dac2a3f0c7815660a14">are_trivially_move_assignable_v</a> = <a class="el" href="../../dc/d61/structbit_1_1core_1_1are__trivially__move__assignable.html">are_trivially_move_assignable</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:a7c249ac330a47dac2a3f0c7815660a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_trivially_move_assignable::type. <br /></td></tr>
<tr class="separator:a7c249ac330a47dac2a3f0c7815660a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759beb6222ee0a125a98348ab0a81d05"><td class="memTemplParams" colspan="2"><a id="a759beb6222ee0a125a98348ab0a81d05"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a759beb6222ee0a125a98348ab0a81d05"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a759beb6222ee0a125a98348ab0a81d05">is_trivially_move_constructible_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a411d152531059e6b08c5dc21be658c43">is_trivially_move_constructible</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a759beb6222ee0a125a98348ab0a81d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_trivially_move_constructible::type. <br /></td></tr>
<tr class="separator:a759beb6222ee0a125a98348ab0a81d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed08767a2a1bb2a7ae6a92900febe6ff"><td class="memTemplParams" colspan="2"><a id="aed08767a2a1bb2a7ae6a92900febe6ff"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:aed08767a2a1bb2a7ae6a92900febe6ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aed08767a2a1bb2a7ae6a92900febe6ff">are_trivially_move_constructible_v</a> = <a class="el" href="../../d9/d90/structbit_1_1core_1_1are__trivially__move__constructible.html">are_trivially_move_constructible</a>&lt;Ts...&gt;::value</td></tr>
<tr class="memdesc:aed08767a2a1bb2a7ae6a92900febe6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_trivially_move_constructible::type. <br /></td></tr>
<tr class="separator:aed08767a2a1bb2a7ae6a92900febe6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6417314fc2bf51fb3f7ea0b0e4c593b"><td class="memTemplParams" colspan="2"><a id="aa6417314fc2bf51fb3f7ea0b0e4c593b"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:aa6417314fc2bf51fb3f7ea0b0e4c593b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa6417314fc2bf51fb3f7ea0b0e4c593b">is_volatile_member_function_pointer_v</a> = <a class="el" href="../../db/d02/structbit_1_1core_1_1is__volatile__member__function__pointer.html">is_volatile_member_function_pointer</a>&lt;Func&gt;::value</td></tr>
<tr class="memdesc:aa6417314fc2bf51fb3f7ea0b0e4c593b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_volatile_member_function_pointer::type. <br /></td></tr>
<tr class="separator:aa6417314fc2bf51fb3f7ea0b0e4c593b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12270c5a948b53535bb067bd91476fd3"><td class="memTemplParams" colspan="2"><a id="a12270c5a948b53535bb067bd91476fd3"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a12270c5a948b53535bb067bd91476fd3"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a12270c5a948b53535bb067bd91476fd3">arity_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/dff/structbit_1_1core_1_1arity">arity</a>&lt;Fn&gt;::value</td></tr>
<tr class="memdesc:a12270c5a948b53535bb067bd91476fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract arity::value. <br /></td></tr>
<tr class="separator:a12270c5a948b53535bb067bd91476fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ea633963d4b50252fea0cb4d2057dd"><td class="memTemplParams" colspan="2"><a id="a86ea633963d4b50252fea0cb4d2057dd"></a>
template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a86ea633963d4b50252fea0cb4d2057dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a86ea633963d4b50252fea0cb4d2057dd">index_of_type_v</a> = <a class="el" href="../../da/d2e/structbit_1_1core_1_1index__of__type.html">index_of_type</a>&lt;T,Types...&gt;::value</td></tr>
<tr class="memdesc:a86ea633963d4b50252fea0cb4d2057dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract index_of_type::value. <br /></td></tr>
<tr class="separator:a86ea633963d4b50252fea0cb4d2057dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c0538b0da94dfd71165142ff04b012"><td class="memTemplParams" colspan="2"><a id="ac5c0538b0da94dfd71165142ff04b012"></a>
template&lt;typename Base , typename... Derived&gt; </td></tr>
<tr class="memitem:ac5c0538b0da94dfd71165142ff04b012"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac5c0538b0da94dfd71165142ff04b012">is_base_of_all_v</a> = <a class="el" href="../../d4/d19/structbit_1_1core_1_1is__base__of__all.html">is_base_of_all</a>&lt;Base,Derived...&gt;::value</td></tr>
<tr class="memdesc:ac5c0538b0da94dfd71165142ff04b012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_base_of_all::value. <br /></td></tr>
<tr class="separator:ac5c0538b0da94dfd71165142ff04b012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ba30137ac3118bca9e7bdcacf5c633"><td class="memTemplParams" colspan="2"><a id="a55ba30137ac3118bca9e7bdcacf5c633"></a>
template&lt;typename Base , typename... Derived&gt; </td></tr>
<tr class="memitem:a55ba30137ac3118bca9e7bdcacf5c633"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a55ba30137ac3118bca9e7bdcacf5c633">is_base_of_any_v</a> = <a class="el" href="../../d1/d80/structbit_1_1core_1_1is__base__of__any.html">is_base_of_any</a>&lt;Base,Derived...&gt;::value</td></tr>
<tr class="memdesc:a55ba30137ac3118bca9e7bdcacf5c633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_base_of_any::value. <br /></td></tr>
<tr class="separator:a55ba30137ac3118bca9e7bdcacf5c633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bd102270b2672061a1eefe370fb609"><td class="memTemplParams" colspan="2"><a id="ae3bd102270b2672061a1eefe370fb609"></a>
template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:ae3bd102270b2672061a1eefe370fb609"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae3bd102270b2672061a1eefe370fb609">is_derived_from_all_v</a> = <a class="el" href="../../de/d3b/structbit_1_1core_1_1is__derived__from__all.html">is_derived_from_all</a>&lt;Derived,Bases...&gt;::value</td></tr>
<tr class="memdesc:ae3bd102270b2672061a1eefe370fb609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_derived_from_all::value. <br /></td></tr>
<tr class="separator:ae3bd102270b2672061a1eefe370fb609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e276c577590b309e86ef44cb61c4cd"><td class="memTemplParams" colspan="2"><a id="af3e276c577590b309e86ef44cb61c4cd"></a>
template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:af3e276c577590b309e86ef44cb61c4cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af3e276c577590b309e86ef44cb61c4cd">is_derived_from_any_v</a> = <a class="el" href="../../d4/d67/structbit_1_1core_1_1is__derived__from__any.html">is_derived_from_any</a>&lt;Derived,Bases...&gt;::value</td></tr>
<tr class="memdesc:af3e276c577590b309e86ef44cb61c4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_derived_from_any::value. <br /></td></tr>
<tr class="separator:af3e276c577590b309e86ef44cb61c4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9305b8426143917048febe7a2c696474"><td class="memTemplParams" colspan="2"><a id="a9305b8426143917048febe7a2c696474"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9305b8426143917048febe7a2c696474"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9305b8426143917048febe7a2c696474">is_different_v</a> = <a class="el" href="../../dd/d22/structbit_1_1core_1_1is__different.html">is_different</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:a9305b8426143917048febe7a2c696474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_different::type. <br /></td></tr>
<tr class="separator:a9305b8426143917048febe7a2c696474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad1f334ece99c1b96f894ae46d2b1c8"><td class="memTemplParams" colspan="2"><a id="a2ad1f334ece99c1b96f894ae46d2b1c8"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a2ad1f334ece99c1b96f894ae46d2b1c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2ad1f334ece99c1b96f894ae46d2b1c8">are_different_v</a> = <a class="el" href="../../d7/d9d/structbit_1_1core_1_1are__different.html">are_different</a>&lt;T,Ts...&gt;::value</td></tr>
<tr class="memdesc:a2ad1f334ece99c1b96f894ae46d2b1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_different::value. <br /></td></tr>
<tr class="separator:a2ad1f334ece99c1b96f894ae46d2b1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb7a0f1d35450baa3bac9124bf285c9"><td class="memTemplParams" colspan="2"><a id="a6bb7a0f1d35450baa3bac9124bf285c9"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a6bb7a0f1d35450baa3bac9124bf285c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a6bb7a0f1d35450baa3bac9124bf285c9">is_one_of_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d6/dd9/structbit_1_1core_1_1is__one__of">is_one_of</a>&lt;T,Ts...&gt;::value</td></tr>
<tr class="memdesc:a6bb7a0f1d35450baa3bac9124bf285c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_one_of::value. <br /></td></tr>
<tr class="separator:a6bb7a0f1d35450baa3bac9124bf285c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f05e752df16f154b333260f13cc62e"><td class="memTemplParams" colspan="2"><a id="ab3f05e752df16f154b333260f13cc62e"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab3f05e752df16f154b333260f13cc62e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab3f05e752df16f154b333260f13cc62e">is_same_v</a> = <a class="el" href="../../d5/d3d/structbit_1_1core_1_1is__same.html">is_same</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:ab3f05e752df16f154b333260f13cc62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same::type. <br /></td></tr>
<tr class="separator:ab3f05e752df16f154b333260f13cc62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519abec2b435ffe93ec50ac67420ed19"><td class="memTemplParams" colspan="2"><a id="a519abec2b435ffe93ec50ac67420ed19"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a519abec2b435ffe93ec50ac67420ed19"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a519abec2b435ffe93ec50ac67420ed19">are_same_v</a> = <a class="el" href="../../d0/dbf/structbit_1_1core_1_1are__same.html">are_same</a>&lt;T,Ts...&gt;::value</td></tr>
<tr class="memdesc:a519abec2b435ffe93ec50ac67420ed19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_same::value. <br /></td></tr>
<tr class="separator:a519abec2b435ffe93ec50ac67420ed19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7abac39f91c4926afa44e17c4f874fb"><td class="memTemplParams" colspan="2"><a id="ab7abac39f91c4926afa44e17c4f874fb"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab7abac39f91c4926afa44e17c4f874fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab7abac39f91c4926afa44e17c4f874fb">is_same_constness_v</a> = <a class="el" href="../../d8/d31/structbit_1_1core_1_1is__same__constness.html">is_same_constness</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:ab7abac39f91c4926afa44e17c4f874fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_constness::value. <br /></td></tr>
<tr class="separator:ab7abac39f91c4926afa44e17c4f874fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c690e61f158b8012e5bc3fdf71c5fe"><td class="memTemplParams" colspan="2"><a id="af7c690e61f158b8012e5bc3fdf71c5fe"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af7c690e61f158b8012e5bc3fdf71c5fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af7c690e61f158b8012e5bc3fdf71c5fe">is_same_cv_v</a> = <a class="el" href="../../de/da4/structbit_1_1core_1_1is__same__cv.html">is_same_cv</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:af7c690e61f158b8012e5bc3fdf71c5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_cv::value. <br /></td></tr>
<tr class="separator:af7c690e61f158b8012e5bc3fdf71c5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45d406edbc650a31682f8404274ea50"><td class="memTemplParams" colspan="2"><a id="aa45d406edbc650a31682f8404274ea50"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa45d406edbc650a31682f8404274ea50"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa45d406edbc650a31682f8404274ea50">is_same_decay_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#af7924cb4fc7b33d936c69ee41387e639">is_same_decay</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:aa45d406edbc650a31682f8404274ea50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_decay::value. <br /></td></tr>
<tr class="separator:aa45d406edbc650a31682f8404274ea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32db67b570948ac266d7fc721a1b4788"><td class="memTemplParams" colspan="2"><a id="a32db67b570948ac266d7fc721a1b4788"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a32db67b570948ac266d7fc721a1b4788"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a32db67b570948ac266d7fc721a1b4788">is_same_sign_v</a> = <a class="el" href="../../db/d13/structbit_1_1core_1_1is__same__sign.html">is_same_sign</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:a32db67b570948ac266d7fc721a1b4788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_sign::value. <br /></td></tr>
<tr class="separator:a32db67b570948ac266d7fc721a1b4788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4323a1c06d4153597fd9b85f2156779"><td class="memTemplParams" colspan="2"><a id="af4323a1c06d4153597fd9b85f2156779"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af4323a1c06d4153597fd9b85f2156779"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af4323a1c06d4153597fd9b85f2156779">is_same_volatility_v</a> = <a class="el" href="../../db/d33/structbit_1_1core_1_1is__same__volatility.html">is_same_volatility</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:af4323a1c06d4153597fd9b85f2156779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_volatility::value. <br /></td></tr>
<tr class="separator:af4323a1c06d4153597fd9b85f2156779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0107ebf3367394b7d6431490b4f2242a"><td class="memTemplParams" colspan="2"><a id="a0107ebf3367394b7d6431490b4f2242a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0107ebf3367394b7d6431490b4f2242a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0107ebf3367394b7d6431490b4f2242a">pointer_rank_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac1cb0729bdcb141e7590869875942b1e">pointer_rank</a>&lt; std::decay_t&lt;T&gt; &gt;::value</td></tr>
<tr class="memdesc:a0107ebf3367394b7d6431490b4f2242a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract pointer_rank::value. <br /></td></tr>
<tr class="separator:a0107ebf3367394b7d6431490b4f2242a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037cb03b01d3f2829dd62b312121d62d"><td class="memTemplParams" colspan="2"><a id="a037cb03b01d3f2829dd62b312121d62d"></a>
template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a037cb03b01d3f2829dd62b312121d62d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a037cb03b01d3f2829dd62b312121d62d">resolves_overload_index_v</a> = <a class="el" href="../../d2/d35/structbit_1_1core_1_1resolves__overload__index.html">resolves_overload_index</a>&lt;T,Types...&gt;::value</td></tr>
<tr class="memdesc:a037cb03b01d3f2829dd62b312121d62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract resolves_overload_index::value. <br /></td></tr>
<tr class="separator:a037cb03b01d3f2829dd62b312121d62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f4c070ecfd18512f085e031d7ce5cd"><td class="memItemLeft" align="right" valign="top"><a id="ab4f4c070ecfd18512f085e031d7ce5cd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>max_align</b> = alignof(std::max_align_t)</td></tr>
<tr class="separator:ab4f4c070ecfd18512f085e031d7ce5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b62f3459d1bb35b34f09e6ebc30073"><td class="memTemplParams" colspan="2"><a id="ac5b62f3459d1bb35b34f09e6ebc30073"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5b62f3459d1bb35b34f09e6ebc30073"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_expected_v</b> = <a class="el" href="../../d0/db9/structbit_1_1core_1_1is__expected.html">is_expected</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ac5b62f3459d1bb35b34f09e6ebc30073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8e00b64ad5a5081009d2f480740531"><td class="memTemplParams" colspan="2"><a id="a1f8e00b64ad5a5081009d2f480740531"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f8e00b64ad5a5081009d2f480740531"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_unexpected_type_v</b> = <a class="el" href="../../d4/d39/structbit_1_1core_1_1is__unexpected__type.html">is_unexpected_type</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a1f8e00b64ad5a5081009d2f480740531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9670e86a92f14a7979cee07fdd816718"><td class="memItemLeft" align="right" valign="top"><a id="a9670e86a92f14a7979cee07fdd816718"></a>
constexpr <a class="el" href="../../d7/dd6/structbit_1_1core_1_1unexpect__t.html">unexpect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unexpect</b> {0}</td></tr>
<tr class="separator:a9670e86a92f14a7979cee07fdd816718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa388f309c7f89c5953cf902f2144fd18"><td class="memTemplParams" colspan="2"><a id="aa388f309c7f89c5953cf902f2144fd18"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa388f309c7f89c5953cf902f2144fd18"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa388f309c7f89c5953cf902f2144fd18">is_hashable_v</a> = <a class="el" href="../../d4/d35/structbit_1_1core_1_1is__hashable.html">is_hashable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:aa388f309c7f89c5953cf902f2144fd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience utility for extracting <code>::value</code> from <code><a class="el" href="../../d4/d35/structbit_1_1core_1_1is__hashable.html" title="Trait determining whether T is hashable by an ADL call to hash_value. ">is_hashable</a></code>. <br /></td></tr>
<tr class="separator:aa388f309c7f89c5953cf902f2144fd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db5b2ec9a596ae5db30151d0bcffdd8"><td class="memTemplParams" colspan="2"><a id="a7db5b2ec9a596ae5db30151d0bcffdd8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7db5b2ec9a596ae5db30151d0bcffdd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7db5b2ec9a596ae5db30151d0bcffdd8">is_nothrow_hashable_v</a> = <a class="el" href="../../df/d0a/structbit_1_1core_1_1is__nothrow__hashable.html">is_nothrow_hashable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a7db5b2ec9a596ae5db30151d0bcffdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience utility for extracting <code>::value</code> from <code><a class="el" href="../../df/d0a/structbit_1_1core_1_1is__nothrow__hashable.html" title="Trait determining whether T is nothrow hashable by an ADL call to hash_value. ">is_nothrow_hashable</a></code>. <br /></td></tr>
<tr class="separator:a7db5b2ec9a596ae5db30151d0bcffdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d18a05660bd961fbe74bbe098351c9"><td class="memItemLeft" align="right" valign="top"><a id="a17d18a05660bd961fbe74bbe098351c9"></a>
constexpr <a class="el" href="../../dd/d6f/structbit_1_1core_1_1in__place__t.html">in_place_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>in_place</b> {}</td></tr>
<tr class="separator:a17d18a05660bd961fbe74bbe098351c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64d666cbc2d92575f5edcd31253651b"><td class="memTemplParams" colspan="2"><a id="af64d666cbc2d92575f5edcd31253651b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af64d666cbc2d92575f5edcd31253651b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../da/dcd/structbit_1_1core_1_1in__place__type__t.html">in_place_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>in_place_type</b> {}</td></tr>
<tr class="separator:af64d666cbc2d92575f5edcd31253651b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ddcc7c89e2e7e1798d44a89b43e6c9"><td class="memTemplParams" colspan="2"><a id="a67ddcc7c89e2e7e1798d44a89b43e6c9"></a>
template&lt;std::size_t I&gt; </td></tr>
<tr class="memitem:a67ddcc7c89e2e7e1798d44a89b43e6c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d71/structbit_1_1core_1_1in__place__index__t.html">in_place_index_t</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>in_place_index</b> {}</td></tr>
<tr class="separator:a67ddcc7c89e2e7e1798d44a89b43e6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566f78d23dca39d1b1ca532099e24e60"><td class="memTemplParams" colspan="2"><a id="a566f78d23dca39d1b1ca532099e24e60"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a566f78d23dca39d1b1ca532099e24e60"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_in_place_v</b> = <a class="el" href="../../d3/d5a/structbit_1_1core_1_1is__in__place.html">is_in_place</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a566f78d23dca39d1b1ca532099e24e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ab3566f1ab55d339393ac3ab75718c"><td class="memTemplParams" colspan="2"><a id="a79ab3566f1ab55d339393ac3ab75718c"></a>
template&lt;typename Fn , typename... Args&gt; </td></tr>
<tr class="memitem:a79ab3566f1ab55d339393ac3ab75718c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a79ab3566f1ab55d339393ac3ab75718c">is_invocable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2c7a0ee5776e985bbaa3871d7947550a">is_invocable</a>&lt;Fn,Args...&gt;::value</td></tr>
<tr class="memdesc:a79ab3566f1ab55d339393ac3ab75718c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait helper to retrieve the <code>::value</code> of is_invokable. <br /></td></tr>
<tr class="separator:a79ab3566f1ab55d339393ac3ab75718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30f3fcc80108fbeef4a681ac9a756c7"><td class="memTemplParams" colspan="2"><a id="ab30f3fcc80108fbeef4a681ac9a756c7"></a>
template&lt;typename Fn , typename... Args&gt; </td></tr>
<tr class="memitem:ab30f3fcc80108fbeef4a681ac9a756c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab30f3fcc80108fbeef4a681ac9a756c7">is_nothrow_invocable_v</a> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#afc6dcf0031b078fd8c7c65479ffe687f">is_nothrow_invocable</a>&lt;Fn,Args...&gt;::value</td></tr>
<tr class="memdesc:ab30f3fcc80108fbeef4a681ac9a756c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait helper to retrieve the <code>::value</code> of is_nothrow_invokable. <br /></td></tr>
<tr class="separator:ab30f3fcc80108fbeef4a681ac9a756c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dba6f1c96d4ddef129cfa7c7a5f798"><td class="memTemplParams" colspan="2"><a id="a48dba6f1c96d4ddef129cfa7c7a5f798"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48dba6f1c96d4ddef129cfa7c7a5f798"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_optional_v</b> = <a class="el" href="../../db/d51/structbit_1_1core_1_1is__optional.html">is_optional</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a48dba6f1c96d4ddef129cfa7c7a5f798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5c5312597a2acf78b217a1df8ae181"><td class="memItemLeft" align="right" valign="top"><a id="a1f5c5312597a2acf78b217a1df8ae181"></a>
constexpr <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1f5c5312597a2acf78b217a1df8ae181">nullopt</a> = <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>{0}</td></tr>
<tr class="memdesc:a1f5c5312597a2acf78b217a1df8ae181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a nullopt type. <br /></td></tr>
<tr class="separator:a1f5c5312597a2acf78b217a1df8ae181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c49e9493ea5186f410b84556027cb4"><td class="memTemplParams" colspan="2"><a id="a99c49e9493ea5186f410b84556027cb4"></a>
template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:a99c49e9493ea5186f410b84556027cb4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9f00998a640da450aa5f238835e7be8a">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_size_v</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d1/de5/structbit_1_1core_1_1tuple__size">tuple_size</a>&lt;Tuple&gt;::value</td></tr>
<tr class="separator:a99c49e9493ea5186f410b84556027cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffb727c1712c25af014927b51625d77"><td class="memTemplParams" colspan="2"><a id="acffb727c1712c25af014927b51625d77"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acffb727c1712c25af014927b51625d77"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9f00998a640da450aa5f238835e7be8a">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#acffb727c1712c25af014927b51625d77">variant_size_v</a> = <a class="el" href="../../d1/d64/structbit_1_1core_1_1variant__size.html">variant_size</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:acffb727c1712c25af014927b51625d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template for extracting <code>variant_size&lt;T&gt;::value</code>. <br /></td></tr>
<tr class="separator:acffb727c1712c25af014927b51625d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70437882308ad3ab280dd4653850037"><td class="memItemLeft" align="right" valign="top"><a id="ad70437882308ad3ab280dd4653850037"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad70437882308ad3ab280dd4653850037">variant_npos</a> = std::size_t(-1)</td></tr>
<tr class="memdesc:ad70437882308ad3ab280dd4653850037"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special value equal to the largest value representable by the type std::size_t, used as the return type of index() when valueless_by_exception() is true. <br /></td></tr>
<tr class="separator:ad70437882308ad3ab280dd4653850037"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The standard namespace for this project. </p>
<p>Every class, free function, and sub-namespace will be defined inside of this namespace. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="d0/dd3/structbit_1_1core_1_1aligned__storage" id="d0/dd3/structbit_1_1core_1_1aligned__storage"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d0/dd3/structbit_1_1core_1_1aligned__storage">&#9670;&nbsp;</a></span>bit::core::aligned_storage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::aligned_storage</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t Len, std::size_t Align = max_align&gt;<br />
struct bit::core::aligned_storage&lt; Len, Align &gt;</h3>

<p>Provides the nested type type, which is a PODType suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align. </p>
<p>The default value of Align is the most stringent (the largest) alignment requirement for any object whose size is at most Len. If the default value is not used, Align must be the value of alignof(T) for some type T, or the behavior is undefined.</p>
<p>The behavior is undefined if Len == 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Len</td><td>the length of the storage </td></tr>
    <tr><td class="paramname">Align</td><td>the alignment of the storage </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/de5/aligned__storage_8hpp_source.html#l00084">84</a> of file <a class="el" href="../../d7/de5/aligned__storage_8hpp_source.html">aligned_storage.hpp</a>.</p>
</div>
</div>
</div>
<a name="d0/dff/structbit_1_1core_1_1arity" id="d0/dff/structbit_1_1core_1_1arity"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d0/dff/structbit_1_1core_1_1arity">&#9670;&nbsp;</a></span>bit::core::arity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::arity</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Fn&gt;<br />
struct bit::core::arity&lt; Fn &gt;</h3>

<p>Type-trait to determine the arity of a function. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d8e/arity_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d9/d8e/arity_8hpp_source.html">arity.hpp</a>.</p>
</div>
</div>
</div>
<a name="d7/d95/structbit_1_1core_1_1conjunction" id="d7/d95/structbit_1_1core_1_1conjunction"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d7/d95/structbit_1_1core_1_1conjunction">&#9670;&nbsp;</a></span>bit::core::conjunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::conjunction</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename...&gt;<br />
struct bit::core::conjunction&lt;... &gt;</h3>

<p>Type trait to determine the <a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html" title="This utility metafunction provides compile-time boolean values as an integral constant. ">bool_constant</a> from a logical AND operation of other bool_constants. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../df/d80/conjunction_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../df/d80/conjunction_8hpp_source.html">conjunction.hpp</a>.</p>
</div>
</div>
</div>
<a name="d0/df2/classbit_1_1core_1_1delegate" id="d0/df2/classbit_1_1core_1_1delegate"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d0/df2/classbit_1_1core_1_1delegate">&#9670;&nbsp;</a></span>bit::core::delegate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class bit::core::delegate</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Fn&gt;<br />
class bit::core::delegate&lt; Fn &gt;</h3>

<p>This class is for a lightweight way of managing function callbacks without requiring heap allocations. </p>
<p>The syntax for binding functions requires statically specifying the function address and, in the case of member functions, the type of the class. This is due to a limitation in the (pre-c++14) deduction system.</p>
<dl class="section note"><dt>Note</dt><dd>Since delegates deal with statically typed member function pointers, they cannot be used with lambdas. The pointer-to-function must be able to be retrieved statically (e.g. at constexpr time), which is something not possible until C++17 with constexpr lambdas. Additionally, since delegates are statically-bound, they cannot bind to functors, since that requires additional storage that is otherwise not possible.</dd></dl>
<p>Example </p><div class="fragment"><div class="line">Delegate&lt;void()&gt; delegate;</div><div class="line">T       t;</div><div class="line"><span class="keyword">const</span> T ct;</div><div class="line"></div><div class="line">delegate.bind&lt;&amp;foo&gt;();           <span class="comment">// bind function</span></div><div class="line">delegate.bind&lt;&amp;T::static_foo&gt;(); <span class="comment">// bind static member function</span></div><div class="line">delegate.bind&lt;T,&amp;T::foo&gt;( &amp;t );  <span class="comment">// bind member functions</span></div><div class="line">delegate.bind&lt;T,&amp;T::foo&gt;( &amp;ct ); <span class="comment">// bind const member function</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Fn</td><td>signature and return type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d68/delegate_8hpp_source.html#l00086">86</a> of file <a class="el" href="../../d0/d68/delegate_8hpp_source.html">delegate.hpp</a>.</p>
</div>
</div>
</div>
<a name="d7/d04/structbit_1_1core_1_1disable__if_3_01true_00_01_t_01_4" id="d7/d04/structbit_1_1core_1_1disable__if_3_01true_00_01_t_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d7/d04/structbit_1_1core_1_1disable__if_3_01true_00_01_t_01_4">&#9670;&nbsp;</a></span>bit::core::disable_if&lt; true, T &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::disable_if&lt; true, T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct bit::core::disable_if&lt; true, T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d5/da8/sfinae_8hpp_source.html#l00074">74</a> of file <a class="el" href="../../d5/da8/sfinae_8hpp_source.html">sfinae.hpp</a>.</p>
</div>
</div>
</div>
<a name="dc/d3e/structbit_1_1core_1_1empty" id="dc/d3e/structbit_1_1core_1_1empty"></a>
<h2 class="memtitle"><span class="permalink"><a href="#dc/d3e/structbit_1_1core_1_1empty">&#9670;&nbsp;</a></span>bit::core::empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::empty</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T = void&gt;<br />
struct bit::core::empty&lt; T &gt;</h3>

<p>Utility metafunction that always expands into an empty struct with no members or type members. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/da4/empty_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../d8/da4/empty_8hpp_source.html">empty.hpp</a>.</p>
</div>
</div>
</div>
<a name="d0/de6/structbit_1_1core_1_1enable__if_3_01false_00_01_t_01_4" id="d0/de6/structbit_1_1core_1_1enable__if_3_01false_00_01_t_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d0/de6/structbit_1_1core_1_1enable__if_3_01false_00_01_t_01_4">&#9670;&nbsp;</a></span>bit::core::enable_if&lt; false, T &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::enable_if&lt; false, T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct bit::core::enable_if&lt; false, T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d5/da8/sfinae_8hpp_source.html#l00063">63</a> of file <a class="el" href="../../d5/da8/sfinae_8hpp_source.html">sfinae.hpp</a>.</p>
</div>
</div>
</div>
<a name="dc/d0a/structbit_1_1core_1_1enable__overload__if_3_01false_00_01_t_01_4" id="dc/d0a/structbit_1_1core_1_1enable__overload__if_3_01false_00_01_t_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#dc/d0a/structbit_1_1core_1_1enable__overload__if_3_01false_00_01_t_01_4">&#9670;&nbsp;</a></span>bit::core::enable_overload_if&lt; false, T &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::enable_overload_if&lt; false, T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct bit::core::enable_overload_if&lt; false, T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d5/da8/sfinae_8hpp_source.html#l00092">92</a> of file <a class="el" href="../../d5/da8/sfinae_8hpp_source.html">sfinae.hpp</a>.</p>
</div>
</div>
</div>
<a name="dc/d21/structbit_1_1core_1_1function__argument" id="dc/d21/structbit_1_1core_1_1function__argument"></a>
<h2 class="memtitle"><span class="permalink"><a href="#dc/d21/structbit_1_1core_1_1function__argument">&#9670;&nbsp;</a></span>bit::core::function_argument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::function_argument</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t I, typename Fn&gt;<br />
struct bit::core::function_argument&lt; I, Fn &gt;</h3>

<p>Type-trait to access the <code>Ith</code> argument type of a given function. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../de/d3a/function__argument_8hpp_source.html#l00052">52</a> of file <a class="el" href="../../de/d3a/function__argument_8hpp_source.html">function_argument.hpp</a>.</p>
</div>
</div>
</div>
<a name="d1/d73/structbit_1_1core_1_1function__signature" id="d1/d73/structbit_1_1core_1_1function__signature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d1/d73/structbit_1_1core_1_1function__signature">&#9670;&nbsp;</a></span>bit::core::function_signature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::function_signature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Fn&gt;<br />
struct bit::core::function_signature&lt; Fn &gt;</h3>

<p>Metafunction to extract the signature of a given function type. </p>
<p>The result is aliased as <code>::type</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">fn</td><td>the function to check </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d3b/function__signature_8hpp_source.html#l00053">53</a> of file <a class="el" href="../../d5/d3b/function__signature_8hpp_source.html">function_signature.hpp</a>.</p>
</div>
</div>
</div>
<a name="d6/dd9/structbit_1_1core_1_1is__one__of" id="d6/dd9/structbit_1_1core_1_1is__one__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d6/dd9/structbit_1_1core_1_1is__one__of">&#9670;&nbsp;</a></span>bit::core::is_one_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::is_one_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename... Ts&gt;<br />
struct bit::core::is_one_of&lt; T, Ts &gt;</h3>

<p>Type-trait to determine if <code>T</code> is one of <code>Ts</code>. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d0/def/is__one__of_8hpp_source.html#l00049">49</a> of file <a class="el" href="../../d0/def/is__one__of_8hpp_source.html">is_one_of.hpp</a>.</p>
</div>
</div>
</div>
<a name="da/d3a/structbit_1_1core_1_1monostate" id="da/d3a/structbit_1_1core_1_1monostate"></a>
<h2 class="memtitle"><span class="permalink"><a href="#da/d3a/structbit_1_1core_1_1monostate">&#9670;&nbsp;</a></span>bit::core::monostate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::monostate</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Unit type intended for use as a well-behaved empty alternative in <code>variant</code>. </p>
<p>In particular, a variant of non-default-constructible types may list monostate as its first alternative: this makes the variant itself default-constructible. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/df0/monostate_8hpp_source.html#l00058">58</a> of file <a class="el" href="../../d0/df0/monostate_8hpp_source.html">monostate.hpp</a>.</p>
</div>
</div>
</div>
<a name="d7/dd8/structbit_1_1core_1_1normalize__char" id="d7/dd8/structbit_1_1core_1_1normalize__char"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d7/dd8/structbit_1_1core_1_1normalize__char">&#9670;&nbsp;</a></span>bit::core::normalize_char</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::normalize_char</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct bit::core::normalize_char&lt; T &gt;</h3>

<p>Normalizes character types T to non-signed/unsigned character types. </p>
<p>The result is aliased as  ::type</p>
<dl class="section note"><dt>Note</dt><dd>The result is undefined for anything that is not a char-type </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/d43/normalize__char_8hpp_source.html#l00052">52</a> of file <a class="el" href="../../dd/d43/normalize__char_8hpp_source.html">normalize_char.hpp</a>.</p>
</div>
</div>
</div>
<a name="d8/d34/structbit_1_1core_1_1nth__type" id="d8/d34/structbit_1_1core_1_1nth__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d8/d34/structbit_1_1core_1_1nth__type">&#9670;&nbsp;</a></span>bit::core::nth_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::nth_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t I, typename... Types&gt;<br />
struct bit::core::nth_type&lt; I, Types &gt;</h3>

<p>Type-trait for extracting the <code>Ith</code> type from a variadic pack. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../dc/d01/nth__type_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../dc/d01/nth__type_8hpp_source.html">nth_type.hpp</a>.</p>
</div>
</div>
</div>
<a name="db/d9c/structbit_1_1core_1_1nth__type_3_010_01_4" id="db/d9c/structbit_1_1core_1_1nth__type_3_010_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#db/d9c/structbit_1_1core_1_1nth__type_3_010_01_4">&#9670;&nbsp;</a></span>bit::core::nth_type&lt; 0 &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::nth_type&lt; 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;&gt;<br />
struct bit::core::nth_type&lt; 0 &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../dc/d01/nth__type_8hpp_source.html#l00057">57</a> of file <a class="el" href="../../dc/d01/nth__type_8hpp_source.html">nth_type.hpp</a>.</p>
</div>
</div>
</div>
<a name="db/d50/structbit_1_1core_1_1sfinae__base" id="db/d50/structbit_1_1core_1_1sfinae__base"></a>
<h2 class="memtitle"><span class="permalink"><a href="#db/d50/structbit_1_1core_1_1sfinae__base">&#9670;&nbsp;</a></span>bit::core::sfinae_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::sfinae_base</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Base class for sfinae types. </p>

<p class="definition">Definition at line <a class="el" href="../../d5/da8/sfinae_8hpp_source.html#l00046">46</a> of file <a class="el" href="../../d5/da8/sfinae_8hpp_source.html">sfinae.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aaae573381c76657ba4d5c04c82082d97"></a>typedef char(&amp;)[4]</td>
<td class="fieldname">
no_type</td>
<td class="fielddoc">
Type corresponding to no (is not) instances using SFINAE. <dl class="section note"><dt>Note</dt><dd>bit::no_type is guaranteed to be a different size than bit::yes_type </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a06b7dc9648c6d3310f6707b170f77155"></a>typedef char(&amp;)[1]</td>
<td class="fieldname">
yes_type</td>
<td class="fielddoc">
Type corresponding to yes (is) instances using SFINAE. <dl class="section note"><dt>Note</dt><dd>bit::yes_type is guaranteed to be a different size than bit::no_type </dd></dl>
</td></tr>
</table>

</div>
</div>
<a name="df/d18/structbit_1_1core_1_1tuple__element" id="df/d18/structbit_1_1core_1_1tuple__element"></a>
<h2 class="memtitle"><span class="permalink"><a href="#df/d18/structbit_1_1core_1_1tuple__element">&#9670;&nbsp;</a></span>bit::core::tuple_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::tuple_element</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;size_t I, typename Tuple&gt;<br />
struct bit::core::tuple_element&lt; I, Tuple &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d1/db5/tuple__utilities_8hpp_source.html#l00066">66</a> of file <a class="el" href="../../d1/db5/tuple__utilities_8hpp_source.html">tuple_utilities.hpp</a>.</p>
</div>
</div>
</div>
<a name="d1/de5/structbit_1_1core_1_1tuple__size" id="d1/de5/structbit_1_1core_1_1tuple__size"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d1/de5/structbit_1_1core_1_1tuple__size">&#9670;&nbsp;</a></span>bit::core::tuple_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::tuple_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Tuple&gt;<br />
struct bit::core::tuple_size&lt; Tuple &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d1/db5/tuple__utilities_8hpp_source.html#l00058">58</a> of file <a class="el" href="../../d1/db5/tuple__utilities_8hpp_source.html">tuple_utilities.hpp</a>.</p>
</div>
</div>
</div>
<a name="d7/dc5/structbit_1_1core_1_1type__list" id="d7/dc5/structbit_1_1core_1_1type__list"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d7/dc5/structbit_1_1core_1_1type__list">&#9670;&nbsp;</a></span>bit::core::type_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::type_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename... Types&gt;<br />
struct bit::core::type_list&lt; Types &gt;</h3>

<p>A utility metafunction for encoding a sequence of types into a single unique type. </p>
<p>This is used for packing multiple types into one as a template argument, for expansion later. This can be used to support multiple variadic sets in a single template. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/da7/type__list_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d8/da7/type__list_8hpp_source.html">type_list.hpp</a>.</p>
</div>
</div>
</div>
<a name="d7/d3c/classbit_1_1core_1_1underlying__container__type" id="d7/d3c/classbit_1_1core_1_1underlying__container__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d7/d3c/classbit_1_1core_1_1underlying__container__type">&#9670;&nbsp;</a></span>bit::core::underlying_container_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class bit::core::underlying_container_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class bit::core::underlying_container_type&lt; T &gt;</h3>

<p>Gets the underlying container type of any container adapter. </p>
<p>The result is aliased as <code>::type</code> </p>
<p>If <code>T</code> is not a container adapter, <code>::type</code> is not defined to allow for SFINAE</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the container adapter type to extract the underlying type from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d43/container__utilities_8hpp_source.html#l00076">76</a> of file <a class="el" href="../../d8/d43/container__utilities_8hpp_source.html">container_utilities.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aecbbeee6461326c29fd8a7452fbed04b"></a>typedef typename type</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="d1/d55/structbit_1_1core_1_1variant__alternative" id="d1/d55/structbit_1_1core_1_1variant__alternative"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d1/d55/structbit_1_1core_1_1variant__alternative">&#9670;&nbsp;</a></span>bit::core::variant_alternative</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::core::variant_alternative</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t I, typename T&gt;<br />
struct bit::core::variant_alternative&lt; I, T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d9/d7a/variant_8hpp_source.html#l00503">503</a> of file <a class="el" href="../../d9/d7a/variant_8hpp_source.html">variant.hpp</a>.</p>
</div>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab5b6e977f622007cfef6fb89fe6f1e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b6e977f622007cfef6fb89fe6f1e75">&#9670;&nbsp;</a></span>aligned_storage_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab5b6e977f622007cfef6fb89fe6f1e75">bit::core::aligned_storage_for</a> = typedef <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad5c2ede351bacf3e10a0d75360aa3d1d">aligned_storage_t</a>&lt;detail::aligned_storage_max&lt;sizeof(Types)...&gt;::value, detail::aligned_storage_max&lt;alignof(Types)...&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type-alias for creating <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/dd3/structbit_1_1core_1_1aligned__storage" title="Provides the nested type type, which is a PODType suitable for use as uninitialized storage for any o...">aligned_storage</a> large enough and suitably aligned for all specified Types... </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>the types to ensure alignment and size of </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/de5/aligned__storage_8hpp_source.html#l00103">103</a> of file <a class="el" href="../../d7/de5/aligned__storage_8hpp_source.html">aligned_storage.hpp</a>.</p>

</div>
</div>
<a id="a1d594ee9a1db433b8726fd85f5dfca1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d594ee9a1db433b8726fd85f5dfca1f">&#9670;&nbsp;</a></span>function_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1d594ee9a1db433b8726fd85f5dfca1f">bit::core::function_pointer</a> = typedef typename detail::function_t&lt;Fn&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias for function pointers to make it more readable. </p>
<dl class="section note"><dt>Note</dt><dd>That function_t is unable to deduce it's template parameters if used in a deduction context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/de3/types_8hpp_source.html#l00211">211</a> of file <a class="el" href="../../dd/de3/types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a id="ab51f16431c3e7b201420c4b96ca59f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51f16431c3e7b201420c4b96ca59f58">&#9670;&nbsp;</a></span>is_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ab51f16431c3e7b201420c4b96ca59f58">bit::core::is_assignable</a> = typedef std::is_assignable&lt;T,U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is assignable. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../de/de9/is__assignable_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../de/de9/is__assignable_8hpp_source.html">is_assignable.hpp</a>.</p>

</div>
</div>
<a id="a3e4d09b7fe409dc363b65f21fb0b1b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4d09b7fe409dc363b65f21fb0b1b06">&#9670;&nbsp;</a></span>is_copy_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3e4d09b7fe409dc363b65f21fb0b1b06">bit::core::is_copy_assignable</a> = typedef std::is_copy_assignable&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is copy-assignable. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d1/d70/is__copy__assignable_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d1/d70/is__copy__assignable_8hpp_source.html">is_copy_assignable.hpp</a>.</p>

</div>
</div>
<a id="a1771083dc64b5a241d9e36069a44cb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1771083dc64b5a241d9e36069a44cb6a">&#9670;&nbsp;</a></span>is_copy_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a1771083dc64b5a241d9e36069a44cb6a">bit::core::is_copy_constructible</a> = typedef std::is_copy_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is copy-constructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d4/d41/is__copy__constructible_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d4/d41/is__copy__constructible_8hpp_source.html">is_copy_constructible.hpp</a>.</p>

</div>
</div>
<a id="a7075f46b78f22acb517a4fc86f9ee464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7075f46b78f22acb517a4fc86f9ee464">&#9670;&nbsp;</a></span>is_default_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7075f46b78f22acb517a4fc86f9ee464">bit::core::is_default_constructible</a> = typedef std::is_default_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is default-constructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../df/db7/is__default__constructible_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../df/db7/is__default__constructible_8hpp_source.html">is_default_constructible.hpp</a>.</p>

</div>
</div>
<a id="a414aed485401f8a9703416887ba9c2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414aed485401f8a9703416887ba9c2e8">&#9670;&nbsp;</a></span>is_destructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a414aed485401f8a9703416887ba9c2e8">bit::core::is_destructible</a> = typedef std::is_destructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is destructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d3/d32/is__destructible_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d3/d32/is__destructible_8hpp_source.html">is_destructible.hpp</a>.</p>

</div>
</div>
<a id="a2c7a0ee5776e985bbaa3871d7947550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7a0ee5776e985bbaa3871d7947550a">&#9670;&nbsp;</a></span>is_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2c7a0ee5776e985bbaa3871d7947550a">bit::core::is_invocable</a> = typedef detail::is_invocable&lt;Fn,Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to determine whether <code>Fn</code> is invokable with <code>Args</code>... </p>
<p>Formally, the expression: </p><div class="fragment"><div class="line">INVOKE( std::declval&lt;Fn&gt;(), std::declval&lt;Args&gt;()... )</div></div><!-- fragment --><p> is well formed</p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../dd/d31/invoke_8hpp_source.html#l00203">203</a> of file <a class="el" href="../../dd/d31/invoke_8hpp_source.html">invoke.hpp</a>.</p>

</div>
</div>
<a id="a3b9e46d169a187adb1a07e0531e8a01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9e46d169a187adb1a07e0531e8a01a">&#9670;&nbsp;</a></span>is_move_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a3b9e46d169a187adb1a07e0531e8a01a">bit::core::is_move_assignable</a> = typedef std::is_move_assignable&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is move-assignable. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../dc/d2d/is__move__assignable_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../dc/d2d/is__move__assignable_8hpp_source.html">is_move_assignable.hpp</a>.</p>

</div>
</div>
<a id="a65ffdda9ec7463844a64a48dfeef2483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ffdda9ec7463844a64a48dfeef2483">&#9670;&nbsp;</a></span>is_move_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a65ffdda9ec7463844a64a48dfeef2483">bit::core::is_move_constructible</a> = typedef std::is_move_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is move-constructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d3/d08/is__move__constructible_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d3/d08/is__move__constructible_8hpp_source.html">is_move_constructible.hpp</a>.</p>

</div>
</div>
<a id="adc1a797ea83fba610a8acdebdba7dafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1a797ea83fba610a8acdebdba7dafe">&#9670;&nbsp;</a></span>is_nothrow_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#adc1a797ea83fba610a8acdebdba7dafe">bit::core::is_nothrow_assignable</a> = typedef std::is_nothrow_assignable&lt;T,U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is nothrow assignable. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d0/d4f/is__trivially__assignable_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d0/d4f/is__trivially__assignable_8hpp_source.html">is_trivially_assignable.hpp</a>.</p>

</div>
</div>
<a id="a4664ddec42d92eb0982bd8d2cbcd5a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4664ddec42d92eb0982bd8d2cbcd5a7e">&#9670;&nbsp;</a></span>is_nothrow_copy_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a4664ddec42d92eb0982bd8d2cbcd5a7e">bit::core::is_nothrow_copy_assignable</a> = typedef std::is_nothrow_copy_assignable&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is nothrow copy-assignable. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../df/d6a/is__nothrow__copy__assignable_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../df/d6a/is__nothrow__copy__assignable_8hpp_source.html">is_nothrow_copy_assignable.hpp</a>.</p>

</div>
</div>
<a id="a0a3c99e273941fc29f98f96f802f0a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3c99e273941fc29f98f96f802f0a7d">&#9670;&nbsp;</a></span>is_nothrow_copy_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0a3c99e273941fc29f98f96f802f0a7d">bit::core::is_nothrow_copy_constructible</a> = typedef std::is_nothrow_copy_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is copy-constructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d1/de7/is__nothrow__copy__constructible_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d1/de7/is__nothrow__copy__constructible_8hpp_source.html">is_nothrow_copy_constructible.hpp</a>.</p>

</div>
</div>
<a id="a504a07f5c7a1615c06c5a59162c09a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504a07f5c7a1615c06c5a59162c09a00">&#9670;&nbsp;</a></span>is_nothrow_default_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a504a07f5c7a1615c06c5a59162c09a00">bit::core::is_nothrow_default_constructible</a> = typedef std::is_nothrow_default_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is nothrow default-constructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../da/da9/is__nothrow__default__constructible_8hpp_source.html#l00052">52</a> of file <a class="el" href="../../da/da9/is__nothrow__default__constructible_8hpp_source.html">is_nothrow_default_constructible.hpp</a>.</p>

</div>
</div>
<a id="ae1ee3460c056151459089407d1194b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ee3460c056151459089407d1194b64">&#9670;&nbsp;</a></span>is_nothrow_destructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ae1ee3460c056151459089407d1194b64">bit::core::is_nothrow_destructible</a> = typedef std::is_nothrow_destructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is destructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d5/d10/is__nothrow__destructible_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d5/d10/is__nothrow__destructible_8hpp_source.html">is_nothrow_destructible.hpp</a>.</p>

</div>
</div>
<a id="afc6dcf0031b078fd8c7c65479ffe687f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6dcf0031b078fd8c7c65479ffe687f">&#9670;&nbsp;</a></span>is_nothrow_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#afc6dcf0031b078fd8c7c65479ffe687f">bit::core::is_nothrow_invocable</a> = typedef detail::is_nothrow_invocable&lt;Fn,Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to determine whether <code>Fn</code> is nothrow invokable with <code>Args</code>... </p>
<p>Formally, the expression: </p><div class="fragment"><div class="line">INVOKE( std::declval&lt;Fn&gt;(), std::declval&lt;Args&gt;()... )</div></div><!-- fragment --><p> is well formed and is known not to throw</p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../dd/d31/invoke_8hpp_source.html#l00229">229</a> of file <a class="el" href="../../dd/d31/invoke_8hpp_source.html">invoke.hpp</a>.</p>

</div>
</div>
<a id="a9518a91a11b6a4140499d395f7dc608a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9518a91a11b6a4140499d395f7dc608a">&#9670;&nbsp;</a></span>is_nothrow_move_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a9518a91a11b6a4140499d395f7dc608a">bit::core::is_nothrow_move_assignable</a> = typedef std::is_nothrow_move_assignable&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is nothrow move-assignable. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d5/d92/is__nothrow__move__assignable_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d5/d92/is__nothrow__move__assignable_8hpp_source.html">is_nothrow_move_assignable.hpp</a>.</p>

</div>
</div>
<a id="aa2c2235981ef56c0ef0a7b2d56738f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c2235981ef56c0ef0a7b2d56738f44">&#9670;&nbsp;</a></span>is_nothrow_move_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#aa2c2235981ef56c0ef0a7b2d56738f44">bit::core::is_nothrow_move_constructible</a> = typedef std::is_nothrow_move_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is move-constructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../df/d0f/is__nothrow__move__constructible_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../df/d0f/is__nothrow__move__constructible_8hpp_source.html">is_nothrow_move_constructible.hpp</a>.</p>

</div>
</div>
<a id="af7924cb4fc7b33d936c69ee41387e639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7924cb4fc7b33d936c69ee41387e639">&#9670;&nbsp;</a></span>is_same_decay</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#af7924cb4fc7b33d936c69ee41387e639">bit::core::is_same_decay</a> = typedef std::is_same&lt;std::decay_t&lt;T&gt;,std::decay_t&lt;U&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to determine whether a type is the same with a different decay type. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d6/dd3/is__same__decay_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d6/dd3/is__same__decay_8hpp_source.html">is_same_decay.hpp</a>.</p>

</div>
</div>
<a id="a95aaae9e48d9bc1e9ce1680fe2961614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95aaae9e48d9bc1e9ce1680fe2961614">&#9670;&nbsp;</a></span>is_string_span</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a95aaae9e48d9bc1e9ce1680fe2961614">bit::core::is_string_span</a> = typedef detail::is_string_span&lt;std::remove_cv_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type-trait to determine whether the type is a string_span </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/string__span_8hpp_source.html#l00126">126</a> of file <a class="el" href="../../d9/d14/string__span_8hpp_source.html">string_span.hpp</a>.</p>

</div>
</div>
<a id="af9a6053cdf318c66148e586dfef7530a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a6053cdf318c66148e586dfef7530a">&#9670;&nbsp;</a></span>is_trivially_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#af9a6053cdf318c66148e586dfef7530a">bit::core::is_trivially_assignable</a> = typedef std::is_trivially_assignable&lt;T,U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is trivially assignable. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d0/d5e/is__nothrow__assignable_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d0/d5e/is__nothrow__assignable_8hpp_source.html">is_nothrow_assignable.hpp</a>.</p>

</div>
</div>
<a id="a0891f6958fb7737380699c4d05c4bf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0891f6958fb7737380699c4d05c4bf64">&#9670;&nbsp;</a></span>is_trivially_copy_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a0891f6958fb7737380699c4d05c4bf64">bit::core::is_trivially_copy_assignable</a> = typedef std::is_trivially_copy_assignable&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is trivially copy-assignable. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d1/db1/is__trivially__copy__assignable_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d1/db1/is__trivially__copy__assignable_8hpp_source.html">is_trivially_copy_assignable.hpp</a>.</p>

</div>
</div>
<a id="a09839e41c2608b206f4a02d43f28fd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09839e41c2608b206f4a02d43f28fd8f">&#9670;&nbsp;</a></span>is_trivially_copy_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a09839e41c2608b206f4a02d43f28fd8f">bit::core::is_trivially_copy_constructible</a> = typedef std::is_trivially_copy_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is copy-constructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../de/d78/is__trivially__copy__constructible_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../de/d78/is__trivially__copy__constructible_8hpp_source.html">is_trivially_copy_constructible.hpp</a>.</p>

</div>
</div>
<a id="a7aecfc9d5ab4fa42b6289b479b37739b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aecfc9d5ab4fa42b6289b479b37739b">&#9670;&nbsp;</a></span>is_trivially_default_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a7aecfc9d5ab4fa42b6289b479b37739b">bit::core::is_trivially_default_constructible</a> = typedef std::is_trivially_default_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is trivially default-constructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../df/dc7/is__trivially__default__constructible_8hpp_source.html#l00052">52</a> of file <a class="el" href="../../df/dc7/is__trivially__default__constructible_8hpp_source.html">is_trivially_default_constructible.hpp</a>.</p>

</div>
</div>
<a id="aadc833e0cdfa1b9c18c112b5164239c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc833e0cdfa1b9c18c112b5164239c7">&#9670;&nbsp;</a></span>is_trivially_destructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#aadc833e0cdfa1b9c18c112b5164239c7">bit::core::is_trivially_destructible</a> = typedef std::is_trivially_destructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is destructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d37/is__trivially__destructible_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d8/d37/is__trivially__destructible_8hpp_source.html">is_trivially_destructible.hpp</a>.</p>

</div>
</div>
<a id="a35d6085a41d33b8ab2f232ad21392982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d6085a41d33b8ab2f232ad21392982">&#9670;&nbsp;</a></span>is_trivially_move_assignable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a35d6085a41d33b8ab2f232ad21392982">bit::core::is_trivially_move_assignable</a> = typedef std::is_trivially_move_assignable&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is trivially move-assignable. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d1/d25/is__trivially__move__assignable_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d1/d25/is__trivially__move__assignable_8hpp_source.html">is_trivially_move_assignable.hpp</a>.</p>

</div>
</div>
<a id="a411d152531059e6b08c5dc21be658c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411d152531059e6b08c5dc21be658c43">&#9670;&nbsp;</a></span>is_trivially_move_constructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a411d152531059e6b08c5dc21be658c43">bit::core::is_trivially_move_constructible</a> = typedef std::is_trivially_move_constructible&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait for determining if a type is move-constructible. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d26/is__trivially__move__constructible_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d9/d26/is__trivially__move__constructible_8hpp_source.html">is_trivially_move_constructible.hpp</a>.</p>

</div>
</div>
<a id="aaca3133d65111e9bd17f114f28ec8239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca3133d65111e9bd17f114f28ec8239">&#9670;&nbsp;</a></span>is_zstring_span</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#aaca3133d65111e9bd17f114f28ec8239">bit::core::is_zstring_span</a> = typedef detail::is_zstring_span&lt;std::remove_cv_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type-trait to determine whether the type is a null-terminated string </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/string__span_8hpp_source.html#l00133">133</a> of file <a class="el" href="../../d9/d14/string__span_8hpp_source.html">string_span.hpp</a>.</p>

</div>
</div>
<a id="addcecdee4575842906c24982a4bb2f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcecdee4575842906c24982a4bb2f3e">&#9670;&nbsp;</a></span>match_cv_qualifiers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Qualified , typename Unqualified &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#addcecdee4575842906c24982a4bb2f3e">bit::core::match_cv_qualifiers</a> = typedef detail::cv_selector&lt; Unqualified, std::is_const&lt;Qualified&gt;::value, std::is_volatile&lt;Qualified&gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to match the cv qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d7/da0/match__cv__qualifiers_8hpp_source.html#l00079">79</a> of file <a class="el" href="../../d7/da0/match__cv__qualifiers_8hpp_source.html">match_cv_qualifiers.hpp</a>.</p>

</div>
</div>
<a id="a2264263085a410d741140157b6c6f773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2264263085a410d741140157b6c6f773">&#9670;&nbsp;</a></span>match_ref_qualifiers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Qualified , typename Unqualified &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a2264263085a410d741140157b6c6f773">bit::core::match_ref_qualifiers</a> = typedef detail::ref_selector&lt; Unqualified, std::is_lvalue_reference&lt;Qualified&gt;::value, std::is_rvalue_reference&lt;Qualified&gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to match the ref qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d0/d5a/match__ref__qualifiers_8hpp_source.html#l00072">72</a> of file <a class="el" href="../../d0/d5a/match__ref__qualifiers_8hpp_source.html">match_ref_qualifiers.hpp</a>.</p>

</div>
</div>
<a id="ad3f29bd16760413ccb652e9568402ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f29bd16760413ccb652e9568402ddc">&#9670;&nbsp;</a></span>match_sign_qualifiers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Qualified , typename Unqualified &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ad3f29bd16760413ccb652e9568402ddc">bit::core::match_sign_qualifiers</a> = typedef detail::sign_selector&lt; Unqualified, std::is_signed&lt;Qualified&gt;::value, std::is_unsigned&lt;Qualified&gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to match the sign qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../de/d9b/match__sign__qualifiers_8hpp_source.html#l00071">71</a> of file <a class="el" href="../../de/d9b/match__sign__qualifiers_8hpp_source.html">match_sign_qualifiers.hpp</a>.</p>

</div>
</div>
<a id="a011912bcc8a49005c1b9716e461cd069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011912bcc8a49005c1b9716e461cd069">&#9670;&nbsp;</a></span>member_function_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a011912bcc8a49005c1b9716e461cd069">bit::core::member_function_pointer</a> = typedef typename detail::member_function_t&lt;T,Fn&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias for member function pointers to make it more readable. </p>
<dl class="section note"><dt>Note</dt><dd>member_function_t is unable to deduce it's template parameters if used in a deduction context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/de3/types_8hpp_source.html#l00204">204</a> of file <a class="el" href="../../dd/de3/types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a id="acc991625a0b8cddbdaaf8f1aca5ac889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc991625a0b8cddbdaaf8f1aca5ac889">&#9670;&nbsp;</a></span>member_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#acc991625a0b8cddbdaaf8f1aca5ac889">bit::core::member_pointer</a> = typedef R T::*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias for member pointers to make it more readable. </p>
<dl class="section note"><dt>Note</dt><dd>member_t is unable to deduce it's template parameters if used in a deduction context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/de3/types_8hpp_source.html#l00196">196</a> of file <a class="el" href="../../dd/de3/types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a id="ac1cb0729bdcb141e7590869875942b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cb0729bdcb141e7590869875942b1e">&#9670;&nbsp;</a></span>pointer_rank</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#ac1cb0729bdcb141e7590869875942b1e">bit::core::pointer_rank</a> = typedef detail::pointer_rank&lt;T,0&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the level of indirection of a given type T. </p>
<p>This effectively counts the number of pointer types in a given type T</p>
<p>The result is stored in <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../df/dde/pointer__rank_8hpp_source.html#l00063">63</a> of file <a class="el" href="../../df/dde/pointer__rank_8hpp_source.html">pointer_rank.hpp</a>.</p>

</div>
</div>
<a id="a009ebf263b365e405468e850d654d2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009ebf263b365e405468e850d654d2ee">&#9670;&nbsp;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a009ebf263b365e405468e850d654d2ee">bit::core::type_identity_t</a> = typedef typename <a class="el" href="../../dd/d2d/structbit_1_1core_1_1type__identity.html">type_identity</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Namespace alias used to extract identity&lt;T&gt;::type. </p>
<dl class="section note"><dt>Note</dt><dd>This alias is mostly useful for preventing template deduction </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d6a/type__identity_8hpp_source.html#l00053">53</a> of file <a class="el" href="../../d7/d6a/type__identity_8hpp_source.html">type_identity.hpp</a>.</p>

</div>
</div>
<a id="a34572ccc792c800c6e93ea48afdf8a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34572ccc792c800c6e93ea48afdf8a66">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a34572ccc792c800c6e93ea48afdf8a66">bit::core::void_t</a> = typedef typename detail::voidify&lt;Types...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility metafunction that maps a sequence of any types to the type void. </p>
<p>This is used for determining validity of expressions using SFINAE </p>

<p class="definition">Definition at line <a class="el" href="../../d9/dce/void__t_8hpp_source.html#l00054">54</a> of file <a class="el" href="../../d9/dce/void__t_8hpp_source.html">void_t.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a41a462b88353d20ab5cbb602fab0fb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a462b88353d20ab5cbb602fab0fb44">&#9670;&nbsp;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a41a462b88353d20ab5cbb602fab0fb44">bit::core::byte</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsigned byte type. </p>
<dl class="section note"><dt>Note</dt><dd>Due to a restriction in pre-C++-17, a conversion to a pointer of byte types results in undefined behavior due to a violation of strict-aliasing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/da9/byte_8hpp_source.html#l00054">54</a> of file <a class="el" href="../../da/da9/byte_8hpp_source.html">byte.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a592ab70b4f1bdab17b3997e99b7315a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592ab70b4f1bdab17b3997e99b7315a2">&#9670;&nbsp;</a></span>address_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::address_from </td>
          <td>(</td>
          <td class="paramtype">InputIterator &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> -&gt;  typename std::iterator_traits&lt; InputIterator &gt;::value_type *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object referenced through an iterator <code>it</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the value referenced from the iterator </dd></dl>

</div>
</div>
<a id="ad72b086c85f13bf0c6bb6bdf36b33dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72b086c85f13bf0c6bb6bdf36b33dc3">&#9670;&nbsp;</a></span>allocate_exclusive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt;T&gt; bit::core::allocate_exclusive </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a>, forwarding <code>args</code> to the underyling constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>the allocator to allocate the <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a> </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to forward for the underlying constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an allocated <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a> </dd></dl>

</div>
</div>
<a id="a692e290b0e84335bb232b7f044830643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692e290b0e84335bb232b7f044830643">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::core::apply </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the Callable object <code>function</code> with a <code>tuple</code> of arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to be invoked </td></tr>
    <tr><td class="paramname">tuple</td><td>tuple whose elements to be used as arguments to <code>function</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned from <code>function</code> </dd></dl>

</div>
</div>
<a id="ae35fa1305981737caa85398a336a3254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35fa1305981737caa85398a336a3254">&#9670;&nbsp;</a></span>at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; bit::core::at </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the element at <code>n</code> with bounds-checking. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>n</code> &gt;= N</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array to check </td></tr>
    <tr><td class="paramname">n</td><td>the index to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the entry </dd></dl>

</div>
</div>
<a id="a917a5c61b0f62afa9ad874020a8cc10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917a5c61b0f62afa9ad874020a8cc10f">&#9670;&nbsp;</a></span>at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; bit::core::at </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the element at <code>n</code> with bounds-checking. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>n</code> &gt;= N</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer list to extract from </td></tr>
    <tr><td class="paramname">n</td><td>the index to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the entry </dd></dl>

</div>
</div>
<a id="a1bb844fbb8e0294cbc64b77372020b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb844fbb8e0294cbc64b77372020b18">&#9670;&nbsp;</a></span>at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bit::core::at </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(c.at(std::forward&lt; Key &gt;(key)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the element from the container with the given <code>key</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container to check </td></tr>
    <tr><td class="paramname">key</td><td>the key into the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the entry </dd></dl>

</div>
</div>
<a id="a399c77dafe665f46c2d5e672812c6a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399c77dafe665f46c2d5e672812c6a77">&#9670;&nbsp;</a></span>at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bit::core::at </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(c.at(std::forward&lt; Key &gt;(key)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the element from the container with the given <code>key</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container to check </td></tr>
    <tr><td class="paramname">key</td><td>the key into the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the entry </dd></dl>

</div>
</div>
<a id="a971cc81c70825b79d1b4cec2966a9e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971cc81c70825b79d1b4cec2966a9e07">&#9670;&nbsp;</a></span>back() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; bit::core::back </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the last entry in the given <code>array</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the last entry </dd></dl>

</div>
</div>
<a id="ac87532ba958f1074256ab21b9e11e121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87532ba958f1074256ab21b9e11e121">&#9670;&nbsp;</a></span>back() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; bit::core::back </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the last entry in the given initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the last entry </dd></dl>

</div>
</div>
<a id="a82952b2b002a9a78b62f31b7737174dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82952b2b002a9a78b62f31b7737174dc">&#9670;&nbsp;</a></span>back() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::back </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.back())</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the last entry in the given container by delegating the call to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the last entry </dd></dl>

</div>
</div>
<a id="a31d5f76937c0a01d114ccd2a5d78ff9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d5f76937c0a01d114ccd2a5d78ff9e">&#9670;&nbsp;</a></span>back() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::back </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.back())</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the last entry in the given container by delegating the call to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the last entry </dd></dl>

</div>
</div>
<a id="a66c6402efda390b93c9704f3537a3b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c6402efda390b93c9704f3537a3b76">&#9670;&nbsp;</a></span>data() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T* bit::core::data </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to contiguous data from a specified <code>array</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the data </dd></dl>

</div>
</div>
<a id="adea7826b865e212b9ef982b564106fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea7826b865e212b9ef982b564106fd8">&#9670;&nbsp;</a></span>data() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T* bit::core::data </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to contiguous data from a specified initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the data </dd></dl>

</div>
</div>
<a id="aced4497f464f7a31d443327f99b3bc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced4497f464f7a31d443327f99b3bc7d">&#9670;&nbsp;</a></span>data() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::data </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.data())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to contiguous data in a container by delegating to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the data </dd></dl>

</div>
</div>
<a id="aea38530996aac13beeed507a320a33d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea38530996aac13beeed507a320a33d9">&#9670;&nbsp;</a></span>data() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::data </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.data())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to contiguous data in a container by delegating to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the data </dd></dl>

</div>
</div>
<a id="a103a5deb93be662372b777e3c1666bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103a5deb93be662372b777e3c1666bc3">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::core::deep_compare </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a130a84a0b8363904331d217b8ce899e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130a84a0b8363904331d217b8ce899e7">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::core::deep_compare </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="ad2c9d6dad46100369c7555aee033a20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c9d6dad46100369c7555aee033a20f">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::core::deep_compare </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a38657589568f9ac3da93109b7613d196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38657589568f9ac3da93109b7613d196">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::core::deep_compare </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="af1db675d6cd6e7be647306f52d1c4922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1db675d6cd6e7be647306f52d1c4922">&#9670;&nbsp;</a></span>dereference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::core::dereference </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereferences all levels of pointer indirection from the supplied pointer. </p>
<dl class="section note"><dt>Note</dt><dd>This does not do any null-checking</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to dereference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the dereferenced pointer </dd></dl>

</div>
</div>
<a id="a1fe204bcdcfaa842d61490dbbca87c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe204bcdcfaa842d61490dbbca87c42">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::destroy </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the objects in the range <code></code>[first, <code>last</code>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range to destroy </td></tr>
    <tr><td class="paramname">end</td><td>the end of the range to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0de5e078e11eede138af0d701dc94ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0de5e078e11eede138af0d701dc94ee">&#9670;&nbsp;</a></span>destroy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::destroy_at </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the destructor of the object pointed to by p, as if by p-&gt;~T(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a07bcad989da353c4f7a6725b74d4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a07bcad989da353c4f7a6725b74d4ab">&#9670;&nbsp;</a></span>destroy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator bit::core::destroy_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the <code>n</code> objects in the range starting at <code>first</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range to destroy </td></tr>
    <tr><td class="paramname">n</td><td>the number of entries to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac384c942143284e55516f4c6cba7db81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac384c942143284e55516f4c6cba7db81">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="../../d9/d73/namespacebit_1_1core.html#dc/d3e/structbit_1_1core_1_1empty">bit::core::empty</a> </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the array is empty. </p>
<p>This overload will always return <code>false</code>, since arrays of size 0 are illegal in C++.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> </dd></dl>

</div>
</div>
<a id="a62cef9f854953065d5aba21b92a6931d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cef9f854953065d5aba21b92a6931d">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="../../d9/d73/namespacebit_1_1core.html#dc/d3e/structbit_1_1core_1_1empty">bit::core::empty</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the initializer list is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the initializer list is empty </dd></dl>

</div>
</div>
<a id="a33cc6271a63c342d4833d30d6d80e4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33cc6271a63c342d4833d30d6d80e4d8">&#9670;&nbsp;</a></span>empty() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="../../d9/d73/namespacebit_1_1core.html#dc/d3e/structbit_1_1core_1_1empty">bit::core::empty</a> </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.empty())</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the container is empty by delegating to the container's implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty </dd></dl>

</div>
</div>
<a id="ab7b6a1261d77a5190c87bb6b68b568c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b6a1261d77a5190c87bb6b68b568c3">&#9670;&nbsp;</a></span>from_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* bit::core::from_address </td>
          <td>(</td>
          <td class="paramtype">std::uintptr_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric address <code>address</code> into a pointer pointing to the address location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the address value to convert to a pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer pointing to the given address </dd></dl>

</div>
</div>
<a id="a12cbfa02664b96a6f457ec32a39b702b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cbfa02664b96a6f457ec32a39b702b">&#9670;&nbsp;</a></span>front() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; bit::core::front </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the first entry in the given <code>array</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the first entry </dd></dl>

</div>
</div>
<a id="a0b598d5ce425d87697a13a541c0f3bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b598d5ce425d87697a13a541c0f3bb4">&#9670;&nbsp;</a></span>front() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; bit::core::front </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the first entry in the given initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the first entry </dd></dl>

</div>
</div>
<a id="a305ef47989897767dcaddd9d981ff974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305ef47989897767dcaddd9d981ff974">&#9670;&nbsp;</a></span>front() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::front </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.front())</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the first entry in the given container by delegating the call to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the first entry </dd></dl>

</div>
</div>
<a id="a1be040bde12ac0b4095de82072365345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be040bde12ac0b4095de82072365345">&#9670;&nbsp;</a></span>front() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::front </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.front())</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the first entry in the given container by delegating the call to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the first entry </dd></dl>

</div>
</div>
<a id="a47d690dc876b4908b42c8d33f73fe6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d690dc876b4908b42c8d33f73fe6a9">&#9670;&nbsp;</a></span>get() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp; bit::core::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <code>N'th</code> entry from the specifier <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html" title="An immutable wrapper around non-owned contiguous data. ">array_view</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>N</code> is not in range of <code>x</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the entry to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the <a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html" title="An immutable wrapper around non-owned contiguous data. ">array_view</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the entry </dd></dl>

</div>
</div>
<a id="afa394559e2bd507e27ef72ffe98f4595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa394559e2bd507e27ef72ffe98f4595">&#9670;&nbsp;</a></span>get() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; bit::core::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code>Nth</code> element from <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The entry to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the span to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the </dd></dl>

</div>
</div>
<a id="adaa4d6a6fb3fa4a537180d8ccdb8ebcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa4d6a6fb3fa4a537180d8ccdb8ebcd">&#9670;&nbsp;</a></span>get() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp; bit::core::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code>Nth</code> element from <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The entry to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the span to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the </dd></dl>

</div>
</div>
<a id="a575be5722c5ecc2ff9f3041c0377e14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575be5722c5ecc2ff9f3041c0377e14a">&#9670;&nbsp;</a></span>get() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp;&amp; bit::core::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code>Nth</code> element from <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The entry to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the span to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the </dd></dl>

</div>
</div>
<a id="a586a08ad40ade60348e849097b377f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586a08ad40ade60348e849097b377f23">&#9670;&nbsp;</a></span>get() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp;&amp; bit::core::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the <code>Nth</code> element from <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The entry to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the span to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the </dd></dl>

</div>
</div>
<a id="a9e33a514d678ae30919ad9f1a804d834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e33a514d678ae30919ad9f1a804d834">&#9670;&nbsp;</a></span>get() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; bit::core::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d1/dae/classbit_1_1core_1_1bad__variant__access.html" title="Exception thrown by variant. ">bad_variant_access</a></td><td>if <code>T</code> is not the active alternative</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the alternative to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the variant to extract the entry from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the alternative </dd></dl>

</div>
</div>
<a id="ad6c334d6e887191085cb5aa6c6a15894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c334d6e887191085cb5aa6c6a15894">&#9670;&nbsp;</a></span>get() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp;&amp; bit::core::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d1/dae/classbit_1_1core_1_1bad__variant__access.html" title="Exception thrown by variant. ">bad_variant_access</a></td><td>if <code>T</code> is not the active alternative</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the alternative to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the variant to extract the entry from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the alternative </dd></dl>

</div>
</div>
<a id="a8c1a8c2c7655cdd77777a3cbdfda1892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1a8c2c7655cdd77777a3cbdfda1892">&#9670;&nbsp;</a></span>get() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp; bit::core::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d1/dae/classbit_1_1core_1_1bad__variant__access.html" title="Exception thrown by variant. ">bad_variant_access</a></td><td>if <code>T</code> is not the active alternative</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the alternative to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the variant to extract the entry from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the alternative </dd></dl>

</div>
</div>
<a id="a770a846dee0632f51b6b9915fbe45203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770a846dee0632f51b6b9915fbe45203">&#9670;&nbsp;</a></span>get() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const T&amp;&amp; bit::core::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d1/dae/classbit_1_1core_1_1bad__variant__access.html" title="Exception thrown by variant. ">bad_variant_access</a></td><td>if <code>T</code> is not the active alternative</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the alternative to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the variant to extract the entry from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the alternative </dd></dl>

</div>
</div>
<a id="ac72e9e9bd0666bf000471641e06606fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72e9e9bd0666bf000471641e06606fd">&#9670;&nbsp;</a></span>get_deleter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Deleter , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Deleter* bit::core::get_deleter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the deleter from <code>ptr</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Deleter</td><td>the type of the deleter to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a> to get the deleter from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the deleter </dd></dl>

</div>
</div>
<a id="a4e0692e7a0f194394b9f4dbc17a02910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0692e7a0f194394b9f4dbc17a02910">&#9670;&nbsp;</a></span>get_if() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::add_pointer_t&lt;variant_alternative_t&lt;I, <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt;Types...&gt; &gt; &gt; bit::core::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor. </p>
<p>If <code>pv</code> is not a null pointer and <code>pv-&gt;index()</code> == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value.</p>
<p>The call is ill-formed if I is not a valid index in the variant</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>the index of the alternative to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>the pointer to the variant to extract the value from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the variant alternative when successful </dd></dl>

</div>
</div>
<a id="ab4cdacd1d9f9526ec1ece0f968bd63cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cdacd1d9f9526ec1ece0f968bd63cd">&#9670;&nbsp;</a></span>get_if() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::add_pointer_t&lt;const variant_alternative_t&lt;I, <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt;Types...&gt; &gt; &gt; bit::core::get_if </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index-based non-throwing accessor. </p>
<p>If <code>pv</code> is not a null pointer and <code>pv-&gt;index()</code> == I, returns a pointer to the value stored in the variant pointed to by pv. Otherwise, returns a null pointer value.</p>
<p>The call is ill-formed if I is not a valid index in the variant</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>the index of the alternative to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>the pointer to the variant to extract the value from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the variant alternative when successful </dd></dl>

</div>
</div>
<a id="a1c5d6bd02a1f6e0df15174eba83b3f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5d6bd02a1f6e0df15174eba83b3f59">&#9670;&nbsp;</a></span>get_if() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::add_pointer_t&lt;T&gt; bit::core::get_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type-based non-throwing accessor. </p>
<p>Equivalent to the index-based <code>get_if</code> with <code>I</code> being the zero-based index of <code>T</code> in <code>Types</code>....</p>
<p>The call is ill-formed if T is not a unique element of Types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the alternative type to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>the pointer to the variant to extract the value from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the variant alternative when successful </dd></dl>

</div>
</div>
<a id="aac1021e598ea8f73a96cd5d98d44c43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1021e598ea8f73a96cd5d98d44c43f">&#9670;&nbsp;</a></span>get_if() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::add_pointer_t&lt;const T&gt; bit::core::get_if </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; *&#160;</td>
          <td class="paramname"><em>pv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type-based non-throwing accessor. </p>
<p>Equivalent to the index-based <code>get_if</code> with <code>I</code> being the zero-based index of <code>T</code> in <code>Types</code>....</p>
<p>The call is ill-formed if T is not a unique element of Types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the alternative type to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pv</td><td>the pointer to the variant to extract the value from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the variant alternative when successful </dd></dl>

</div>
</div>
<a id="a2f42ca7dfce022572daf371b4e2e1d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f42ca7dfce022572daf371b4e2e1d1d">&#9670;&nbsp;</a></span>get_underlying_container() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af840a751e699cded9aab77b10c5a2bca">underlying_container_type_t</a>&lt;C&gt;&amp; bit::core::get_underlying_container </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the underlying container of a given container adapter. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not participate in overload resolution if <code>container</code> is not a container adapter</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>reference to the container adapter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the underlying container </dd></dl>

</div>
</div>
<a id="a6e3896843013a3359c6715056b6564bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3896843013a3359c6715056b6564bb">&#9670;&nbsp;</a></span>get_underlying_container() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#af840a751e699cded9aab77b10c5a2bca">underlying_container_type_t</a>&lt;C&gt;&amp; bit::core::get_underlying_container </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the underlying container of a given container adapter. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not participate in overload resolution if <code>container</code> is not a container adapter</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>reference to the container adapter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the underlying container </dd></dl>

</div>
</div>
<a id="a7d1d9c0968c2f98d231e32aa8ce251c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1d9c0968c2f98d231e32aa8ce251c7">&#9670;&nbsp;</a></span>get_underlying_container() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#af840a751e699cded9aab77b10c5a2bca">underlying_container_type_t</a>&lt;C&gt;&amp;&amp; bit::core::get_underlying_container </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the underlying container of a given container adapter. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not participate in overload resolution if <code>container</code> is not a container adapter</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>reference to the container adapter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the underlying container </dd></dl>

</div>
</div>
<a id="a40d5c4be91794078459da185d57c147e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d5c4be91794078459da185d57c147e">&#9670;&nbsp;</a></span>get_underlying_container() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#af840a751e699cded9aab77b10c5a2bca">underlying_container_type_t</a>&lt;C&gt;&amp;&amp; bit::core::get_underlying_container </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the underlying container of a given container adapter. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not participate in overload resolution if <code>container</code> is not a container adapter</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>reference to the container adapter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the underlying container </dd></dl>

</div>
</div>
<a id="a1877296e32889d983ea3b6bb067b900f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1877296e32889d983ea3b6bb067b900f">&#9670;&nbsp;</a></span>hash_combine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines two hash values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the seed to combine </td></tr>
    <tr><td class="paramname">hash</td><td>the hash to combine with the seed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the combination </dd></dl>

</div>
</div>
<a id="a5caf854e63614ed2ba6a366e23bd65b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caf854e63614ed2ba6a366e23bd65b5">&#9670;&nbsp;</a></span>hash_combine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Hashes, typename  = std::enable_if&lt;(sizeof...(Hashes)&gt;0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a>&#160;</td>
          <td class="paramname"><em>hash0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashes...&#160;</td>
          <td class="paramname"><em>hashes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines n hash values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the seed to begin combination with </td></tr>
    <tr><td class="paramname">hash0</td><td>the first hash to comnbine with the seed </td></tr>
    <tr><td class="paramname">hashes</td><td>the rest of the hashes to combine with the combined seed/hashes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the combinations </dd></dl>

</div>
</div>
<a id="a2669bce95a2431bf03a059245573f481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2669bce95a2431bf03a059245573f481">&#9670;&nbsp;</a></span>hash_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a range of entries, returning the result. </p>
<p>This is equivalent to combining hashes of all entries within the range</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to hash </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hashed value </dd></dl>

</div>
</div>
<a id="a49e5974ac125794d6a8bdb1052a8029e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e5974ac125794d6a8bdb1052a8029e">&#9670;&nbsp;</a></span>hash_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_raw </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes the raw memory from a given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the raw data </dd></dl>

</div>
</div>
<a id="a80c1e455166eaeae136eaf1788d9e4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c1e455166eaeae136eaf1788d9e4b8">&#9670;&nbsp;</a></span>hash_string_segment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_string_segment </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a segment of a given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the pointer to the start of the string </td></tr>
    <tr><td class="paramname">count</td><td>the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string segment </dd></dl>

</div>
</div>
<a id="a2fae2ae3e9fc4f10e6afbd5521bb93c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fae2ae3e9fc4f10e6afbd5521bb93c8">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a std::basic_string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash </dd></dl>

</div>
</div>
<a id="a6056e72eee2ae8cd6ca23635ad0894c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6056e72eee2ae8cd6ca23635ad0894c1">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/38]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#da/d3a/structbit_1_1core_1_1monostate">monostate</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes the monostate. </p>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a id="a3646e85a78b3b10ea26053dfd8b29c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3646e85a78b3b10ea26053dfd8b29c00">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of a null pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a6c00861c3509e4c2074a0829bfe8efa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c00861c3509e4c2074a0829bfe8efa3">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[4/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given bool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="aab1df6f04ec5f0ac82788acc30913bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1df6f04ec5f0ac82788acc30913bd2">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[5/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a916f409a35fdbe28162d0d98aff785c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916f409a35fdbe28162d0d98aff785c8">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[6/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given signed char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a31afbb6d269fe1478d86e104df076685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31afbb6d269fe1478d86e104df076685">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[7/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a0926dbe5d9eff8b994789936aa40cd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0926dbe5d9eff8b994789936aa40cd38">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[8/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given wchar_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a79ae062c7eeea0afd09e1f1d608d1296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ae062c7eeea0afd09e1f1d608d1296">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[9/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">char16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given char16_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="abb4b5975973389fb74387552e4f41780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4b5975973389fb74387552e4f41780">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[10/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">char32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given char32_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a7581c377ce2e9e2d7506e13f023bdcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7581c377ce2e9e2d7506e13f023bdcd9">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[11/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="afbc0be67f97ee381cbab2f76a7fcaefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc0be67f97ee381cbab2f76a7fcaefc">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[12/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a27993124b4eddc0b1e39c2afef288b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27993124b4eddc0b1e39c2afef288b53">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[13/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="adf9eff787554f00284e1e0630751a53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9eff787554f00284e1e0630751a53b">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[14/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a64430bb06e89a5ee445810541ad24570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64430bb06e89a5ee445810541ad24570">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[15/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a67883a77ae7eb4e67373c35892405aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67883a77ae7eb4e67373c35892405aef">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[16/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="ab200faa1197be3dae43472662bea6e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab200faa1197be3dae43472662bea6e11">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[17/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given long long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a0d0809bccdeae9b7c9eb5289ab847544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0809bccdeae9b7c9eb5289ab847544">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[18/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned long long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a96a464bfaa85557128b7c6a4bbd4d968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a464bfaa85557128b7c6a4bbd4d968">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[19/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a3f653fc485b211136a292901103cede4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f653fc485b211136a292901103cede4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[20/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a9299b0cc16bb9842b31cdb2d83021dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9299b0cc16bb9842b31cdb2d83021dae">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[21/38]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given long double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a91cab286759f64965ed073bc322e8bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cab286759f64965ed073bc322e8bd5">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[22/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a8e6e8f8ee3600cf7e1f181b7ab042c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6e8f8ee3600cf7e1f181b7ab042c5e">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[23/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">R(*)(Args...)&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given function pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="ad40f38581a85fe780c1e9b0791aa9420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40f38581a85fe780c1e9b0791aa9420">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[24/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d0/df2/classbit_1_1core_1_1delegate">delegate</a>&lt; Fn &gt; &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes the delegate <code>fn</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the delegate to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash result </dd></dl>

</div>
</div>
<a id="a0706e5b253fafc6b29cc33578f48f1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0706e5b253fafc6b29cc33578f48f1b6">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[25/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename C , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">R(C::*)(Args...)&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given member function pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a85dba90796b6fa79d2c6dbc99d5e9e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dba90796b6fa79d2c6dbc99d5e9e5f">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[26/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">R C::*&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given member pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a286f256fcf2305d0da9ec0482ce4214d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286f256fcf2305d0da9ec0482ce4214d">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[27/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>val</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a hash of the given T array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a1d3367f727959b10b889d08e8fc3c0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3367f727959b10b889d08e8fc3c0ff">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[28/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>val</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a hash of the given T array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a7465e6eca64b98688c7f090beb6a3e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7465e6eca64b98688c7f090beb6a3e96">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[29/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">Enum&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes enum values. </p>
<dl class="section note"><dt>Note</dt><dd>This only participates in overload resolution if <code>std::is_enum</code> is <code>true</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the enum value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash value of the enum </dd></dl>

</div>
</div>
<a id="a9bff4068bff0d16f5386c746d3c389ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bff4068bff0d16f5386c746d3c389ca">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[30/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes the value of the underlying type of the <a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html" title="A wrapper to propagate the const qualifier. ">propagate_const</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hashed value </dd></dl>

</div>
</div>
<a id="a026d3af804429d3bb087db5170194ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026d3af804429d3bb087db5170194ddf">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[31/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html" title="An offset pointer based on boost::offset_ptr. ">offset_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the ptr to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the unique_ptr </dd></dl>

</div>
</div>
<a id="aa7109380717cfe420349abf170ea884c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7109380717cfe420349abf170ea884c">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[32/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes this <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the underlying pointer </dd></dl>

</div>
</div>
<a id="a3f503ae080ce536353c2e1888cfadb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f503ae080ce536353c2e1888cfadb69">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[33/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes this <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the underlying pointer </dd></dl>

</div>
</div>
<a id="a3ae39492e9d5baad61bef8464b9567c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae39492e9d5baad61bef8464b9567c9">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[34/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a std::pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>the pair to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad874efe0856adf8264bc8fd2e6eeba62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad874efe0856adf8264bc8fd2e6eeba62">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[35/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a hash of the underlying lazy, instantiating it if not already instantiated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to retrieve the has of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the lazy </dd></dl>

</div>
</div>
<a id="a1b4e3ebbdfe30d764492264cd1c08e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4e3ebbdfe30d764492264cd1c08e7a">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[36/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the basic_ string_view to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="af16023c1d180ed1b9f2b481ab3a251ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16023c1d180ed1b9f2b481ab3a251ae">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[37/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given optional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the optional to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="a8e1040f99274d130fa8f8e27a7cf9af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1040f99274d130fa8f8e27a7cf9af7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[38/38]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hash of this variant. </p>
<p>The computed hash is the hash of the active variant alternative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the variant to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the underlying value </dd></dl>

</div>
</div>
<a id="a0514f296deed170893498184033a474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0514f296deed170893498184033a474f">&#9670;&nbsp;</a></span>hash_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d73/namespacebit_1_1core.html#a20982aad790d41336dc1dc7a319a4829">hash_t</a> bit::core::hash_values </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes all the specified <code>args</code> and combines the results. </p>
<p>The computation for each of the <code>args</code> is determined by using ADL to determine the appropriate <code>hash_value</code> function to call</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash result </dd></dl>

</div>
</div>
<a id="aec9818a93d98871306da76168556a3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9818a93d98871306da76168556a3e7">&#9670;&nbsp;</a></span>holds_alternative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::core::holds_alternative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d2b/classbit_1_1core_1_1variant.html">variant</a>&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the variant v holds the alternative T. </p>
<p>The call is ill-formed if T appears more than once in Types...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>variant to examine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the variant currently holds the alternative T </dd></dl>

</div>
</div>
<a id="a04ec7ba016233046c155dc8565e08b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ec7ba016233046c155dc8565e08b5e">&#9670;&nbsp;</a></span>indeterminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::core::indeterminate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tribool is indeterminate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tribool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>t</code> is <code>indeterminate</code> </dd></dl>

</div>
</div>
<a id="ad433f17c43899a3cf2532a8df7489068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad433f17c43899a3cf2532a8df7489068">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::invoke </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(detail::invoke_impl(std::forward&lt; Func &gt;(function), std::forward&lt; Args &gt;(args)...))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke the Callable object <code>function</code> with the parameters <code>args</code>. </p>
<p>As by <code>INVOKE</code>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to be invoked </td></tr>
    <tr><td class="paramname">args</td><td>arguments to pass to <code>function</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bd42c34136c4aa85e715d5e907256ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd42c34136c4aa85e715d5e907256ef">&#9670;&nbsp;</a></span>make_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = detail::array_autodeduce, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::make_array </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt;  detail::array_return_type_t&lt; T, Args... &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make utility for creating a std::array. </p>
<p>If the return type is explicitly specified, no deduction take place; if the type is omitted, the return type is the common type of all inputs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the return type of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments for the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the arguments </dd></dl>

</div>
</div>
<a id="aa5392c28ec969231146b7924b5b816bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5392c28ec969231146b7924b5b816bd">&#9670;&nbsp;</a></span>make_compressed_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt;std::decay_t&lt;T1&gt;,std::decay_t&lt;T2&gt; &gt; bit::core::make_compressed_pair </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make utility to create a type-deduced compressed pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to assign to <code>first</code> </td></tr>
    <tr><td class="paramname">y</td><td>the value to assign to <code>second</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a385758d8cbdedd7ccf47abb1af349086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385758d8cbdedd7ccf47abb1af349086">&#9670;&nbsp;</a></span>make_exclusive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt;T&gt; bit::core::make_exclusive </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a> from the given <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to forward for the underlying constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an allocated <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a> </dd></dl>

</div>
</div>
<a id="af2c34577b8c71606e6656934ebe13535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c34577b8c71606e6656934ebe13535">&#9670;&nbsp;</a></span>make_from_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T bit::core::make_from_tuple </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an object of type  T, using the elements of the tuple t as the arguments to the constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>tuple whose elements to be used as arguments to the constructor of T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed T object </dd></dl>

</div>
</div>
<a id="aeb98239a989d7a4d511643e45b98bf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb98239a989d7a4d511643e45b98bf71">&#9670;&nbsp;</a></span>make_key_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt;0,Iterator&gt; bit::core::make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for making a tuple iterator that only iterates the first tuple element, which is the key in associative containers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple element iterator </dd></dl>

</div>
</div>
<a id="a3d8ec3aaf89c882b592115d42bc67d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8ec3aaf89c882b592115d42bc67d70">&#9670;&nbsp;</a></span>make_key_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Sentinel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::make_key_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Iterator &gt;, <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Sentinel &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the first value of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced <a class="el" href="../../d9/d73/namespacebit_1_1core.html#df/d18/structbit_1_1core_1_1tuple__element">tuple_element</a> range </dd></dl>

</div>
</div>
<a id="afce611d88f46a64e4a2480807cdc47b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce611d88f46a64e4a2480807cdc47b8">&#9670;&nbsp;</a></span>make_key_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::make_key_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(::bit::core::make_key_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a key range from another range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a key range </dd></dl>

</div>
</div>
<a id="af57604cec41abca73b3f51425b2bc07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57604cec41abca73b3f51425b2bc07d">&#9670;&nbsp;</a></span>make_lazy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt;T&gt; bit::core::make_lazy </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a lazy type from the given arguments. </p>
<p>This is just a wrapper around lazy&lt;T&gt;( in_place, args... );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lazy instance </dd></dl>

</div>
</div>
<a id="a0fcce9500567e547c2fc4721d861b67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcce9500567e547c2fc4721d861b67f">&#9670;&nbsp;</a></span>make_lazy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt;T&gt; bit::core::make_lazy </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a lazy type from the given arguments. </p>
<p>This is just a wrapper around lazy&lt;T&gt;( in_place, ilist, args... );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>an initializer list to forward to T's constructor </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lazy instance </dd></dl>

</div>
</div>
<a id="a696082f2cb7f9cdb953a66dc1521fe03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696082f2cb7f9cdb953a66dc1521fe03">&#9670;&nbsp;</a></span>make_lazy_generator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt;T&gt; bit::core::make_lazy_generator </td>
          <td>(</td>
          <td class="paramtype">Ctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>ctor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a lazy type that uses a generator function to generate the arguments that will be forwarded to T's constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the lazy to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctor</td><td>A function that returns a tuple of arguments used to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed lazy </dd></dl>

</div>
</div>
<a id="abb838cba647dd556b5981b76ed464c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb838cba647dd556b5981b76ed464c90">&#9670;&nbsp;</a></span>make_move_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Sentinel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">move_range</a>&lt;Iterator,Sentinel&gt; bit::core::make_move_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a movable range from a given <code>iterator</code> <code>sentinal</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="a1bdf325132341e974eb8423c9cfa78c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdf325132341e974eb8423c9cfa78c8">&#9670;&nbsp;</a></span>make_move_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::make_move_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(::bit::core::make_move_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a reverse range from a given <code>iterator</code> <code>sentinal</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irange</td><td>the range to deduce </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="a916d653daf216702003d0a122d6fd744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916d653daf216702003d0a122d6fd744">&#9670;&nbsp;</a></span>make_observer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt;T&gt; bit::core::make_observer </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a raw pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> </dd></dl>

</div>
</div>
<a id="a29089b0b119e21e2f65a5b7449f0c9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29089b0b119e21e2f65a5b7449f0c9ba">&#9670;&nbsp;</a></span>make_observer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;!std::is_same&lt;T,U&gt;::value &amp;&amp; std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt;T&gt; bit::core::make_observer </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a raw pointer, and coerces it to the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to convert to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> </dd></dl>

</div>
</div>
<a id="aecd28445da50e3e955e6744428192dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd28445da50e3e955e6744428192dbc">&#9670;&nbsp;</a></span>make_observer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Pointer , typename  = std::enable_if_t&lt;detail::is_ptr_observable&lt;Pointer&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt;T&gt; bit::core::make_observer </td>
          <td>(</td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a smart pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>explicit type of the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> </dd></dl>

</div>
</div>
<a id="ae7a09b31fcf37df74b65ba906bac5c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a09b31fcf37df74b65ba906bac5c20">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt;std::decay_t&lt;T&gt; &gt; bit::core::make_optional </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object from <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to construct the optional from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a665d9cab4ad4ec500efcc95a52d0a476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665d9cab4ad4ec500efcc95a52d0a476">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt;T&gt; bit::core::make_optional </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object of type <code>T</code> from the given <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args...</td><td>the arguments to pass to <code>T's</code> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00f18c94f402d0f37b1809825525d6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f18c94f402d0f37b1809825525d6fc">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt;T&gt; bit::core::make_optional </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object of type <code>T</code> from the given <code>il</code> <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer list to pass </td></tr>
    <tr><td class="paramname">args...</td><td>the arguments to pass to <code>T's</code> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63f59dd8230c8127468ac26d70025a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f59dd8230c8127468ac26d70025a00">&#9670;&nbsp;</a></span>make_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt;I,S&gt; bit::core::make_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="ab4b9ec1eedbb80a15cb163f203d7a9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b9ec1eedbb80a15cb163f203d7a9d4">&#9670;&nbsp;</a></span>make_reverse_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">detail::reverse_range_t</a>&lt;Range&gt; bit::core::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a reverse range from a given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>the range to deduce </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="affc04693e469b283cba46573bdcf42ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc04693e469b283cba46573bdcf42ec">&#9670;&nbsp;</a></span>make_tuple_element_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt;N,Iterator&gt; bit::core::make_tuple_element_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to type-deduce and make an iterator for iterating specific tuple elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple element iterator </dd></dl>

</div>
</div>
<a id="affb29edf2515986a0e1bb95a208ca3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb29edf2515986a0e1bb95a208ca3f3">&#9670;&nbsp;</a></span>make_tuple_element_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Iterator , typename Sentinel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">tuple_element_range</a>&lt;N,Iterator,Sentinel&gt; bit::core::make_tuple_element_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating values of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced <a class="el" href="../../d9/d73/namespacebit_1_1core.html#df/d18/structbit_1_1core_1_1tuple__element">tuple_element</a> range </dd></dl>

</div>
</div>
<a id="af13c16d01325a532ecc115e0b2a2f331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13c16d01325a532ecc115e0b2a2f331">&#9670;&nbsp;</a></span>make_tuple_element_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::make_tuple_element_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(::bit::core::make_tuple_element_range&lt; N &gt;(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a tuple element range from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced <a class="el" href="../../d9/d73/namespacebit_1_1core.html#df/d18/structbit_1_1core_1_1tuple__element">tuple_element</a> range </dd></dl>

</div>
</div>
<a id="a950ae8cea71fd2227bd7b2630d98b377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950ae8cea71fd2227bd7b2630d98b377">&#9670;&nbsp;</a></span>make_unexpected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../de/d25/classbit_1_1core_1_1unexpected__type.html">unexpected_type</a>&lt;E&gt; bit::core::make_unexpected </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an unexpected type <code>E</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>the unexpected type to make </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to forward </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unexpected type </dd></dl>

</div>
</div>
<a id="ae5463a0af76ffc03c812934a15b390d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5463a0af76ffc03c812934a15b390d4">&#9670;&nbsp;</a></span>make_value_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt;1,Iterator&gt; bit::core::make_value_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for making a tuple iterator that only iterates the second tuple element, which is the value in associative containers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple element iterator </dd></dl>

</div>
</div>
<a id="a5b0772faac81cf87c326051a340d3ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0772faac81cf87c326051a340d3ab5">&#9670;&nbsp;</a></span>make_value_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Sentinel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::make_value_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Iterator &gt;, <a class="el" href="../../db/d67/classbit_1_1core_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Sentinel &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the second value of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced <a class="el" href="../../d9/d73/namespacebit_1_1core.html#df/d18/structbit_1_1core_1_1tuple__element">tuple_element</a> range </dd></dl>

</div>
</div>
<a id="a8df7a2934a585ba992e7a67d400b3069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df7a2934a585ba992e7a67d400b3069">&#9670;&nbsp;</a></span>make_value_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::make_value_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(::bit::core::make_value_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a value range from another range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value range </dd></dl>

</div>
</div>
<a id="a9ec81bb60c8ba82b284aa4ed201a5bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec81bb60c8ba82b284aa4ed201a5bc9">&#9670;&nbsp;</a></span>make_zip_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range0 , typename... RangeN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::make_zip_range </td>
          <td>(</td>
          <td class="paramtype">Range0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; <a class="el" href="../../d6/d80/classbit_1_1core_1_1zip__iterator.html">zip_iterator</a>&lt; decltype(r0.begin()), decltype(rn.begin())... &gt;, <a class="el" href="../../d6/d80/classbit_1_1core_1_1zip__iterator.html">zip_iterator</a>&lt; decltype(r0.end()), decltype(rn.end())... &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a zip range from a selection of zip iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r0</td><td>the first range entry </td></tr>
    <tr><td class="paramname">rn</td><td>the rest of the range entries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="a896a8c4c1bd9b1f96ada40849312947f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896a8c4c1bd9b1f96ada40849312947f">&#9670;&nbsp;</a></span>on_scope_clean_exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d6/dbc/classbit_1_1core_1_1scope__guard.html">scope_guard</a>&lt;std::decay_t&lt;Fn&gt; &gt; bit::core::on_scope_clean_exit </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a scope guard that executes at the end of the scope only if no exception has propagated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to execute when a scope is without error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb23fe1fe030da04880550467c6a43ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb23fe1fe030da04880550467c6a43ef">&#9670;&nbsp;</a></span>on_scope_error_exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d6/dbc/classbit_1_1core_1_1scope__guard.html">scope_guard</a>&lt;std::decay_t&lt;Fn&gt; &gt; bit::core::on_scope_error_exit </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a scope guard that executes at the end of the scope only if an exception has been thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to execute when a scope is exited by error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a252978c0dc21f3e845a1b707fb469404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252978c0dc21f3e845a1b707fb469404">&#9670;&nbsp;</a></span>on_scope_exit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d6/dbc/classbit_1_1core_1_1scope__guard.html">scope_guard</a>&lt;std::decay_t&lt;Fn&gt; &gt; bit::core::on_scope_exit </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a scope guard that executes at the end of the scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to execute when a scope is exited </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5864ea98813dae6f823bf69f1acda15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5864ea98813dae6f823bf69f1acda15">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::core::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines inequality between two source_locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the left side of the equation </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the right side of the equation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is not equal to <code>rhs</code> </dd></dl>

</div>
</div>
<a id="ac9c3fe306a36400488aac7865f2f515e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c3fe306a36400488aac7865f2f515e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::core::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a8ec057975f883b02cc93367432c37376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec057975f883b02cc93367432c37376">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::core::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares inequality between the two basic_string_views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left string view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right string view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are different </dd></dl>

</div>
</div>
<a id="a11a8f151582e28e4faec8ac30a1d8337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a8f151582e28e4faec8ac30a1d8337">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::core::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the left string is less than the right substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left string view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right string view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the left string has a character less than the right string, or if the right string is shorter than the left string </dd></dl>

</div>
</div>
<a id="a2f751e76f09f7419be10785ba208bdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f751e76f09f7419be10785ba208bdbe">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CharT,Traits&gt;&amp; bit::core::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for ostream output of <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The output stream to print to </td></tr>
    <tr><td class="paramname">str</td><td>the string to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the output stream </dd></dl>

</div>
</div>
<a id="a4065c82582548eee5f85c97fe8cf6509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4065c82582548eee5f85c97fe8cf6509">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::core::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a2c397566b743fd24f8951624dd130e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c397566b743fd24f8951624dd130e05">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::core::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines equality between two source_locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the left side of the equation </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d3/d9a/classbit_1_1core_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the right side of the equation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is equal to <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a0771b6f752691243cf4adc7c28b8c0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0771b6f752691243cf4adc7c28b8c0dc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::core::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/classbit_1_1core_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a07f157daf774f817239f8b2b5e7dafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f157daf774f817239f8b2b5e7dafe1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::core::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares equality between the two basic_string_views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left string view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right string view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are the same </dd></dl>

</div>
</div>
<a id="aa4ed87890ad4048faeec2ac2b69e1c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ed87890ad4048faeec2ac2b69e1c39">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::core::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a89cf79e95613e1b933f66da7112cb32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cf79e95613e1b933f66da7112cb32b">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::core::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d8b/classbit_1_1core_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aac0e87256c02b6559307fb02f3f0ffb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0e87256c02b6559307fb02f3f0ffb4">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::core::size </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the size of a given array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the array </dd></dl>

</div>
</div>
<a id="af1a87a19f03eca7f4143c5f9045c7761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a87a19f03eca7f4143c5f9045c7761">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::core::size </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> -&gt;  decltype(c.size())</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the size of the specified container by delegating to the container's implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the container </dd></dl>

</div>
</div>
<a id="a48fa329af982df3616cd10ba72e11c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fa329af982df3616cd10ba72e11c9d">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d12/classbit_1_1core_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the two propagate_consts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d4ceae091a55bc103c8c7472607ae3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4ceae091a55bc103c8c7472607ae3a">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/da4/classbit_1_1core_1_1array__view.html">array_view</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps <code>lhs</code> with <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left array view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right array view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae963831f24546292f553fb9e5d06a08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae963831f24546292f553fb9e5d06a08d">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d7e/classbit_1_1core_1_1ring__array.html">ring_array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d7e/classbit_1_1core_1_1ring__array.html">ring_array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two circular arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left array </td></tr>
    <tr><td class="paramname">rhs</td><td>the right array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76f95f40c6b858137740e5f8fb36170b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f95f40c6b858137740e5f8fb36170b">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the instances of two <a class="el" href="../../da/d3e/classbit_1_1core_1_1offset__ptr.html" title="An offset pointer based on boost::offset_ptr. ">offset_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7bcacde1d6dd37205e7366afce04dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bcacde1d6dd37205e7366afce04dea">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> <code>lhs</code> with <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left one to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right one to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96affd163ea4d2e3689d3df45baa32e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96affd163ea4d2e3689d3df45baa32e1">&#9670;&nbsp;</a></span>swap() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d49/classbit_1_1core_1_1ring__deque.html">ring_deque</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d49/classbit_1_1core_1_1ring__deque.html">ring_deque</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two circular_deques. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left deque </td></tr>
    <tr><td class="paramname">rhs</td><td>the right deque </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34b0e01a85704c50710bac007b6d8aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b0e01a85704c50710bac007b6d8aaf">&#9670;&nbsp;</a></span>swap() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of <code>lhs</code> with <code>rhs</code>. </p>
<dl class="section post"><dt>Postcondition</dt><dd>the old contents of <code>lhs</code> are in <code>rhs</code> and the old contents of <code>rhs</code> are in <code>lhs</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a> to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right <a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html" title="An RAII wrapper around an allocated piece of memory with unique ownership semantics. ">exclusive_ptr</a> to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae43c1e99b659be1a036f7a3cf54af68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae43c1e99b659be1a036f7a3cf54af68">&#9670;&nbsp;</a></span>swap() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of two compressed_pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left <a class="el" href="../../d5/db6/classbit_1_1core_1_1compressed__pair.html" title="compressed_pair is a struct template that provides a way to store two heterogeneous objects as a sing...">compressed_pair</a> to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right compressed pair to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea94db7b3bc698956ebff8a2367c0a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea94db7b3bc698956ebff8a2367c0a4a">&#9670;&nbsp;</a></span>swap() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d27/classbit_1_1core_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of <code>lhs</code> with <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5aeff9341b2675bd0dd78cbb668e821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5aeff9341b2675bd0dd78cbb668e821">&#9670;&nbsp;</a></span>swap() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d69/classbit_1_1core_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of the lazy from <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left lazy to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right lazy to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22b26ad5ab22a544ec4ff8296d974409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b26ad5ab22a544ec4ff8296d974409">&#9670;&nbsp;</a></span>swap() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left optional to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right optional to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e195c7a8247a0098abbfa167aed1ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e195c7a8247a0098abbfa167aed1ade">&#9670;&nbsp;</a></span>to_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uintptr_t bit::core::to_address </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer <code>ptr</code> into an integral type representing the address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to convert to an integral value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the numeric address of the given pointer </dd></dl>

</div>
</div>
<a id="a915a6e7e98b28551c61ad8ae2c05d00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915a6e7e98b28551c61ad8ae2c05d00c">&#9670;&nbsp;</a></span>to_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt;T,N&gt; bit::core::to_array </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility to convert raw arrays to std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>a lvalue reference to an array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the std::array </dd></dl>

</div>
</div>
<a id="a7561593cbc1e74c86432beb2132d5c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7561593cbc1e74c86432beb2132d5c12">&#9670;&nbsp;</a></span>to_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt;T,N&gt; bit::core::to_array </td>
          <td>(</td>
          <td class="paramtype">T(&amp;&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility to convert raw arrays to std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>a rvalue reference to an array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the std::array </dd></dl>

</div>
</div>
<a id="ab63dd3adf63dc0c3427b881aa1f7d1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63dd3adf63dc0c3427b881aa1f7d1dc">&#9670;&nbsp;</a></span>uninitialized_construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::core::uninitialized_construct </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>last</code> ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range of the elements to copy </td></tr>
    <tr><td class="paramname">last</td><td>the end of the range of the elements to copy </td></tr>
    <tr><td class="paramname">copy</td><td>an instance to copy to each entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06e1e68b92eb5619d3ef30d36b11b934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e1e68b92eb5619d3ef30d36b11b934">&#9670;&nbsp;</a></span>uninitialized_construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::core::uninitialized_construct_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory location specified in <code>ptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">args...</td><td>The arguments to supply to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="a888eff8e740584365fe4113777227d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888eff8e740584365fe4113777227d55">&#9670;&nbsp;</a></span>uninitialized_construct_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator bit::core::uninitialized_construct_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>first</code> + <code>n</code> ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range of the elements to copy </td></tr>
    <tr><td class="paramname">n</td><td>the number of entries to construct </td></tr>
    <tr><td class="paramname">copy</td><td>an instance to copy to each entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bae090d25705f96983335e3cf3649f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bae090d25705f96983335e3cf3649f5">&#9670;&nbsp;</a></span>uninitialized_construct_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Size &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator bit::core::uninitialized_construct_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; ForwardIterator &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>first</code> + <code>n</code> ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range of the elements to copy </td></tr>
    <tr><td class="paramname">n</td><td>the number of entries to construct </td></tr>
    <tr><td class="paramname">copy</td><td>an instance to copy to each entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b1d00426bd79b404f141a23711002d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1d00426bd79b404f141a23711002d9">&#9670;&nbsp;</a></span>uninitialized_copy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::core::uninitialized_copy_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructs an instance of type <code>T</code> in the given memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">other</td><td>The instance to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="a7dc1326ae6cfa6a20e3a31f4f353d018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc1326ae6cfa6a20e3a31f4f353d018">&#9670;&nbsp;</a></span>uninitialized_default_construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::core::uninitialized_default_construct_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructs an instance of type <code>T</code> in the given memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="a972a3a74ef52c90323a0a08f54b27e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972a3a74ef52c90323a0a08f54b27e94">&#9670;&nbsp;</a></span>uninitialized_move_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::core::uninitialized_move_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructs an instance of type <code>T</code> in the given memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">other</td><td>The instance to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="aca8f5946de25b209a570a37b436c2c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8f5946de25b209a570a37b436c2c40">&#9670;&nbsp;</a></span>uninitialized_tuple_construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::core::uninitialized_tuple_construct_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>tuple</code> at the memory location specified in <code>ptr</code>. </p>
<p>This forwards the arguments from the <code>tuple</code> to the constructor of T, as if by calling make_from_tuple</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple containing arguments to forward to T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer ot the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4e94d709bc3526358602db98d408e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e94d709bc3526358602db98d408e71a">&#9670;&nbsp;</a></span>bool_constant_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::core::bool_constant_v = <a class="el" href="../../d9/dc6/structbit_1_1core_1_1bool__constant.html">bool_constant</a>&lt;B&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience template variable to extract bool_constant::value. </p>
<p>This is always the same as the template variable (trivial) </p>

<p class="definition">Definition at line <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html#l00056">56</a> of file <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html">bool_constant.hpp</a>.</p>

</div>
</div>
<a id="a504eba41c7fd7d1dbd5e04f8579e3630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504eba41c7fd7d1dbd5e04f8579e3630">&#9670;&nbsp;</a></span>make_observer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html">observer_ptr</a>&lt;std::remove_pointer_t&lt;decltype(std::declval&lt;const Pointer&amp;&gt;).<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a47d690dc876b4908b42c8d33f73fe6a9">get</a>())&gt; &gt; bit::core::make_observer(const Pointer &amp;ptr) noexcept</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a smart pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="../../d5/d93/classbit_1_1core_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/d88/observer__ptr_8hpp_source.html#l00378">378</a> of file <a class="el" href="../../d9/d88/observer__ptr_8hpp_source.html">observer_ptr.hpp</a>.</p>

</div>
</div>
<a id="aa915b880bed22d4ce34b97c241882a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa915b880bed22d4ce34b97c241882a4f">&#9670;&nbsp;</a></span>size_constant_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::core::size_constant_v = <a class="el" href="../../d1/d94/structbit_1_1core_1_1size__constant.html">size_constant</a>&lt;Size&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience template variable to extract size_constant::value. </p>
<p>This is always the same as the template variable (trivial) </p>

<p class="definition">Definition at line <a class="el" href="../../de/dcd/size__constant_8hpp_source.html#l00059">59</a> of file <a class="el" href="../../de/dcd/size__constant_8hpp_source.html">size_constant.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
