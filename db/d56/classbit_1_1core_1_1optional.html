<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bit::core: bit::core::optional&lt; T &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bit::core
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d9f/namespacebit.html">bit</a></li><li class="navelem"><a class="el" href="../../d9/d73/namespacebit_1_1core.html">core</a></li><li class="navelem"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d3/d24/classbit_1_1core_1_1optional-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bit::core::optional&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class template optional manages an optional contained value, i.e. a value that may or may not be present.  
 <a href="../../db/d56/classbit_1_1core_1_1optional.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../db/dd5/optional_8hpp_source.html">optional.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bit::core::optional&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../db/d56/classbit_1_1core_1_1optional.png" usemap="#bit::core::optional_3C_20T_20_3E_map" alt=""/>
  <map id="bit::core::optional_3C_20T_20_3E_map" name="bit::core::optional_3C_20T_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a414d40491dee22e31c946483afa671fb"><td class="memItemLeft" align="right" valign="top"><a id="a414d40491dee22e31c946483afa671fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> = T</td></tr>
<tr class="memdesc:a414d40491dee22e31c946483afa671fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying type of this Optional. <br /></td></tr>
<tr class="separator:a414d40491dee22e31c946483afa671fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e7df85797e811ba77cf2a32351afa64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a6e7df85797e811ba77cf2a32351afa64">optional</a> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a78b67a176c3a604dee4c2d4d4d8612a1">enable_overload_if_t</a>&lt; std::is_copy_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&gt; other)</td></tr>
<tr class="memdesc:a6e7df85797e811ba77cf2a32351afa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an optional.  <a href="#a6e7df85797e811ba77cf2a32351afa64">More...</a><br /></td></tr>
<tr class="separator:a6e7df85797e811ba77cf2a32351afa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06dabe8952e2570e03838ebc117f518"><td class="memItemLeft" align="right" valign="top"><a id="aa06dabe8952e2570e03838ebc117f518"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>optional</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a21cd3956f5221a64247d167f225f0752">disable_overload_if_t</a>&lt; std::is_copy_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&gt; other)=delete</td></tr>
<tr class="separator:aa06dabe8952e2570e03838ebc117f518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83f85e8531b34c66f8360a009ff7588"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#ad83f85e8531b34c66f8360a009ff7588">optional</a> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a78b67a176c3a604dee4c2d4d4d8612a1">enable_overload_if_t</a>&lt; std::is_move_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&amp;&gt; other)</td></tr>
<tr class="memdesc:ad83f85e8531b34c66f8360a009ff7588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs an optional.  <a href="#ad83f85e8531b34c66f8360a009ff7588">More...</a><br /></td></tr>
<tr class="separator:ad83f85e8531b34c66f8360a009ff7588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afda85ca23173fc2330c0ea1ca4e1ce"><td class="memItemLeft" align="right" valign="top"><a id="a7afda85ca23173fc2330c0ea1ca4e1ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>optional</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a21cd3956f5221a64247d167f225f0752">disable_overload_if_t</a>&lt; std::is_move_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&amp;&gt; other)=delete</td></tr>
<tr class="separator:a7afda85ca23173fc2330c0ea1ca4e1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a081bc1d5dc90685cb3870ec696c74"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = std::enable_if_t&lt;std::is_constructible&lt;T,Args...&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:af7a081bc1d5dc90685cb3870ec696c74"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#af7a081bc1d5dc90685cb3870ec696c74">optional</a> (<a class="el" href="../../dd/d6f/structbit_1_1core_1_1in__place__t.html">in_place_t</a> tag, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af7a081bc1d5dc90685cb3870ec696c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optional object that contains a value.  <a href="#af7a081bc1d5dc90685cb3870ec696c74">More...</a><br /></td></tr>
<tr class="separator:af7a081bc1d5dc90685cb3870ec696c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef801af16f8646300de5815cbf1f36af"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Args, typename  = std::enable_if_t&lt;std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aef801af16f8646300de5815cbf1f36af"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#aef801af16f8646300de5815cbf1f36af">optional</a> (<a class="el" href="../../dd/d6f/structbit_1_1core_1_1in__place__t.html">in_place_t</a>, std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aef801af16f8646300de5815cbf1f36af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optional object that contains a value.  <a href="#aef801af16f8646300de5815cbf1f36af">More...</a><br /></td></tr>
<tr class="separator:aef801af16f8646300de5815cbf1f36af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55bc3e80884c1e37f54c02d6a866887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#ab55bc3e80884c1e37f54c02d6a866887">operator=</a> (<a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>)</td></tr>
<tr class="memdesc:ab55bc3e80884c1e37f54c02d6a866887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns this optional to be a null optional.  <a href="#ab55bc3e80884c1e37f54c02d6a866887">More...</a><br /></td></tr>
<tr class="separator:ab55bc3e80884c1e37f54c02d6a866887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb59be33d6f5d505e02819a735977cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#acb59be33d6f5d505e02819a735977cc6">operator=</a> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a78b67a176c3a604dee4c2d4d4d8612a1">enable_overload_if_t</a>&lt; std::is_copy_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a> &amp;&amp;std::is_copy_assignable&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&gt; other)</td></tr>
<tr class="memdesc:acb59be33d6f5d505e02819a735977cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigns the optional stored in <code>other</code>.  <a href="#acb59be33d6f5d505e02819a735977cc6">More...</a><br /></td></tr>
<tr class="separator:acb59be33d6f5d505e02819a735977cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac6186f048895d0ca44610fb885ba28"><td class="memItemLeft" align="right" valign="top"><a id="a6ac6186f048895d0ca44610fb885ba28"></a>
<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a21cd3956f5221a64247d167f225f0752">disable_overload_if_t</a>&lt; std::is_copy_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a> &amp;&amp;std::is_copy_assignable&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&gt; other)=delete</td></tr>
<tr class="separator:a6ac6186f048895d0ca44610fb885ba28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e01eca2732b976689256916c236e8e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a8e01eca2732b976689256916c236e8e4">operator=</a> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a78b67a176c3a604dee4c2d4d4d8612a1">enable_overload_if_t</a>&lt; std::is_move_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a> &amp;&amp;std::is_move_assignable&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&amp;&gt; other)</td></tr>
<tr class="memdesc:a8e01eca2732b976689256916c236e8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assigns the optional stored in <code>other</code>.  <a href="#a8e01eca2732b976689256916c236e8e4">More...</a><br /></td></tr>
<tr class="separator:a8e01eca2732b976689256916c236e8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cd217495f3f335fa4919515cfced6e"><td class="memItemLeft" align="right" valign="top"><a id="a17cd217495f3f335fa4919515cfced6e"></a>
<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a21cd3956f5221a64247d167f225f0752">disable_overload_if_t</a>&lt; std::is_move_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a> &amp;&amp;std::is_move_assignable&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&amp;&gt; other)=delete</td></tr>
<tr class="separator:a17cd217495f3f335fa4919515cfced6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822e56c857733fccfe824612fda941bd"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename  = std::enable_if_t&lt;detail::optional_is_value_assignable&lt;T,U&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a822e56c857733fccfe824612fda941bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a822e56c857733fccfe824612fda941bd">operator=</a> (U &amp;&amp;<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>)</td></tr>
<tr class="memdesc:a822e56c857733fccfe824612fda941bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perfect-forwarded assignment.  <a href="#a822e56c857733fccfe824612fda941bd">More...</a><br /></td></tr>
<tr class="separator:a822e56c857733fccfe824612fda941bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8b090358f6867de6cc631ed242012b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:afc8b090358f6867de6cc631ed242012b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#afc8b090358f6867de6cc631ed242012b">operator=</a> (std::enable_if_t&lt; <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">detail::optional_is_copy_convert_assignable</a>&lt; T, U &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&gt; other)</td></tr>
<tr class="memdesc:afc8b090358f6867de6cc631ed242012b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the state of <code>other</code>.  <a href="#afc8b090358f6867de6cc631ed242012b">More...</a><br /></td></tr>
<tr class="separator:afc8b090358f6867de6cc631ed242012b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78052cfd9402273c3fc496ea2d404349"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a78052cfd9402273c3fc496ea2d404349"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a78052cfd9402273c3fc496ea2d404349">operator=</a> (std::enable_if_t&lt; <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">detail::optional_is_move_convert_assignable</a>&lt; T, U &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;&gt; other)</td></tr>
<tr class="memdesc:a78052cfd9402273c3fc496ea2d404349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the state of <code>other</code>.  <a href="#a78052cfd9402273c3fc496ea2d404349">More...</a><br /></td></tr>
<tr class="separator:a78052cfd9402273c3fc496ea2d404349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e1a0030e8bd73410c1e08c80953cc8"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a24e1a0030e8bd73410c1e08c80953cc8">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a24e1a0030e8bd73410c1e08c80953cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> contains a value.  <a href="#a24e1a0030e8bd73410c1e08c80953cc8">More...</a><br /></td></tr>
<tr class="separator:a24e1a0030e8bd73410c1e08c80953cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a02d9b500b2bccc88094d807addcdaf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a5a02d9b500b2bccc88094d807addcdaf">has_value</a> () const noexcept</td></tr>
<tr class="memdesc:a5a02d9b500b2bccc88094d807addcdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>*this</code> contains a value.  <a href="#a5a02d9b500b2bccc88094d807addcdaf">More...</a><br /></td></tr>
<tr class="separator:a5a02d9b500b2bccc88094d807addcdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaf0aaec69e81d55d1e9622e4a277c0"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename  = std::enable_if_t&lt;conjunction&lt;is_invocable&lt;Fn,const T&amp;&gt;,                                         is_optional&lt;invoke_result_t&lt;Fn,const T&amp;&gt;&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a3eaf0aaec69e81d55d1e9622e4a277c0"><td class="memTemplItemLeft" align="right" valign="top">invoke_result_t&lt; Fn, const T &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a3eaf0aaec69e81d55d1e9622e4a277c0">flat_map</a> (Fn &amp;&amp;fn) const</td></tr>
<tr class="memdesc:a3eaf0aaec69e81d55d1e9622e4a277c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the function <code>fn</code> with this optional as the argument.  <a href="#a3eaf0aaec69e81d55d1e9622e4a277c0">More...</a><br /></td></tr>
<tr class="separator:a3eaf0aaec69e81d55d1e9622e4a277c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44aea889caccc4972029b32182ffe451"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename  = std::enable_if_t&lt;is_invocable&lt;Fn,const T&amp;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a44aea889caccc4972029b32182ffe451"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; invoke_result_t&lt; Fn, const T &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a44aea889caccc4972029b32182ffe451">map</a> (Fn &amp;&amp;fn) const</td></tr>
<tr class="memdesc:a44aea889caccc4972029b32182ffe451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes this function <code>fn</code> with this optional as the argument.  <a href="#a44aea889caccc4972029b32182ffe451">More...</a><br /></td></tr>
<tr class="separator:a44aea889caccc4972029b32182ffe451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed857da053914817a13117384c2ae26c"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aed857da053914817a13117384c2ae26c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; std::decay_t&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#aed857da053914817a13117384c2ae26c">and_then</a> (U &amp;&amp;u) const</td></tr>
<tr class="memdesc:aed857da053914817a13117384c2ae26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>u</code> if this optional contains a value, nullopt otherwise.  <a href="#aed857da053914817a13117384c2ae26c">More...</a><br /></td></tr>
<tr class="separator:aed857da053914817a13117384c2ae26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb99ded93f533ae5314303434f5b2d01"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aeb99ded93f533ae5314303434f5b2d01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; std::decay_t&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#aeb99ded93f533ae5314303434f5b2d01">or_else</a> (U &amp;&amp;u) const</td></tr>
<tr class="memdesc:aeb99ded93f533ae5314303434f5b2d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>u</code> if this optional does not contain a value, nullopt otherwise.  <a href="#aeb99ded93f533ae5314303434f5b2d01">More...</a><br /></td></tr>
<tr class="separator:aeb99ded93f533ae5314303434f5b2d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a3e8b886467cfcb2759b410c5a9442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a49a3e8b886467cfcb2759b410c5a9442">swap</a> (<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> &amp;other)</td></tr>
<tr class="memdesc:a49a3e8b886467cfcb2759b410c5a9442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents with those of other.  <a href="#a49a3e8b886467cfcb2759b410c5a9442">More...</a><br /></td></tr>
<tr class="separator:a49a3e8b886467cfcb2759b410c5a9442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c03b891355b8e4b30230502b693d7de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4c03b891355b8e4b30230502b693d7de">reset</a> () noexcept(std::is_nothrow_destructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>)</td></tr>
<tr class="memdesc:a4c03b891355b8e4b30230502b693d7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>*this</code> contains a value, destroy that value as if by <code><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943" title="Returns the contained value. ">value()</a></code>.T::~T().  <a href="#a4c03b891355b8e4b30230502b693d7de">More...</a><br /></td></tr>
<tr class="separator:a4c03b891355b8e4b30230502b693d7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dad403b669a27eca24c6d1c3077782"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af0dad403b669a27eca24c6d1c3077782"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#af0dad403b669a27eca24c6d1c3077782">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:af0dad403b669a27eca24c6d1c3077782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the contained value in-place.  <a href="#af0dad403b669a27eca24c6d1c3077782">More...</a><br /></td></tr>
<tr class="separator:af0dad403b669a27eca24c6d1c3077782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4890e8897b502acd09a56f8014245d56"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a4890e8897b502acd09a56f8014245d56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4890e8897b502acd09a56f8014245d56">emplace</a> (std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4890e8897b502acd09a56f8014245d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the contained value in-place.  <a href="#a4890e8897b502acd09a56f8014245d56">More...</a><br /></td></tr>
<tr class="separator:a4890e8897b502acd09a56f8014245d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7c5f002893d4a9488a60dc7f63cabbb3"><td class="memItemLeft" align="right" valign="top"><a id="a7c5f002893d4a9488a60dc7f63cabbb3"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a7c5f002893d4a9488a60dc7f63cabbb3">optional</a> () noexcept</td></tr>
<tr class="memdesc:a7c5f002893d4a9488a60dc7f63cabbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optional that does not contain a value. <br /></td></tr>
<tr class="separator:a7c5f002893d4a9488a60dc7f63cabbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72a086edb007233066d3933e0d3ac8a"><td class="memItemLeft" align="right" valign="top"><a id="ac72a086edb007233066d3933e0d3ac8a"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#ac72a086edb007233066d3933e0d3ac8a">optional</a> (<a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="memdesc:ac72a086edb007233066d3933e0d3ac8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optional that does not contain a value. <br /></td></tr>
<tr class="separator:ac72a086edb007233066d3933e0d3ac8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a49533d3fcf17f08435b264cdd0d55ad1"><td class="memTemplParams" colspan="2">template&lt;typename U , std::enable_if_t&lt; detail::optional_is_copy_convertible&lt; T, U &gt;::value &amp;&amp;std::is_convertible&lt; const U &amp;, T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a49533d3fcf17f08435b264cdd0d55ad1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a49533d3fcf17f08435b264cdd0d55ad1">optional</a> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;other)</td></tr>
<tr class="memdesc:a49533d3fcf17f08435b264cdd0d55ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor.  <a href="#a49533d3fcf17f08435b264cdd0d55ad1">More...</a><br /></td></tr>
<tr class="separator:a49533d3fcf17f08435b264cdd0d55ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49533d3fcf17f08435b264cdd0d55ad1"><td class="memTemplParams" colspan="2">template&lt;typename U , std::enable_if_t&lt; detail::optional_is_copy_convertible&lt; T, U &gt;::value &amp;&amp;!std::is_convertible&lt; const U &amp;, T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a49533d3fcf17f08435b264cdd0d55ad1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a49533d3fcf17f08435b264cdd0d55ad1">optional</a> (const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;other)</td></tr>
<tr class="memdesc:a49533d3fcf17f08435b264cdd0d55ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor.  <a href="#a49533d3fcf17f08435b264cdd0d55ad1">More...</a><br /></td></tr>
<tr class="separator:a49533d3fcf17f08435b264cdd0d55ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a103a1685fb62f2fa3bfca04a65c63cfc"><td class="memTemplParams" colspan="2">template&lt;typename U , std::enable_if_t&lt; detail::optional_is_move_convertible&lt; T, U &gt;::value &amp;&amp;std::is_convertible&lt; U &amp;&amp;, T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a103a1685fb62f2fa3bfca04a65c63cfc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a103a1685fb62f2fa3bfca04a65c63cfc">optional</a> (<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a103a1685fb62f2fa3bfca04a65c63cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move constructor.  <a href="#a103a1685fb62f2fa3bfca04a65c63cfc">More...</a><br /></td></tr>
<tr class="separator:a103a1685fb62f2fa3bfca04a65c63cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103a1685fb62f2fa3bfca04a65c63cfc"><td class="memTemplParams" colspan="2">template&lt;typename U , std::enable_if_t&lt; detail::optional_is_move_convertible&lt; T, U &gt;::value &amp;&amp;!std::is_convertible&lt; U &amp;&amp;, T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a103a1685fb62f2fa3bfca04a65c63cfc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a103a1685fb62f2fa3bfca04a65c63cfc">optional</a> (<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a103a1685fb62f2fa3bfca04a65c63cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move constructor.  <a href="#a103a1685fb62f2fa3bfca04a65c63cfc">More...</a><br /></td></tr>
<tr class="separator:a103a1685fb62f2fa3bfca04a65c63cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a20e852381d96f28d018964262e349c7b"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, std::enable_if_t&lt; detail::optional_is_value_convertible&lt; T, U &gt;::value &amp;&amp;std::is_convertible&lt; U &amp;&amp;, T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a20e852381d96f28d018964262e349c7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a20e852381d96f28d018964262e349c7b">optional</a> (U &amp;&amp;<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>)</td></tr>
<tr class="memdesc:a20e852381d96f28d018964262e349c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optional object that contains a value.  <a href="#a20e852381d96f28d018964262e349c7b">More...</a><br /></td></tr>
<tr class="separator:a20e852381d96f28d018964262e349c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e852381d96f28d018964262e349c7b"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, std::enable_if_t&lt; detail::optional_is_value_convertible&lt; T, U &gt;::value &amp;&amp;!std::is_convertible&lt; U &amp;&amp;, T &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a20e852381d96f28d018964262e349c7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a20e852381d96f28d018964262e349c7b">optional</a> (U &amp;&amp;<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>)</td></tr>
<tr class="memdesc:a20e852381d96f28d018964262e349c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an optional object that contains a value.  <a href="#a20e852381d96f28d018964262e349c7b">More...</a><br /></td></tr>
<tr class="separator:a20e852381d96f28d018964262e349c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab6ad2c2e6d15f15a570b8ca726e67362"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#ab6ad2c2e6d15f15a570b8ca726e67362">operator-&gt;</a> () noexcept</td></tr>
<tr class="memdesc:ab6ad2c2e6d15f15a570b8ca726e67362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#ab6ad2c2e6d15f15a570b8ca726e67362">More...</a><br /></td></tr>
<tr class="separator:ab6ad2c2e6d15f15a570b8ca726e67362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa625977d80672a6d5d6b039c7716040"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#afa625977d80672a6d5d6b039c7716040">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:afa625977d80672a6d5d6b039c7716040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#afa625977d80672a6d5d6b039c7716040">More...</a><br /></td></tr>
<tr class="separator:afa625977d80672a6d5d6b039c7716040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8beb4897e960ee7aedd6d5995adde9c7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a8beb4897e960ee7aedd6d5995adde9c7">operator*</a> () &amp;noexcept</td></tr>
<tr class="memdesc:a8beb4897e960ee7aedd6d5995adde9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#a8beb4897e960ee7aedd6d5995adde9c7">More...</a><br /></td></tr>
<tr class="separator:a8beb4897e960ee7aedd6d5995adde9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14561db34b29ff82db584b1b873eaa24"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a14561db34b29ff82db584b1b873eaa24">operator*</a> () &amp;&amp;noexcept</td></tr>
<tr class="memdesc:a14561db34b29ff82db584b1b873eaa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#a14561db34b29ff82db584b1b873eaa24">More...</a><br /></td></tr>
<tr class="separator:a14561db34b29ff82db584b1b873eaa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc172a1590b1f334e71273cbf3797d3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#accc172a1590b1f334e71273cbf3797d3">operator*</a> () const &amp;noexcept</td></tr>
<tr class="memdesc:accc172a1590b1f334e71273cbf3797d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#accc172a1590b1f334e71273cbf3797d3">More...</a><br /></td></tr>
<tr class="separator:accc172a1590b1f334e71273cbf3797d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9ad409a5edfdb807109a4d925ee544"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> const  &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a5b9ad409a5edfdb807109a4d925ee544">operator*</a> () const &amp;&amp;noexcept</td></tr>
<tr class="memdesc:a5b9ad409a5edfdb807109a4d925ee544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the contained value.  <a href="#a5b9ad409a5edfdb807109a4d925ee544">More...</a><br /></td></tr>
<tr class="separator:a5b9ad409a5edfdb807109a4d925ee544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4398f940d9db67f77733a2093273b943"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a> () &amp;</td></tr>
<tr class="memdesc:a4398f940d9db67f77733a2093273b943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value.  <a href="#a4398f940d9db67f77733a2093273b943">More...</a><br /></td></tr>
<tr class="separator:a4398f940d9db67f77733a2093273b943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264a3945ec48686fe1f57eab24aa9146"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a264a3945ec48686fe1f57eab24aa9146">value</a> () const &amp;</td></tr>
<tr class="memdesc:a264a3945ec48686fe1f57eab24aa9146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value.  <a href="#a264a3945ec48686fe1f57eab24aa9146">More...</a><br /></td></tr>
<tr class="separator:a264a3945ec48686fe1f57eab24aa9146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa14377b00f68f008410136b80d225340"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#aa14377b00f68f008410136b80d225340">value</a> () &amp;&amp;</td></tr>
<tr class="memdesc:aa14377b00f68f008410136b80d225340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value.  <a href="#aa14377b00f68f008410136b80d225340">More...</a><br /></td></tr>
<tr class="separator:aa14377b00f68f008410136b80d225340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aeba634d2122a8d982101c4c787a31"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a71aeba634d2122a8d982101c4c787a31">value</a> () const &amp;&amp;</td></tr>
<tr class="memdesc:a71aeba634d2122a8d982101c4c787a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value.  <a href="#a71aeba634d2122a8d982101c4c787a31">More...</a><br /></td></tr>
<tr class="separator:a71aeba634d2122a8d982101c4c787a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2c8becef3c1135f61a09aae65978bc8a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a2c8becef3c1135f61a09aae65978bc8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a2c8becef3c1135f61a09aae65978bc8a">value_or</a> (U &amp;&amp;default_value) const &amp;</td></tr>
<tr class="memdesc:a2c8becef3c1135f61a09aae65978bc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value if <code>*this</code> has a value, otherwise returns <code>default_value</code>.  <a href="#a2c8becef3c1135f61a09aae65978bc8a">More...</a><br /></td></tr>
<tr class="separator:a2c8becef3c1135f61a09aae65978bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366b95ec6b40ff66e69e0d8418478e85"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a366b95ec6b40ff66e69e0d8418478e85"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a366b95ec6b40ff66e69e0d8418478e85">value_or</a> (U &amp;&amp;default_value) &amp;&amp;</td></tr>
<tr class="memdesc:a366b95ec6b40ff66e69e0d8418478e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contained value if <code>*this</code> has a value, otherwise returns <code>default_value</code>.  <a href="#a366b95ec6b40ff66e69e0d8418478e85">More...</a><br /></td></tr>
<tr class="separator:a366b95ec6b40ff66e69e0d8418478e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class bit::core::optional&lt; T &gt;</h3>

<p>The class template optional manages an optional contained value, i.e. a value that may or may not be present. </p>
<p>A common use case for optional is the return value of a function that may fail. As opposed to other approaches, such as std::pair&lt;T,bool&gt;, optional handles expensive to construct objects well and is more readable, as the intent is expressed explicitly.</p>
<p>Any instance of optional&lt;T&gt; at any given point in time either contains a value or does not contain a value.</p>
<p>If an optional&lt;T&gt; contains a value, the value is guaranteed to be allocated as part of the optional object footprint, i.e. no dynamic memory allocation ever takes place. Thus, an optional object models an object, not a pointer, even though the <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a8beb4897e960ee7aedd6d5995adde9c7" title="Accesses the contained value. ">operator*()</a> and <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#ab6ad2c2e6d15f15a570b8ca726e67362" title="Accesses the contained value. ">operator-&gt;()</a> are defined.</p>
<p>When an object of type optional&lt;T&gt; is contextually converted to bool, the conversion returns true if the object contains a value and false if it does not contain a value.</p>
<p>The optional object contains a value in the following conditions:</p><ul>
<li>The object is initialized with a value of type T</li>
<li>The object is assigned from another optional that contains a value.</li>
<li>The object does not contain a value in the following conditions:</li>
<li>The object is default-initialized.</li>
<li>The object is initialized with a value of <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html" title="This type represents null optional value. ">nullopt_t</a> or an optional object that does not contain a value.</li>
<li>The object is assigned from a value of <a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html" title="This type represents null optional value. ">nullopt_t</a> or from an optional that does not contain a value</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../db/dd5/optional_8hpp_source.html#l00059">59</a> of file <a class="el" href="../../db/dd5/optional_8hpp_source.html">optional.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6e7df85797e811ba77cf2a32351afa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7df85797e811ba77cf2a32351afa64">&#9670;&nbsp;</a></span>optional() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a78b67a176c3a604dee4c2d4d4d8612a1">enable_overload_if_t</a>&lt; std::is_copy_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;&gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructs an optional. </p>
<p>If <code>other</code> contains a value, initializes the contained value as if direct-initializing (but not direct-list-initializing) an object of type T with the expression *other.</p>
<p>If other does not contain a value, constructs an object that does not contain a value.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is defined as deleted if std::is_copy_constructible_v&lt;T&gt; is false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the optional to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad83f85e8531b34c66f8360a009ff7588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83f85e8531b34c66f8360a009ff7588">&#9670;&nbsp;</a></span>optional() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a78b67a176c3a604dee4c2d4d4d8612a1">enable_overload_if_t</a>&lt; std::is_move_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;&amp;&gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructs an optional. </p>
<p>If other contains a value, initializes the contained value as if direct-initializing (but not direct-list-initializing) an object of type T with the expression std::move(*other) and does not make other empty: a moved-from optional still contains a value, but the value itself is moved from.</p>
<p>If other does not contain a value, constructs an object that does not contain a value.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is defined as deleted if std::is_move_constructible_v&lt;T&gt; is false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the optional to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49533d3fcf17f08435b264cdd0d55ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49533d3fcf17f08435b264cdd0d55ad1">&#9670;&nbsp;</a></span>optional() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , std::enable_if_t&lt; detail::optional_is_copy_convertible&lt; T, U &gt;::value &amp;&amp;std::is_convertible&lt; const U &amp;, T &gt;::value &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converting copy constructor. </p>
<p>If other doesn't contain a value, constructs an optional object that does not contain a value. Otherwise, constructs an optional object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression *other.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li>std::is_constructible_v&lt;T, const U&amp;&gt; is true</li>
<li>T is not constructible or convertible from any expression of type (possibly const) optional&lt;U&gt;, i.e., the following 8 type traits are all false:<ul>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
</ul>
</li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if std::is_convertible_v&lt;const U&amp;, T&gt; is false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49533d3fcf17f08435b264cdd0d55ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49533d3fcf17f08435b264cdd0d55ad1">&#9670;&nbsp;</a></span>optional() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , std::enable_if_t&lt; detail::optional_is_copy_convertible&lt; T, U &gt;::value &amp;&amp;!std::is_convertible&lt; const U &amp;, T &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting copy constructor. </p>
<p>If other doesn't contain a value, constructs an optional object that does not contain a value. Otherwise, constructs an optional object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression *other.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li>std::is_constructible_v&lt;T, const U&amp;&gt; is true</li>
<li>T is not constructible or convertible from any expression of type (possibly const) optional&lt;U&gt;, i.e., the following 8 type traits are all false:<ul>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
</ul>
</li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if std::is_convertible_v&lt;const U&amp;, T&gt; is false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other type to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a103a1685fb62f2fa3bfca04a65c63cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103a1685fb62f2fa3bfca04a65c63cfc">&#9670;&nbsp;</a></span>optional() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , std::enable_if_t&lt; detail::optional_is_move_convertible&lt; T, U &gt;::value &amp;&amp;std::is_convertible&lt; U &amp;&amp;, T &gt;::value &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converting move constructor. </p>
<p>If other doesn't contain a value, constructs an optional object that does not contain a value. Otherwise, constructs an optional object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression std::move(*other).</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li>std::is_constructible_v&lt;T, U&amp;&amp;&gt; is true</li>
<li>T is not constructible or convertible from any expression of type (possibly const) optional&lt;U&gt;, i.e., the following 8 type traits are all false:<ul>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
</ul>
</li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if std::is_convertible_v&lt;U&amp;&amp;, T&gt; is false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a103a1685fb62f2fa3bfca04a65c63cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103a1685fb62f2fa3bfca04a65c63cfc">&#9670;&nbsp;</a></span>optional() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , std::enable_if_t&lt; detail::optional_is_move_convertible&lt; T, U &gt;::value &amp;&amp;!std::is_convertible&lt; U &amp;&amp;, T &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting move constructor. </p>
<p>If other doesn't contain a value, constructs an optional object that does not contain a value. Otherwise, constructs an optional object that contains a value, initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression std::move(*other).</p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not participate in overload resolution unless the following conditions are met:<ul>
<li>std::is_constructible_v&lt;T, U&amp;&amp;&gt; is true</li>
<li>T is not constructible or convertible from any expression of type (possibly const) optional&lt;U&gt;, i.e., the following 8 type traits are all false:<ul>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
</ul>
</li>
</ul>
</dd>
<dd>
This constructor is explicit if and only if std::is_convertible_v&lt;U&amp;&amp;, T&gt; is false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7a081bc1d5dc90685cb3870ec696c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a081bc1d5dc90685cb3870ec696c74">&#9670;&nbsp;</a></span>optional() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = std::enable_if_t&lt;std::is_constructible&lt;T,Args...&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d6f/structbit_1_1core_1_1in__place__t.html">in_place_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an optional object that contains a value. </p>
<p>the value is initialized as if direct-initializing (but not direct-list-initializing) an object of type T from the arguments std::forward&lt;Args&gt;(args)...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The in_place tag </td></tr>
    <tr><td class="paramname">args...</td><td>the arguments to pass to T's constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef801af16f8646300de5815cbf1f36af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef801af16f8646300de5815cbf1f36af">&#9670;&nbsp;</a></span>optional() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename... Args, typename  = std::enable_if_t&lt;std::is_constructible&lt;T, std::initializer_list&lt;U&gt;&amp;, Args...&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/d6f/structbit_1_1core_1_1in__place__t.html">in_place_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an optional object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type T from the arguments std::forward&lt;std::initializer_list&lt;U&gt;&gt;(ilist), std::forward&lt;Args&gt;(args)...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The in_place tag </td></tr>
    <tr><td class="paramname">ilist</td><td>An initializer list of entries to forward </td></tr>
    <tr><td class="paramname">args...</td><td>the arguments to pass to T's constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20e852381d96f28d018964262e349c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e852381d96f28d018964262e349c7b">&#9670;&nbsp;</a></span>optional() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T, std::enable_if_t&lt; detail::optional_is_value_convertible&lt; T, U &gt;::value &amp;&amp;std::is_convertible&lt; U &amp;&amp;, T &gt;::value &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an optional object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression value.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is constexpr if the constructor of T selected by direct-initialization is constexpr</dd>
<dd>
This constructor does not participate in overload resolution unless std::is_constructible_v&lt;T, U&amp;&amp;&gt; is true and std::decay_t&lt;U&gt; is neither std::in_place_t nor optional&lt;T&gt;.</dd>
<dd>
This constructor is explicit if and only if std::is_convertible_v&lt;U&amp;&amp;, T&gt; is false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20e852381d96f28d018964262e349c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e852381d96f28d018964262e349c7b">&#9670;&nbsp;</a></span>optional() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T, std::enable_if_t&lt; detail::optional_is_value_convertible&lt; T, U &gt;::value &amp;&amp;!std::is_convertible&lt; U &amp;&amp;, T &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a> </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an optional object that contains a value. </p>
<p>The value is initialized as if direct-initializing (but not direct-list-initializing) an object of type T with the expression value.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is constexpr if the constructor of T selected by direct-initialization is constexpr</dd>
<dd>
This constructor does not participate in overload resolution unless std::is_constructible_v&lt;T, U&amp;&amp;&gt; is true and std::decay_t&lt;U&gt; is neither std::in_place_t nor optional&lt;T&gt;.</dd>
<dd>
This constructor is explicit if and only if std::is_convertible_v&lt;U&amp;&amp;, T&gt; is false</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aed857da053914817a13117384c2ae26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed857da053914817a13117384c2ae26c">&#9670;&nbsp;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt;std::decay_t&lt;U&gt; &gt; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>u</code> if this optional contains a value, nullopt otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>optional </td></tr>
    <tr><td class="paramname">u</td><td>the value to return as an optional </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an optional of <code>u</code> if this contains a value </dd></dl>

</div>
</div>
<a id="af0dad403b669a27eca24c6d1c3077782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dad403b669a27eca24c6d1c3077782">&#9670;&nbsp;</a></span>emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the contained value in-place. </p>
<p>If <code>*this</code> already contains a value before the call, the contained value is destroyed by calling its destructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args...</td><td>the arguments to pass to the constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4890e8897b502acd09a56f8014245d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4890e8897b502acd09a56f8014245d56">&#9670;&nbsp;</a></span>emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the contained value in-place. </p>
<p>If <code>*this</code> already contains a value before the call, the contained value is destroyed by calling its destructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>the initializer list to pass to the constructor </td></tr>
    <tr><td class="paramname">args...</td><td>the arguments to pass to the constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eaf0aaec69e81d55d1e9622e4a277c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaf0aaec69e81d55d1e9622e4a277c0">&#9670;&nbsp;</a></span>flat_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename  = std::enable_if_t&lt;conjunction&lt;is_invocable&lt;Fn,const T&amp;&gt;,                                         is_optional&lt;invoke_result_t&lt;Fn,const T&amp;&gt;&gt;&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">invoke_result_t&lt;Fn,const T&amp;&gt; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::flat_map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the function <code>fn</code> with this optional as the argument. </p>
<p>If this optional is nullopt, this function returns nullopt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function being called </dd></dl>

</div>
</div>
<a id="a5a02d9b500b2bccc88094d807addcdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a02d9b500b2bccc88094d807addcdaf">&#9670;&nbsp;</a></span>has_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::has_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>*this</code> contains a value. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> contains a value, <code>false</code> if <code>*this</code> does not contain a value </dd></dl>

</div>
</div>
<a id="a44aea889caccc4972029b32182ffe451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44aea889caccc4972029b32182ffe451">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename  = std::enable_if_t&lt;is_invocable&lt;Fn,const T&amp;&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt;invoke_result_t&lt;Fn,const T&amp;&gt; &gt; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::map </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes this function <code>fn</code> with this optional as the argument. </p>
<p>If this optional is nullopt, the result of this function is nullopt. Otherwise this function wraps the result and returns it as an optional</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>the function to invoke with this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optional result of the function invoked </dd></dl>

</div>
</div>
<a id="a24e1a0030e8bd73410c1e08c80953cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e1a0030e8bd73410c1e08c80953cc8">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>*this</code> contains a value. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> contains a value, <code>false</code> if <code>*this</code> does not contain a value </dd></dl>

</div>
</div>
<a id="a8beb4897e960ee7aedd6d5995adde9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8beb4897e960ee7aedd6d5995adde9c7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a>&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="a14561db34b29ff82db584b1b873eaa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14561db34b29ff82db584b1b873eaa24">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a>&amp;&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="accc172a1590b1f334e71273cbf3797d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc172a1590b1f334e71273cbf3797d3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> const&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="a5b9ad409a5edfdb807109a4d925ee544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9ad409a5edfdb807109a4d925ee544">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> const&amp;&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behaviour is undefined if <code>*this</code> does not contain a value</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the contained value </dd></dl>

</div>
</div>
<a id="ab6ad2c2e6d15f15a570b8ca726e67362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ad2c2e6d15f15a570b8ca726e67362">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a>* <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behavior is undefined if <code>*this</code> does not contain a value.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the contained value </dd></dl>

</div>
</div>
<a id="afa625977d80672a6d5d6b039c7716040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa625977d80672a6d5d6b039c7716040">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> const* <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses the contained value. </p>
<dl class="section note"><dt>Note</dt><dd>The behavior is undefined if <code>*this</code> does not contain a value.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the contained value </dd></dl>

</div>
</div>
<a id="ab55bc3e80884c1e37f54c02d6a866887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55bc3e80884c1e37f54c02d6a866887">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/da8/structbit_1_1core_1_1nullopt__t.html">nullopt_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns this optional to be a null optional. </p>
<p>If <code></code>(*this) had a value before the call, the contained value is destroyed. </p>

</div>
</div>
<a id="acb59be33d6f5d505e02819a735977cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb59be33d6f5d505e02819a735977cc6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a78b67a176c3a604dee4c2d4d4d8612a1">enable_overload_if_t</a>&lt; std::is_copy_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a> &amp;&amp;std::is_copy_assignable&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;&gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assigns the optional stored in <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other optional to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e01eca2732b976689256916c236e8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e01eca2732b976689256916c236e8e4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d73/namespacebit_1_1core.html#a78b67a176c3a604dee4c2d4d4d8612a1">enable_overload_if_t</a>&lt; std::is_move_constructible&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a> &amp;&amp;std::is_move_assignable&lt; T &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;&amp;&gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assigns the optional stored in <code>other</code>. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>other</code> contained a value before the call, it is left as a null optional</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This assignment does not participate in overload resolution unless U is</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other optional to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a822e56c857733fccfe824612fda941bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822e56c857733fccfe824612fda941bd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T, typename  = std::enable_if_t&lt;detail::optional_is_value_assignable&lt;T,U&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perfect-forwarded assignment. </p>
<p>Depending on whether *this contains a value before the call, the contained value is either direct-initialized from std::forward&lt;U&gt;(value) or assigned from std::forward&lt;U&gt;(value).</p>
<dl class="section note"><dt>Note</dt><dd>The function does not participate in overload resolution unless<ul>
<li>std::decay_t&lt;U&gt; is not optional&lt;T&gt;,</li>
<li>std::is_constructible_v&lt;T, U&gt; is true</li>
<li>std::is_assignable_v&lt;T&amp;, U&gt; is true</li>
<li>and at least one of the following is true:<ul>
<li>T is not a scalar type;</li>
<li>std::decay_t&lt;U&gt; is not T.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to assign to the contained value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code></code>(*this) </dd></dl>

</div>
</div>
<a id="afc8b090358f6867de6cc631ed242012b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8b090358f6867de6cc631ed242012b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::enable_if_t&lt; <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">detail::optional_is_copy_convert_assignable</a>&lt; T, U &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the state of <code>other</code>. </p>
<p>If both *this and other do not contain a value, the function has no effect.</p>
<p>If *this contains a value, but other does not, then the contained value is destroyed by calling its destructor. *this does not contain a value after the call.</p>
<p>If other contains a value, then depending on whether *this contains a value, the contained value is either direct-initialized or assigned from *other.</p>
<dl class="section note"><dt>Note</dt><dd>A moved-from optional still contains a value.</dd>
<dd>
This overload does not participate in overload resolution unless the following conditions are met:<ul>
<li>std::is_constructible_v&lt;T, const U&amp;&gt; and std::is_assignable_v&lt;T&amp;, const U&amp;&gt; are both true.</li>
<li>T is not constructible, convertible, or assignable from any expression of type (possibly const) :optional&lt;U&gt;, i.e., the following 12 type traits are all false:<ul>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
<li>std::is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&amp;&gt;.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another optional object whose contained value to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to (*this) </dd></dl>

</div>
</div>
<a id="a78052cfd9402273c3fc496ea2d404349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78052cfd9402273c3fc496ea2d404349">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::enable_if_t&lt; <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">detail::optional_is_move_convert_assignable</a>&lt; T, U &gt;::<a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943">value</a>, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;&gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the state of <code>other</code>. </p>
<p>If both *this and other do not contain a value, the function has no effect.</p>
<p>If *this contains a value, but other does not, then the contained value is destroyed by calling its destructor. *this does not contain a value after the call.</p>
<p>If other contains a value, then depending on whether *this contains a value, the contained value is either direct-initialized or assigned from std::move(*other).</p>
<dl class="section note"><dt>Note</dt><dd>A moved-from optional still contains a value.</dd>
<dd>
This overload does not participate in overload resolution unless the following conditions are met:<ul>
<li>std::is_constructible_v&lt;T, U&amp;&amp;&gt; and std::is_assignable_v&lt;T&amp;, U&amp;&amp;&gt; are both true.</li>
<li>T is not constructible, convertible, or assignable from any expression of type (possibly const) :optional&lt;U&gt;, i.e., the following 12 type traits are all false:<ul>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_constructible_v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
<li>std::is_convertible_v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</li>
<li>std::is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&gt;</li>
<li>std::is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&amp;&gt;</li>
<li>std::is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&amp;&gt;.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another optional object whose contained value to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to (*this) </dd></dl>

</div>
</div>
<a id="aeb99ded93f533ae5314303434f5b2d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb99ded93f533ae5314303434f5b2d01">&#9670;&nbsp;</a></span>or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt;std::decay_t&lt;U&gt; &gt; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>u</code> if this optional does not contain a value, nullopt otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the value to return as an optional </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an optional of <code>u</code> if this does not contains a value </dd></dl>

</div>
</div>
<a id="a4c03b891355b8e4b30230502b693d7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c03b891355b8e4b30230502b693d7de">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <code>*this</code> contains a value, destroy that value as if by <code><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a4398f940d9db67f77733a2093273b943" title="Returns the contained value. ">value()</a></code>.T::~T(). </p>
<p>Otherwise, there are no effects. <code>*this</code> does not contain a value after this call. </p>

</div>
</div>
<a id="a49a3e8b886467cfcb2759b410c5a9442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a3e8b886467cfcb2759b410c5a9442">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents with those of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the optional object to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4398f940d9db67f77733a2093273b943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4398f940d9db67f77733a2093273b943">&#9670;&nbsp;</a></span>value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a>&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value. </p>
<p>Equivalent to </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> bool(*<span class="keyword">this</span>) ? *val : <span class="keywordflow">throw</span> bad_optional_access();</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../df/d90/classbit_1_1core_1_1bad__optional__access.html" title="An exception thrown when an optional is attempted to be accessed while not containing a value...">bad_optional_access</a></td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a264a3945ec48686fe1f57eab24aa9146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264a3945ec48686fe1f57eab24aa9146">&#9670;&nbsp;</a></span>value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> const&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value. </p>
<p>Equivalent to </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> bool(*<span class="keyword">this</span>) ? *val : <span class="keywordflow">throw</span> bad_optional_access();</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../df/d90/classbit_1_1core_1_1bad__optional__access.html" title="An exception thrown when an optional is attempted to be accessed while not containing a value...">bad_optional_access</a></td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="aa14377b00f68f008410136b80d225340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14377b00f68f008410136b80d225340">&#9670;&nbsp;</a></span>value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a>&amp;&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value. </p>
<p>Equivalent to </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> bool(*<span class="keyword">this</span>) ? std::move(*val) : throw bad_optional_access();</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../df/d90/classbit_1_1core_1_1bad__optional__access.html" title="An exception thrown when an optional is attempted to be accessed while not containing a value...">bad_optional_access</a></td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a71aeba634d2122a8d982101c4c787a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71aeba634d2122a8d982101c4c787a31">&#9670;&nbsp;</a></span>value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a>&amp;&amp; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value. </p>
<p>Equivalent to </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> bool(*<span class="keyword">this</span>) ? std::move(*val) : throw bad_optional_access();</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../df/d90/classbit_1_1core_1_1bad__optional__access.html" title="An exception thrown when an optional is attempted to be accessed while not containing a value...">bad_optional_access</a></td><td>if <code>*this</code> does not contain a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of <code>*this</code> </dd></dl>

</div>
</div>
<a id="a2c8becef3c1135f61a09aae65978bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8becef3c1135f61a09aae65978bc8a">&#9670;&nbsp;</a></span>value_or() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::value_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value if <code>*this</code> has a value, otherwise returns <code>default_value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_value</td><td>the value to use in case <code>*this</code> is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value to use in case <code>*this</code> is empty </dd></dl>

</div>
</div>
<a id="a366b95ec6b40ff66e69e0d8418478e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366b95ec6b40ff66e69e0d8418478e85">&#9670;&nbsp;</a></span>value_or() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html#a414d40491dee22e31c946483afa671fb">value_type</a> <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">bit::core::optional</a>&lt; T &gt;::value_or </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained value if <code>*this</code> has a value, otherwise returns <code>default_value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_value</td><td>the value to use in case <code>*this</code> is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value to use in case <code>*this</code> is empty </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Matthew/Workspace/cppbits/Core/include/bit/core/utilities/<a class="el" href="../../db/dd5/optional_8hpp_source.html">optional.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
