<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bit::core: bit::core::detail Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bit::core
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d9f/namespacebit.html">bit</a></li><li class="navelem"><a class="el" href="../../d9/d73/namespacebit_1_1core.html">core</a></li><li class="navelem"><a class="el" href="../../d1/d6a/namespacebit_1_1core_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bit::core::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Private namespace for managing implementation-details within headers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:d0/dfc/structbit_1_1core_1_1detail_1_1aligned__storage__max"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>aligned_storage_max</b></td></tr>
<tr class="separator:d0/dfc/structbit_1_1core_1_1detail_1_1aligned__storage__max"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>aligned_storage_max&lt; Max &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>aligned_storage_max&lt; Max, Size0, Sizes... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/de9/structbit_1_1core_1_1detail_1_1array__autodeduce"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>array_autodeduce</b></td></tr>
<tr class="separator:d3/de9/structbit_1_1core_1_1detail_1_1array__autodeduce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/d29/structbit_1_1core_1_1detail_1_1array__return__type__helper"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>array_return_type_helper</b></td></tr>
<tr class="separator:d4/d29/structbit_1_1core_1_1detail_1_1array__return__type__helper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>array_return_type_helper&lt; array_autodeduce, Types... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/d0d/classbit_1_1core_1_1detail_1_1compressed__pair__impl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_pair_impl</b></td></tr>
<tr class="separator:d9/d0d/classbit_1_1core_1_1detail_1_1compressed__pair__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_pair_impl&lt; T1, T1, true, true &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d21/classbit_1_1core_1_1detail_1_1compressed__pair__impl_3_01_t1_00_01_t2_00_01false_00_01false_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_pair_impl&lt; T1, T2, false, false &gt;</b></td></tr>
<tr class="separator:d6/d21/classbit_1_1core_1_1detail_1_1compressed__pair__impl_3_01_t1_00_01_t2_00_01false_00_01false_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_pair_impl&lt; T1, T2, false, true &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_pair_impl&lt; T1, T2, true, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_pair_impl&lt; T1, T2, true, true &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d96/classbit_1_1core_1_1detail_1_1compressed__tuple__impl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_tuple_impl</b></td></tr>
<tr class="separator:de/d96/classbit_1_1core_1_1detail_1_1compressed__tuple__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/d64/classbit_1_1core_1_1detail_1_1compressed__tuple__impl_3_01_idx_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_tuple_impl&lt; Idx &gt;</b></td></tr>
<tr class="separator:df/d64/classbit_1_1core_1_1detail_1_1compressed__tuple__impl_3_01_idx_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_tuple_impl&lt; Idx, T0, Ts... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d27/classbit_1_1core_1_1detail_1_1compressed__tuple__storage"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_tuple_storage</b></td></tr>
<tr class="separator:de/d27/classbit_1_1core_1_1detail_1_1compressed__tuple__storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/d6b/classbit_1_1core_1_1detail_1_1compressed__tuple__storage_3_01_idx_00_01_t_00_01false_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_tuple_storage&lt; Idx, T, false &gt;</b></td></tr>
<tr class="separator:d5/d6b/classbit_1_1core_1_1detail_1_1compressed__tuple__storage_3_01_idx_00_01_t_00_01false_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compressed_tuple_storage&lt; Idx, T, true &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>conversion_index</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>conversion_index&lt; T, variant&lt; Types... &gt;, void_t&lt; decltype(std::declval&lt; variant_f&lt; Types... &gt;&gt;()(std::declval&lt; T &gt;()))&gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/df7/structbit_1_1core_1_1detail_1_1conversion__type__or__void__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>conversion_type_or_void_impl</b></td></tr>
<tr class="separator:d4/df7/structbit_1_1core_1_1detail_1_1conversion__type__or__void__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>conversion_type_or_void_impl&lt; I, variant&lt; Types... &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>conversion_type_or_void_impl&lt; std::size_t(-1), variant&lt; Types... &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>cv_selector</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to select the proper cv-qualifiers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>cv_selector&lt; Unqualified, false, true &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>cv_selector&lt; Unqualified, true, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>cv_selector&lt; Unqualified, true, true &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/df2/structbit_1_1core_1_1detail_1_1detector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>detector</b></td></tr>
<tr class="separator:de/df2/structbit_1_1core_1_1detail_1_1detector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/dcb/structbit_1_1core_1_1detail_1_1detector_3_01_default_00_01void__t_3_01_op_3_01_args_8_8_8_01_4_05061065120b3139ed7875926baaebd17"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>detector&lt; Default, void_t&lt; Op&lt; Args... &gt; &gt;, Op, Args... &gt;</b></td></tr>
<tr class="separator:d0/dcb/structbit_1_1core_1_1detail_1_1detector_3_01_default_00_01void__t_3_01_op_3_01_args_8_8_8_01_4_05061065120b3139ed7875926baaebd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/da5/classbit_1_1core_1_1detail_1_1exclusive__ptr__emplace"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>exclusive_ptr_emplace</b></td></tr>
<tr class="separator:d9/da5/classbit_1_1core_1_1detail_1_1exclusive__ptr__emplace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/da1/classbit_1_1core_1_1detail_1_1exclusive__ptr__pointer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>exclusive_ptr_pointer</b></td></tr>
<tr class="separator:d4/da1/classbit_1_1core_1_1detail_1_1exclusive__ptr__pointer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d9f/classbit_1_1core_1_1detail_1_1expected__base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>expected_base</b></td></tr>
<tr class="separator:d6/d9f/classbit_1_1core_1_1detail_1_1expected__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/dd9/classbit_1_1core_1_1detail_1_1expected__base_3_01false_00_01_t_00_01_e_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>expected_base&lt; false, T, E &gt;</b></td></tr>
<tr class="separator:d6/dd9/classbit_1_1core_1_1detail_1_1expected__base_3_01false_00_01_t_00_01_e_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d4c/classbit_1_1core_1_1detail_1_1expected__base_3_01true_00_01_t_00_01_e_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>expected_base&lt; true, T, E &gt;</b></td></tr>
<tr class="separator:de/d4c/classbit_1_1core_1_1detail_1_1expected__base_3_01true_00_01_t_00_01_e_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d48/structbit_1_1core_1_1detail_1_1function__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>function_t</b></td></tr>
<tr class="separator:dd/d48/structbit_1_1core_1_1detail_1_1function__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/def/structbit_1_1core_1_1detail_1_1function__t_3_01_r_07_args_8_8_8_08_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>function_t&lt; R(Args...)&gt;</b></td></tr>
<tr class="separator:dc/def/structbit_1_1core_1_1detail_1_1function__t_3_01_r_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>has_data_member_function</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>has_data_member_function&lt; T, void_t&lt; decltype(std::declval&lt; T &gt;().data())&gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>has_size_member_function</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>has_size_member_function&lt; T, void_t&lt; decltype(std::declval&lt; T &gt;().size())&gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_from</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_from_constructible</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d66/structbit_1_1core_1_1detail_1_1index__from__constructible__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_from_constructible_impl</b></td></tr>
<tr class="separator:da/d66/structbit_1_1core_1_1detail_1_1index__from__constructible__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_from_constructible_impl&lt; I, T &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_from_constructible_impl&lt; I, T, T0, Ts... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/dcc/structbit_1_1core_1_1detail_1_1index__from__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_from_impl</b></td></tr>
<tr class="separator:d6/dcc/structbit_1_1core_1_1detail_1_1index__from__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_from_impl&lt; I, T, T, Ts... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_from_impl&lt; I, T, T0, Ts... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d86/structbit_1_1core_1_1detail_1_1index__of__type__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_of_type_impl</b></td></tr>
<tr class="separator:db/d86/structbit_1_1core_1_1detail_1_1index__of__type__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_of_type_impl&lt; I, T, T, Types... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>index_of_type_impl&lt; I, T, Type0, Types... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_allowed_element_type_conversion</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_allowed_extent_conversion</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_associative_container_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_associative_container_impl&lt; T, void_t&lt; typename T::value_type, typename T::reference, typename T::const_reference, typename T::iterator, typename T::const_iterator, typename T::difference_type, typename T::size_type, decltype(typename T::iterator(std::declval&lt; T &amp; &gt;().begin())), decltype(typename T::iterator(std::declval&lt; T &amp; &gt;().end())), decltype(typename T::const_iterator(std::declval&lt; T &amp; &gt;().cbegin())), decltype(typename T::const_iterator(std::declval&lt; T &amp; &gt;().cend())), decltype(bool(std::declval&lt; T &amp; &gt;()==std::declval&lt; T &amp; &gt;())), decltype(bool(std::declval&lt; T &amp; &gt;() !=std::declval&lt; T &amp; &gt;())), decltype(std::declval&lt; T &amp; &gt;().swap(std::declval&lt; T &amp; &gt;())), decltype(typename T::size_type(std::declval&lt; T &amp; &gt;().size())), decltype(typename T::size_type(std::declval&lt; T &amp; &gt;().max_size())), decltype(bool(std::declval&lt; T &amp; &gt;().empty())) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bidirectional_iterator_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_bidirectional_iterator_impl&lt; T, void_t&lt; decltype(--std::declval&lt; T &amp; &gt;()), decltype(std::declval&lt; T &amp; &gt;() --), decltype(*std::declval&lt; T &amp; &gt;() --) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_constructible</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_container_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_container_impl&lt; T, void_t&lt; typename T::value_type, typename T::reference, typename T::const_reference, typename T::iterator, typename T::const_iterator, typename T::difference_type, typename T::size_type, decltype(typename T::iterator(std::declval&lt; T &amp; &gt;().begin())), decltype(typename T::iterator(std::declval&lt; T &amp; &gt;().end())), decltype(typename T::const_iterator(std::declval&lt; const T &amp; &gt;().cbegin())), decltype(typename T::const_iterator(std::declval&lt; const T &amp; &gt;().cend())), decltype(bool(std::declval&lt; const T &amp; &gt;()==std::declval&lt; const T &amp; &gt;())), decltype(bool(std::declval&lt; const T &amp; &gt;() !=std::declval&lt; const T &amp; &gt;())), decltype(std::declval&lt; T &amp; &gt;().swap(std::declval&lt; T &amp; &gt;())), decltype(typename T::size_type(std::declval&lt; const T &amp; &gt;().size())), decltype(typename T::size_type(std::declval&lt; const T &amp; &gt;().max_size())), decltype(bool(std::declval&lt; const T &amp; &gt;().empty())) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_contiguous_container_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_contiguous_container_impl&lt; T, void_t&lt; decltype(std::declval&lt; const typename T::value_type *&amp; &gt;()=std::declval&lt; const T &amp; &gt;().data()) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_equality_comparable_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_equality_comparable_impl&lt; T, void_t&lt; decltype(bool(std::declval&lt; const T &amp; &gt;()==std::declval&lt; const T &amp; &gt;())) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_explicit_constructible</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_explicitly_constructible_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_explicitly_constructible_impl&lt; T, type_list&lt; Args... &gt;, void_t&lt; decltype(T(std::declval&lt; Args &gt;()...)) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/df0/structbit_1_1core_1_1detail_1_1is__explicitly__convertible__dummy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_explicitly_convertible_dummy</b></td></tr>
<tr class="separator:d9/df0/structbit_1_1core_1_1detail_1_1is__explicitly__convertible__dummy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_explicitly_convertible_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_explicitly_convertible_impl&lt; From, To, void_t&lt; decltype(is_explicitly_convertible_dummy&lt; To &gt;::test(static_cast&lt; To &gt;(std::declval&lt; From &gt;()))) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_hashable_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_hashable_impl&lt; T, void_t&lt; decltype(std::declval&lt;::bit::core::hash_t &amp; &gt;()=hash_value(std::declval&lt; T &gt;()))&gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/d47/structbit_1_1core_1_1detail_1_1is__implicitly__constructible__dummy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_implicitly_constructible_dummy</b></td></tr>
<tr class="separator:d1/d47/structbit_1_1core_1_1detail_1_1is__implicitly__constructible__dummy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_implicitly_constructible_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_implicitly_constructible_impl&lt; T, type_list&lt; Args... &gt;, void_t&lt; decltype(is_implicitly_constructible_dummy&lt; T &gt;::test({ std::declval&lt; Args &gt;()... })) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d70/structbit_1_1core_1_1detail_1_1is__implicitly__convertible__dummy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_implicitly_convertible_dummy</b></td></tr>
<tr class="separator:d6/d70/structbit_1_1core_1_1detail_1_1is__implicitly__convertible__dummy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_implicitly_convertible_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_implicitly_convertible_impl&lt; From, To, void_t&lt; decltype(is_implicitly_convertible_dummy&lt; To &gt;::test(std::declval&lt; From &gt;())) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_input_iterator_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_input_iterator_impl&lt; T, void_t&lt; decltype(std::declval&lt; T &amp; &gt;() !=std::declval&lt; T &gt;()), decltype(std::declval&lt; T &amp; &gt;()==std::declval&lt; T &gt;()), decltype(std::declval&lt; T &amp; &gt;()++), decltype(*std::declval&lt; T &amp; &gt;()++) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/de7/structbit_1_1core_1_1detail_1_1is__invocable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_invocable</b></td></tr>
<tr class="separator:dd/de7/structbit_1_1core_1_1detail_1_1is__invocable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_iterator_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_iterator_impl&lt; T, void_t&lt; typename std::iterator_traits&lt; T &gt;::value_type, typename std::iterator_traits&lt; T &gt;::difference_type, typename std::iterator_traits&lt; T &gt;::pointer, typename std::iterator_traits&lt; T &gt;::reference, typename std::iterator_traits&lt; T &gt;::iterator_category, decltype(*std::declval&lt; T &amp; &gt;()), decltype(++std::declval&lt; T &amp; &gt;()) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_not_in_place</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_not_in_place&lt; in_place_index_t&lt; N &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_not_in_place&lt; in_place_t &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_not_in_place&lt; in_place_type_t&lt; T &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_nothrow_hashable_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_nothrow_hashable_impl&lt; T, void_t&lt; decltype(std::declval&lt;::bit::core::hash_t &amp; &gt;()=hash_value(std::declval&lt; T &gt;()))&gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d7c/structbit_1_1core_1_1detail_1_1is__nothrow__invocable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_nothrow_invocable</b></td></tr>
<tr class="separator:dc/d7c/structbit_1_1core_1_1detail_1_1is__nothrow__invocable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_nullable_pointer_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_nullable_pointer_impl&lt; T, void_t&lt; decltype(T(nullptr)), decltype(std::declval&lt; T &amp; &gt;()=nullptr), decltype(std::declval&lt; T &amp; &gt;() !=std::declval&lt; T &amp; &gt;()), decltype(std::declval&lt; T &amp; &gt;()==nullptr), decltype(nullptr==std::declval&lt; T &amp; &gt;()), decltype(std::declval&lt; T &amp; &gt;() !=nullptr), decltype(nullptr !=std::declval&lt; T &amp; &gt;()) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/dcf/structbit_1_1core_1_1detail_1_1is__ptr__observable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_ptr_observable</b></td></tr>
<tr class="separator:d9/dcf/structbit_1_1core_1_1detail_1_1is__ptr__observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_random_access_iterator_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_random_access_iterator_impl&lt; T, void_t&lt; decltype(std::declval&lt; T &amp; &gt;()+=std::declval&lt; typename std::iterator_traits&lt; T &gt;::difference_type &gt;()), decltype(std::declval&lt; T &amp; &gt;()+std::declval&lt; typename std::iterator_traits&lt; T &gt;::difference_type &gt;()), decltype(std::declval&lt; typename std::iterator_traits&lt; T &gt;::difference_type &gt;()+std::declval&lt; T &amp; &gt;()), decltype(std::declval&lt; T &amp; &gt;() -=std::declval&lt; typename std::iterator_traits&lt; T &gt;::difference_type &gt;()), decltype(std::declval&lt; T &amp; &gt;() - std::declval&lt; typename std::iterator_traits&lt; T &gt;::difference_type &gt;()), decltype(std::declval&lt; T &amp; &gt;() - std::declval&lt; T &amp; &gt;()), decltype(std::declval&lt; T &amp; &gt;()[std::declval&lt; typename std::iterator_traits&lt; T &gt;::difference_type &gt;()]), decltype(static_cast&lt; bool &gt;(std::declval&lt; T &amp; &gt;()&lt; std::declval&lt; T &amp; &gt;())), decltype(static_cast&lt; bool &gt;(std::declval&lt; T &amp; &gt;() &gt; std::declval&lt; T &amp; &gt;())), decltype(static_cast&lt; bool &gt;(std::declval&lt; T &amp; &gt;()&lt;=std::declval&lt; T &amp; &gt;())), decltype(static_cast&lt; bool &gt;(std::declval&lt; T &amp; &gt;() &gt;=std::declval&lt; T &amp; &gt;())) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_range_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_range_impl&lt; T, void_t&lt; decltype(std::declval&lt; T &gt;().begin()), decltype(std::declval&lt; T &gt;().end()) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_reference_wrapper</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_reference_wrapper&lt; std::reference_wrapper&lt; U &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_reverse_range_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_reverse_range_impl&lt; T, void_t&lt; decltype(std::declval&lt; T &gt;().begin()), decltype(std::declval&lt; T &gt;().end()) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_reversible_container_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_reversible_container_impl&lt; T, void_t&lt; typename T::reverse_iterator, typename T::const_reverse_iterator, decltype(typename T::reverse_iterator(std::declval&lt; T &amp; &gt;().rbegin())), decltype(typename T::reverse_iterator(std::declval&lt; T &amp; &gt;().rend())), decltype(typename T::const_reverse_iterator(std::declval&lt; T &amp; &gt;().crbegin())), decltype(typename T::const_reverse_iterator(std::declval&lt; T &amp; &gt;().crend())) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_sequence_container_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_sequence_container_impl&lt; T, void_t&lt; decltype(std::declval&lt; T &amp; &gt;().insert(std::declval&lt; typename T::const_iterator &gt;(), std::declval&lt; const typename T::value_type &amp; &gt;())), decltype(std::declval&lt; T &amp; &gt;().insert(std::declval&lt; typename T::const_iterator &gt;(), std::declval&lt; typename T::value_type &amp;&amp; &gt;())), decltype(std::declval&lt; T &amp; &gt;().insert(std::declval&lt; typename T::const_iterator &gt;(), std::declval&lt; typename T::size_type &gt;(), std::declval&lt; const typename T::value_type &amp; &gt;())), decltype(std::declval&lt; T &amp; &gt;().insert(std::declval&lt; typename T::const_iterator &gt;(), std::declval&lt; const T * &gt;(), std::declval&lt; const T * &gt;())), decltype(std::declval&lt; T &amp; &gt;().insert(std::declval&lt; typename T::const_iterator &gt;(), std::declval&lt; std::initializer_list&lt; typename T::value_type &gt;&gt;())), decltype(std::declval&lt; T &amp; &gt;().erase(std::declval&lt; typename T::const_iterator &gt;())), decltype(std::declval&lt; T &amp; &gt;().erase(std::declval&lt; typename T::const_iterator &gt;(), std::declval&lt; typename T::const_iterator &gt;())), decltype(std::declval&lt; T &amp; &gt;().clear()), decltype(std::declval&lt; T &amp; &gt;().assign(std::declval&lt; typename T::iterator &gt;(), std::declval&lt; typename T::iterator &gt;())), decltype(std::declval&lt; T &amp; &gt;().assign(std::declval&lt; std::initializer_list&lt; typename T::value_type &gt;&gt;())), decltype(std::declval&lt; T &amp; &gt;().assign(std::declval&lt; typename T::size_type &gt;(), std::declval&lt; typename T::value_type &gt;())), decltype(typename T::reference(std::declval&lt; T &amp; &gt;().front())), decltype(typename T::const_reference(std::declval&lt; const T &amp; &gt;().front())), decltype(typename T::reference(std::declval&lt; T &amp; &gt;().back())), decltype(typename T::const_reference(std::declval&lt; const T &amp; &gt;().back())), decltype(std::declval&lt; T &amp; &gt;().push_front(std::declval&lt; const typename T::value_type &amp; &gt;())), decltype(std::declval&lt; T &amp; &gt;().push_front(std::declval&lt; typename T::value_type &amp;&amp; &gt;())), decltype(std::declval&lt; T &amp; &gt;().push_back(std::declval&lt; const typename T::value_type &amp; &gt;())), decltype(std::declval&lt; T &amp; &gt;().push_back(std::declval&lt; typename T::value_type &amp;&amp; &gt;())), decltype(std::declval&lt; T &amp; &gt;().pop_front()), decltype(std::declval&lt; T &amp; &gt;().pop_back()), decltype(typename T::reference(std::declval&lt; T &amp; &gt;()[std::declval&lt; typename T::size_type &gt;()])), decltype(typename T::const_reference(std::declval&lt; const T &amp; &gt;()[std::declval&lt; typename T::size_type &gt;()])), decltype(typename T::reference(std::declval&lt; T &amp; &gt;().at(std::declval&lt; typename T::size_type &gt;()))), decltype(typename T::const_reference(std::declval&lt; const T &amp; &gt;().at(std::declval&lt; typename T::size_type &gt;()))) &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_string_span</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_string_span&lt; basic_string_span&lt; CharT, Traits, Extent &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_string_span&lt; basic_zstring_span&lt; CharT, Traits, Extent &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_zstring_span</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_zstring_span&lt; basic_zstring_span&lt; CharT, Traits, Extent &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>lazy_is_direct_init_assignable</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>lazy_is_direct_initializable</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>lazy_is_enabled_assignment_base</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>lazy_is_enabled_copy_assignment</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>lazy_is_enabled_copy_ctor</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>lazy_is_enabled_ctor_base</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>lazy_is_enabled_move_assignment</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>lazy_is_enabled_move_ctor</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/d2d/structbit_1_1core_1_1detail_1_1member__function__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>member_function_t</b></td></tr>
<tr class="separator:d9/d2d/structbit_1_1core_1_1detail_1_1member__function__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/dbb/structbit_1_1core_1_1detail_1_1member__function__t_3_01const_01_t_00_01_r_07_args_8_8_8_08_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>member_function_t&lt; const T, R(Args...)&gt;</b></td></tr>
<tr class="separator:dd/dbb/structbit_1_1core_1_1detail_1_1member__function__t_3_01const_01_t_00_01_r_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d60/structbit_1_1core_1_1detail_1_1member__function__t_3_01const_01volatile_01_t_00_01_r_07_args_8_8_8_08_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>member_function_t&lt; const volatile T, R(Args...)&gt;</b></td></tr>
<tr class="separator:dd/d60/structbit_1_1core_1_1detail_1_1member__function__t_3_01const_01volatile_01_t_00_01_r_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/dec/structbit_1_1core_1_1detail_1_1member__function__t_3_01_t_00_01_r_07_args_8_8_8_08_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>member_function_t&lt; T, R(Args...)&gt;</b></td></tr>
<tr class="separator:dc/dec/structbit_1_1core_1_1detail_1_1member__function__t_3_01_t_00_01_r_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/dfd/structbit_1_1core_1_1detail_1_1member__function__t_3_01volatile_01_t_00_01_r_07_args_8_8_8_08_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>member_function_t&lt; volatile T, R(Args...)&gt;</b></td></tr>
<tr class="separator:d9/dfd/structbit_1_1core_1_1detail_1_1member__function__t_3_01volatile_01_t_00_01_r_07_args_8_8_8_08_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/ddf/classbit_1_1core_1_1detail_1_1optional__base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>optional_base</b></td></tr>
<tr class="separator:df/ddf/classbit_1_1core_1_1detail_1_1optional__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d09/classbit_1_1core_1_1detail_1_1optional__base_3_01_t_00_01false_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>optional_base&lt; T, false &gt;</b></td></tr>
<tr class="separator:dd/d09/classbit_1_1core_1_1detail_1_1optional__base_3_01_t_00_01false_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d31/classbit_1_1core_1_1detail_1_1optional__base_3_01_t_00_01true_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>optional_base&lt; T, true &gt;</b></td></tr>
<tr class="separator:dc/d31/classbit_1_1core_1_1detail_1_1optional__base_3_01_t_00_01true_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>pointer_rank</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>pointer_rank&lt; T *, Count &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>ref_selector</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>ref_selector&lt; Unqualified, false, true &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>ref_selector&lt; Unqualified, true, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/d91/structbit_1_1core_1_1detail_1_1resolves__overload__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>resolves_overload_impl</b></td></tr>
<tr class="separator:de/d91/structbit_1_1core_1_1detail_1_1resolves__overload__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/df4/structbit_1_1core_1_1detail_1_1resolves__overload__impl_3_01_i_00_01_t0_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>resolves_overload_impl&lt; I, T0 &gt;</b></td></tr>
<tr class="separator:dc/df4/structbit_1_1core_1_1detail_1_1resolves__overload__impl_3_01_i_00_01_t0_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>resolves_overload_impl&lt; I, T0, T1, Types... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>resolves_overload_index_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>resolves_overload_index_impl&lt; T, void_t&lt; decltype(std::declval&lt; resolves_overload_impl&lt; 0, Types... &gt;&gt;()(std::declval&lt; T &gt;()))&gt;, Types... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/df7/classbit_1_1core_1_1detail_1_1ring__buffer__iterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ring_buffer_iterator</b></td></tr>
<tr class="memdesc:df/df7/classbit_1_1core_1_1detail_1_1ring__buffer__iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator for iterating the circular buffer. <br /></td></tr>
<tr class="separator:df/df7/classbit_1_1core_1_1detail_1_1ring__buffer__iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>sign_selector</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>sign_selector&lt; Unqualified, false, true &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>sign_selector&lt; Unqualified, true, false &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>span_extent_type</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type used to manage the extent. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/dbf/classbit_1_1core_1_1detail_1_1span__extent__type_3_01dynamic__extent_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>span_extent_type&lt; dynamic_extent &gt;</b></td></tr>
<tr class="separator:d1/dbf/classbit_1_1core_1_1detail_1_1span__extent__type_3_01dynamic__extent_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>string_span_is_string</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/d92/structbit_1_1core_1_1detail_1_1tribool__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>tribool_t</b></td></tr>
<tr class="separator:d2/d92/structbit_1_1core_1_1detail_1_1tribool__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/de8/structbit_1_1core_1_1detail_1_1type__of__member__ptr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>type_of_member_ptr</b></td></tr>
<tr class="separator:d9/de8/structbit_1_1core_1_1detail_1_1type__of__member__ptr"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>type_of_member_ptr&lt; U T::* &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/d8d/classbit_1_1core_1_1detail_1_1variant__base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>variant_base</b></td></tr>
<tr class="separator:df/d8d/classbit_1_1core_1_1detail_1_1variant__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/df5/classbit_1_1core_1_1detail_1_1variant__base_3_01false_00_01_types_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>variant_base&lt; false, Types... &gt;</b></td></tr>
<tr class="separator:d7/df5/classbit_1_1core_1_1detail_1_1variant__base_3_01false_00_01_types_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d21/classbit_1_1core_1_1detail_1_1variant__base_3_01true_00_01_types_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>variant_base&lt; true, Types... &gt;</b></td></tr>
<tr class="separator:d8/d21/classbit_1_1core_1_1detail_1_1variant__base_3_01true_00_01_types_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/dfc/structbit_1_1core_1_1detail_1_1variant__empty"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>variant_empty</b></td></tr>
<tr class="separator:d8/dfc/structbit_1_1core_1_1detail_1_1variant__empty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>variant_f</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/dfa/structbit_1_1core_1_1detail_1_1variant__f__impl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>variant_f_impl</b></td></tr>
<tr class="separator:d6/dfa/structbit_1_1core_1_1detail_1_1variant__f__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/d43/structbit_1_1core_1_1detail_1_1variant__f__impl_3_01_i_00_01_t0_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>variant_f_impl&lt; I, T0 &gt;</b></td></tr>
<tr class="separator:d1/d43/structbit_1_1core_1_1detail_1_1variant__f__impl_3_01_i_00_01_t0_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>variant_f_impl&lt; I, T0, T1, Types... &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/dd6/unionbit_1_1core_1_1detail_1_1variant__union"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><b>variant_union</b></td></tr>
<tr class="separator:d6/dd6/unionbit_1_1core_1_1detail_1_1variant__union"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/dec/unionbit_1_1core_1_1detail_1_1variant__union_3_01_b_01_4"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><b>variant_union&lt; B &gt;</b></td></tr>
<tr class="separator:d7/dec/unionbit_1_1core_1_1detail_1_1variant__union_3_01_b_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d4d/unionbit_1_1core_1_1detail_1_1variant__union_3_01false_00_01_type0_00_01_types_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><b>variant_union&lt; false, Type0, Types... &gt;</b></td></tr>
<tr class="separator:d3/d4d/unionbit_1_1core_1_1detail_1_1variant__union_3_01false_00_01_type0_00_01_types_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/d3d/unionbit_1_1core_1_1detail_1_1variant__union_3_01true_00_01_type0_00_01_types_8_8_8_01_4"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><b>variant_union&lt; true, Type0, Types... &gt;</b></td></tr>
<tr class="separator:d2/d3d/unionbit_1_1core_1_1detail_1_1variant__union_3_01true_00_01_type0_00_01_types_8_8_8_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d01/structbit_1_1core_1_1detail_1_1variant__union__has__next"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>variant_union_has_next</b></td></tr>
<tr class="separator:d6/d01/structbit_1_1core_1_1detail_1_1variant__union__has__next"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>variant_union_has_next&lt; variant_union&lt; B, T &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>variant_union_has_next&lt; variant_union&lt; B, Types... &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>voidify</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct helper for void_t <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2058ab58ee4e9707a849c1db8cf5ddb8"><td class="memTemplParams" colspan="2"><a id="a2058ab58ee4e9707a849c1db8cf5ddb8"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a2058ab58ee4e9707a849c1db8cf5ddb8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_return_type_helper_t</b> = typename array_return_type_helper&lt; T, Ts... &gt;::type</td></tr>
<tr class="separator:a2058ab58ee4e9707a849c1db8cf5ddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3510e8d3da32e1e4cf9ddfc82983d736"><td class="memTemplParams" colspan="2"><a id="a3510e8d3da32e1e4cf9ddfc82983d736"></a>
template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a3510e8d3da32e1e4cf9ddfc82983d736"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array_return_type_t</b> = std::array&lt; array_return_type_helper_t&lt; T, Types... &gt;, sizeof...(Types)&gt;</td></tr>
<tr class="separator:a3510e8d3da32e1e4cf9ddfc82983d736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4284bcde600e784c8d0815cbfdb9331"><td class="memTemplParams" colspan="2"><a id="af4284bcde600e784c8d0815cbfdb9331"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4284bcde600e784c8d0815cbfdb9331"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_observer_element_type_t</b> = std::remove_pointer_t&lt; std::decay_t&lt; decltype(std::declval&lt; T &gt;().<a class="el" href="../../d9/d73/namespacebit_1_1core.html#a47d690dc876b4908b42c8d33f73fe6a9">get</a>())&gt; &gt;</td></tr>
<tr class="separator:af4284bcde600e784c8d0815cbfdb9331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7af2259c308e508f183a6a3e9d23c1b"><td class="memTemplParams" colspan="2"><a id="af7af2259c308e508f183a6a3e9d23c1b"></a>
template&lt;typename Range &gt; </td></tr>
<tr class="memitem:af7af2259c308e508f183a6a3e9d23c1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reverse_range_t</b> = <a class="el" href="../../d0/d23/classbit_1_1core_1_1range.html">range</a>&lt; decltype(std::declval&lt; Range &amp; &gt;().rbegin()), decltype(std::declval&lt; Range &amp; &gt;().rend())&gt;</td></tr>
<tr class="separator:af7af2259c308e508f183a6a3e9d23c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c4d6fc75ea57bac4918e9ce144c106"><td class="memTemplParams" colspan="2"><a id="a87c4d6fc75ea57bac4918e9ce144c106"></a>
template&lt;typename Ptr &gt; </td></tr>
<tr class="memitem:a87c4d6fc75ea57bac4918e9ce144c106"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_of_member_ptr_t</b> = typename type_of_member_ptr&lt; Ptr &gt;::type</td></tr>
<tr class="separator:a87c4d6fc75ea57bac4918e9ce144c106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae010f7e6bbc36789a5368ac33683935f"><td class="memTemplParams" colspan="2"><a id="ae010f7e6bbc36789a5368ac33683935f"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae010f7e6bbc36789a5368ac33683935f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_is_convertible</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a>&lt; std::is_constructible&lt; T, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp; &gt;, std::is_constructible&lt; T, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp; &gt;, std::is_constructible&lt; T, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp; &gt;, std::is_constructible&lt; T, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp; &gt;, std::is_convertible&lt; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;, T &gt;, std::is_convertible&lt; const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;, T &gt;, std::is_convertible&lt; <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;, T &gt;, std::is_convertible&lt; const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp;, T &gt; &gt;</td></tr>
<tr class="separator:ae010f7e6bbc36789a5368ac33683935f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2ddf0867dd13980e980d9011434459"><td class="memTemplParams" colspan="2"><a id="aca2ddf0867dd13980e980d9011434459"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aca2ddf0867dd13980e980d9011434459"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_is_copy_convertible</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a>&lt; <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">optional_is_convertible</a>&lt; T, U &gt;, std::is_constructible&lt; T, const U &amp; &gt; &gt;</td></tr>
<tr class="separator:aca2ddf0867dd13980e980d9011434459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac805ca8ef9543cda3a9dba2b62fb06b2"><td class="memTemplParams" colspan="2"><a id="ac805ca8ef9543cda3a9dba2b62fb06b2"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac805ca8ef9543cda3a9dba2b62fb06b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_is_move_convertible</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a>&lt; <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">optional_is_convertible</a>&lt; T, U &gt;, std::is_constructible&lt; T, U &amp;&amp; &gt; &gt;</td></tr>
<tr class="separator:ac805ca8ef9543cda3a9dba2b62fb06b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb478ab816cff42d0bb96b400014971"><td class="memTemplParams" colspan="2"><a id="accb478ab816cff42d0bb96b400014971"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:accb478ab816cff42d0bb96b400014971"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_is_value_convertible</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a>&lt; std::is_constructible&lt; T, U &amp;&amp; &gt;, <a class="el" href="../../de/d5e/structbit_1_1core_1_1negation.html">negation</a>&lt; std::is_same&lt; std::decay_t&lt; U &gt;, <a class="el" href="../../dd/d6f/structbit_1_1core_1_1in__place__t.html">in_place_t</a> &gt; &gt;, <a class="el" href="../../de/d5e/structbit_1_1core_1_1negation.html">negation</a>&lt; std::is_same&lt; std::decay_t&lt; U &gt;, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &gt;&gt; &gt;</td></tr>
<tr class="separator:accb478ab816cff42d0bb96b400014971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e2c49f8437ec60919e7e927179996d"><td class="memTemplParams" colspan="2"><a id="aa1e2c49f8437ec60919e7e927179996d"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa1e2c49f8437ec60919e7e927179996d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_is_convert_assignable</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a>&lt; <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">optional_is_convertible</a>&lt; T, U &gt;, std::is_assignable&lt; T &amp;, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp; &gt;, std::is_assignable&lt; T &amp;, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp; &gt;, std::is_assignable&lt; T &amp;, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp; &gt;, std::is_assignable&lt; T &amp;, const <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; U &gt; &amp;&amp; &gt; &gt;</td></tr>
<tr class="separator:aa1e2c49f8437ec60919e7e927179996d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fb41e58d11165a769a7088747bbbf9"><td class="memTemplParams" colspan="2"><a id="a74fb41e58d11165a769a7088747bbbf9"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a74fb41e58d11165a769a7088747bbbf9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_is_copy_convert_assignable</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a>&lt; <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">optional_is_convert_assignable</a>&lt; T, U &gt;, std::is_constructible&lt; T, const U &amp; &gt;, std::is_assignable&lt; T &amp;, const U &amp; &gt; &gt;</td></tr>
<tr class="separator:a74fb41e58d11165a769a7088747bbbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367e97bcac33fd85b84f39ff625a2df4"><td class="memTemplParams" colspan="2"><a id="a367e97bcac33fd85b84f39ff625a2df4"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a367e97bcac33fd85b84f39ff625a2df4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_is_move_convert_assignable</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a>&lt; <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">optional_is_convert_assignable</a>&lt; T, U &gt;, std::is_constructible&lt; T, U &amp;&amp; &gt;, std::is_assignable&lt; T &amp;, U &amp;&amp; &gt; &gt;</td></tr>
<tr class="separator:a367e97bcac33fd85b84f39ff625a2df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131c177b3a7c394400fc36ec3200a59d"><td class="memTemplParams" colspan="2"><a id="a131c177b3a7c394400fc36ec3200a59d"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a131c177b3a7c394400fc36ec3200a59d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_is_value_assignable</b> = <a class="el" href="../../d9/d73/namespacebit_1_1core.html#d7/d95/structbit_1_1core_1_1conjunction">conjunction</a>&lt; <a class="el" href="../../de/d5e/structbit_1_1core_1_1negation.html">negation</a>&lt; std::is_same&lt; std::decay_t&lt; U &gt;, <a class="el" href="../../db/d56/classbit_1_1core_1_1optional.html">optional</a>&lt; T &gt; &gt;&gt;, std::is_constructible&lt; T, U &gt;, std::is_assignable&lt; T, U &gt;, <a class="el" href="../../d5/de0/structbit_1_1core_1_1disjunction.html">disjunction</a>&lt; <a class="el" href="../../de/d5e/structbit_1_1core_1_1negation.html">negation</a>&lt; std::is_same&lt; std::decay_t&lt; U &gt;, T &gt; &gt;, <a class="el" href="../../de/d5e/structbit_1_1core_1_1negation.html">negation</a>&lt; std::is_scalar&lt; T &gt; &gt; &gt; &gt;</td></tr>
<tr class="separator:a131c177b3a7c394400fc36ec3200a59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcfab3627bb04abb9931371ba304594"><td class="memTemplParams" colspan="2"><a id="a1fcfab3627bb04abb9931371ba304594"></a>
template&lt;typename T , typename Variant &gt; </td></tr>
<tr class="memitem:a1fcfab3627bb04abb9931371ba304594"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conversion_type_or_void_t</b> = typename conversion_type_or_void_impl&lt; conversion_index_v&lt; T, Variant &gt;, Variant &gt;::type</td></tr>
<tr class="separator:a1fcfab3627bb04abb9931371ba304594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a99f4ea90b0b3bf90b77556aab08653c9"><td class="memTemplParams" colspan="2"><a id="a99f4ea90b0b3bf90b77556aab08653c9"></a>
template&lt;typename C , typename T &gt; </td></tr>
<tr class="memitem:a99f4ea90b0b3bf90b77556aab08653c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const ring_buffer_iterator&lt; C, T &gt; &amp;lhs, const ring_buffer_iterator&lt; C, T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a99f4ea90b0b3bf90b77556aab08653c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2315ad52c2f01648dbeeb30678b5123a"><td class="memTemplParams" colspan="2"><a id="a2315ad52c2f01648dbeeb30678b5123a"></a>
template&lt;typename C , typename T &gt; </td></tr>
<tr class="memitem:a2315ad52c2f01648dbeeb30678b5123a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const ring_buffer_iterator&lt; C, T &gt; &amp;lhs, const ring_buffer_iterator&lt; C, T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a2315ad52c2f01648dbeeb30678b5123a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7681347792c6e8599da11fa8483805c"><td class="memTemplParams" colspan="2"><a id="aa7681347792c6e8599da11fa8483805c"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa7681347792c6e8599da11fa8483805c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_pointer_cast</b> (<a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; U &gt; &amp;&amp;other)</td></tr>
<tr class="separator:aa7681347792c6e8599da11fa8483805c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea00468dbb2cdb5040caa6c4f2dd649"><td class="memTemplParams" colspan="2"><a id="a4ea00468dbb2cdb5040caa6c4f2dd649"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4ea00468dbb2cdb5040caa6c4f2dd649"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_pointer_cast</b> (<a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; U &gt; &amp;&amp;other)</td></tr>
<tr class="separator:a4ea00468dbb2cdb5040caa6c4f2dd649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac633d9b441b9bc6dcf499f012618264f"><td class="memTemplParams" colspan="2"><a id="ac633d9b441b9bc6dcf499f012618264f"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac633d9b441b9bc6dcf499f012618264f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>const_pointer_cast</b> (<a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; U &gt; &amp;&amp;other)</td></tr>
<tr class="separator:ac633d9b441b9bc6dcf499f012618264f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31add529542f3284e07d3ba3b98100a"><td class="memTemplParams" colspan="2"><a id="ad31add529542f3284e07d3ba3b98100a"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad31add529542f3284e07d3ba3b98100a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_pointer_cast</b> (<a class="el" href="../../d9/dfe/classbit_1_1core_1_1exclusive__ptr.html">exclusive_ptr</a>&lt; U &gt; &amp;&amp;other)</td></tr>
<tr class="separator:ad31add529542f3284e07d3ba3b98100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1027539305adfa2c215b08803b255ccf"><td class="memTemplParams" colspan="2"><a id="a1027539305adfa2c215b08803b255ccf"></a>
template&lt;typename Base , typename T , typename Derived , typename... Args&gt; </td></tr>
<tr class="memitem:a1027539305adfa2c215b08803b255ccf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_impl</b> (T Base::*pmf, Derived &amp;&amp;ref, Args &amp;&amp;... args) noexcept(noexcept((std::forward&lt; Derived &gt;(ref).*pmf)(std::forward&lt; Args &gt;(args)...))) -&gt; std::enable_if_t&lt; std::is_function&lt; T &gt;::value &amp;&amp;std::is_base_of&lt; Base, std::decay_t&lt; Derived &gt;&gt;::value, decltype((std::forward&lt; Derived &gt;(ref).*pmf)(std::forward&lt; Args &gt;(args)...))&gt;</td></tr>
<tr class="separator:a1027539305adfa2c215b08803b255ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656bcb39d1d3c0e15132731267569f19"><td class="memTemplParams" colspan="2"><a id="a656bcb39d1d3c0e15132731267569f19"></a>
template&lt;typename Base , typename T , typename RefWrap , typename... Args&gt; </td></tr>
<tr class="memitem:a656bcb39d1d3c0e15132731267569f19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_impl</b> (T Base::*pmf, RefWrap &amp;&amp;ref, Args &amp;&amp;... args) noexcept(noexcept((ref.get().*pmf)(std::forward&lt; Args &gt;(args)...))) -&gt; std::enable_if_t&lt; std::is_function&lt; T &gt;::value &amp;&amp;is_reference_wrapper&lt; std::decay_t&lt; RefWrap &gt;&gt;::value, decltype((ref.get().*pmf)(std::forward&lt; Args &gt;(args)...))&gt;</td></tr>
<tr class="separator:a656bcb39d1d3c0e15132731267569f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f3b3084023df15a77ddc113d5017ec"><td class="memTemplParams" colspan="2"><a id="ad5f3b3084023df15a77ddc113d5017ec"></a>
template&lt;typename Base , typename T , typename Pointer , typename... Args&gt; </td></tr>
<tr class="memitem:ad5f3b3084023df15a77ddc113d5017ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_impl</b> (T Base::*pmf, Pointer &amp;&amp;ptr, Args &amp;&amp;... args) noexcept(noexcept(((*std::forward&lt; Pointer &gt;(ptr)).*pmf)(std::forward&lt; Args &gt;(args)...))) -&gt; std::enable_if_t&lt; std::is_function&lt; T &gt;::value &amp;&amp;!is_reference_wrapper&lt; std::decay_t&lt; Pointer &gt;&gt;::value &amp;&amp;!std::is_base_of&lt; Base, std::decay_t&lt; Pointer &gt;&gt;::value, decltype(((*std::forward&lt; Pointer &gt;(ptr)).*pmf)(std::forward&lt; Args &gt;(args)...))&gt;</td></tr>
<tr class="separator:ad5f3b3084023df15a77ddc113d5017ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcf275c1d57301874619e8eaa848b19"><td class="memTemplParams" colspan="2"><a id="a1fcf275c1d57301874619e8eaa848b19"></a>
template&lt;typename Base , typename T , typename Derived &gt; </td></tr>
<tr class="memitem:a1fcf275c1d57301874619e8eaa848b19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_impl</b> (T Base::*pmd, Derived &amp;&amp;ref) noexcept(noexcept(std::forward&lt; Derived &gt;(ref).*pmd)) -&gt; std::enable_if_t&lt;!std::is_function&lt; T &gt;::value &amp;&amp;std::is_base_of&lt; Base, std::decay_t&lt; Derived &gt;&gt;::value, decltype(std::forward&lt; Derived &gt;(ref).*pmd)&gt;</td></tr>
<tr class="separator:a1fcf275c1d57301874619e8eaa848b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7bb616306baa0f8de380ebb1643724"><td class="memTemplParams" colspan="2"><a id="afa7bb616306baa0f8de380ebb1643724"></a>
template&lt;typename Base , typename T , typename RefWrap &gt; </td></tr>
<tr class="memitem:afa7bb616306baa0f8de380ebb1643724"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_impl</b> (T Base::*pmd, RefWrap &amp;&amp;ref) noexcept(noexcept(ref.get().*pmd)) -&gt; std::enable_if_t&lt;!std::is_function&lt; T &gt;::value &amp;&amp;is_reference_wrapper&lt; std::decay_t&lt; RefWrap &gt;&gt;::value, decltype(ref.get().*pmd)&gt;</td></tr>
<tr class="separator:afa7bb616306baa0f8de380ebb1643724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0f085ff6810c1cd1ba15e0b77c8da6"><td class="memTemplParams" colspan="2"><a id="a8a0f085ff6810c1cd1ba15e0b77c8da6"></a>
template&lt;typename Base , typename T , typename Pointer &gt; </td></tr>
<tr class="memitem:a8a0f085ff6810c1cd1ba15e0b77c8da6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_impl</b> (T Base::*pmd, Pointer &amp;&amp;ptr) noexcept(noexcept((*std::forward&lt; Pointer &gt;(ptr)).*pmd)) -&gt; std::enable_if_t&lt;!std::is_function&lt; T &gt;::value &amp;&amp;!is_reference_wrapper&lt; std::decay_t&lt; Pointer &gt;&gt;::value &amp;&amp;!std::is_base_of&lt; Base, std::decay_t&lt; Pointer &gt;&gt;::value, decltype((*std::forward&lt; Pointer &gt;(ptr)).*pmd)&gt;</td></tr>
<tr class="separator:a8a0f085ff6810c1cd1ba15e0b77c8da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e34cc57d61011992a65965cbe0fe4ff"><td class="memTemplParams" colspan="2"><a id="a8e34cc57d61011992a65965cbe0fe4ff"></a>
template&lt;typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a8e34cc57d61011992a65965cbe0fe4ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_impl</b> (F &amp;&amp;f, Args &amp;&amp;... args) noexcept(noexcept(std::forward&lt; F &gt;(f)(std::forward&lt; Args &gt;(args)...))) -&gt; std::enable_if_t&lt;!std::is_member_pointer&lt; std::decay_t&lt; F &gt;&gt;::value, decltype(std::forward&lt; F &gt;(f)(std::forward&lt; Args &gt;(args)...))&gt;</td></tr>
<tr class="separator:a8e34cc57d61011992a65965cbe0fe4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5931edf15d6e8ed1fa269b54b2a91adb"><td class="memTemplParams" colspan="2"><a id="a5931edf15d6e8ed1fa269b54b2a91adb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5931edf15d6e8ed1fa269b54b2a91adb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_reference_wrapper_v</b> = is_reference_wrapper&lt;T&gt;::value</td></tr>
<tr class="separator:a5931edf15d6e8ed1fa269b54b2a91adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7ddc9d69cac3222d76238d9ea270b4"><td class="memTemplParams" colspan="2"><a id="abf7ddc9d69cac3222d76238d9ea270b4"></a>
template&lt;typename T , typename Variant &gt; </td></tr>
<tr class="memitem:abf7ddc9d69cac3222d76238d9ea270b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conversion_index_v</b> = conversion_index&lt;T,Variant&gt;::value</td></tr>
<tr class="separator:abf7ddc9d69cac3222d76238d9ea270b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Private namespace for managing implementation-details within headers. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
